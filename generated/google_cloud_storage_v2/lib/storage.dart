// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Cloud Storage API.
///
/// Lets you store and retrieve potentially-large, immutable data objects.
library;

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/rpc.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:google_cloud_type/type.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// ## API Overview and Naming Syntax
///
/// The Cloud Storage gRPC API allows applications to read and write data through
/// the abstractions of buckets and objects. For a description of these
/// abstractions please see https://cloud.google.com/storage/docs.
///
/// Resources are named as follows:
///   - Projects are referred to as they are defined by the Resource Manager API,
///     using strings like `projects/123456` or `projects/my-string-id`.
///   - Buckets are named using string names of the form:
///     `projects/{project}/buckets/{bucket}`
///     For globally unique buckets, `_` may be substituted for the project.
///   - Objects are uniquely identified by their name along with the name of the
///     bucket they belong to, as separate strings in this API. For example:
///
///       ReadObjectRequest {
///         bucket: 'projects/_/buckets/my-bucket'
///         object: 'my-object'
///       }
///     Note that object names can contain `/` characters, which are treated as
///     any other character (no special directory semantics).
final class Storage {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `Storage` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `Storage`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  Storage({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `Storage` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory Storage.fromApiKey([String? apiKey]) {
    return Storage(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Request message for DeleteBucket.
final class DeleteBucketRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.DeleteBucketRequest';

  /// Required. Name of a bucket to delete.
  final String name;

  /// If set, only deletes the bucket if its metageneration matches this value.
  final int? ifMetagenerationMatch;

  /// If set, only deletes the bucket if its metageneration does not match this
  /// value.
  final int? ifMetagenerationNotMatch;

  DeleteBucketRequest({
    required this.name,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
  }) : super(fullyQualifiedName);

  factory DeleteBucketRequest.fromJson(Map<String, dynamic> json) {
    return DeleteBucketRequest(
      name: json['name'] ?? '',
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
    ].join(',');
    return 'DeleteBucketRequest($contents)';
  }
}

/// Request message for GetBucket.
final class GetBucketRequest extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.GetBucketRequest';

  /// Required. Name of a bucket.
  final String name;

  /// If set, and if the bucket's current metageneration does not match the
  /// specified value, the request will return an error.
  final int? ifMetagenerationMatch;

  /// If set, and if the bucket's current metageneration matches the specified
  /// value, the request will return an error.
  final int? ifMetagenerationNotMatch;

  /// Mask specifying which fields to read.
  /// A "*" field may be used to indicate all fields.
  /// If no mask is specified, will default to all fields.
  final FieldMask? readMask;

  GetBucketRequest({
    required this.name,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory GetBucketRequest.fromJson(Map<String, dynamic> json) {
    return GetBucketRequest(
      name: json['name'] ?? '',
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      readMask: decodeCustom(json['readMask'], FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
    ].join(',');
    return 'GetBucketRequest($contents)';
  }
}

/// Request message for CreateBucket.
final class CreateBucketRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.CreateBucketRequest';

  /// Required. The project to which this bucket will belong. This field must
  /// either be empty or `projects/_`. The project ID that owns this bucket
  /// should be specified in the `bucket.project` field.
  final String parent;

  /// Optional. Properties of the new bucket being inserted.
  /// The name of the bucket is specified in the `bucket_id` field. Populating
  /// `bucket.name` field will result in an error.
  /// The project of the bucket must be specified in the `bucket.project` field.
  /// This field must be in `projects/{projectIdentifier}` format,
  /// {projectIdentifier} can be the project ID or project number. The `parent`
  /// field must be either empty or `projects/_`.
  final Bucket? bucket;

  /// Required. The ID to use for this bucket, which will become the final
  /// component of the bucket's resource name. For example, the value `foo` might
  /// result in a bucket with the name `projects/123456/buckets/foo`.
  final String bucketId;

  /// Optional. Apply a predefined set of access controls to this bucket.
  /// Valid values are "authenticatedRead", "private", "projectPrivate",
  /// "publicRead", or "publicReadWrite".
  final String predefinedAcl;

  /// Optional. Apply a predefined set of default object access controls to this
  /// bucket. Valid values are "authenticatedRead", "bucketOwnerFullControl",
  /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
  final String predefinedDefaultObjectAcl;

  /// Optional. If true, enable object retention on the bucket.
  final bool enableObjectRetention;

  CreateBucketRequest({
    required this.parent,
    this.bucket,
    required this.bucketId,
    this.predefinedAcl = '',
    this.predefinedDefaultObjectAcl = '',
    this.enableObjectRetention = false,
  }) : super(fullyQualifiedName);

  factory CreateBucketRequest.fromJson(Map<String, dynamic> json) {
    return CreateBucketRequest(
      parent: json['parent'] ?? '',
      bucket: decode(json['bucket'], Bucket.fromJson),
      bucketId: json['bucketId'] ?? '',
      predefinedAcl: json['predefinedAcl'] ?? '',
      predefinedDefaultObjectAcl: json['predefinedDefaultObjectAcl'] ?? '',
      enableObjectRetention: json['enableObjectRetention'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (bucket != null) 'bucket': bucket!.toJson(),
      'bucketId': bucketId,
      if (predefinedAcl.isNotDefault) 'predefinedAcl': predefinedAcl,
      if (predefinedDefaultObjectAcl.isNotDefault)
        'predefinedDefaultObjectAcl': predefinedDefaultObjectAcl,
      if (enableObjectRetention.isNotDefault)
        'enableObjectRetention': enableObjectRetention,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'bucketId=$bucketId',
      'predefinedAcl=$predefinedAcl',
      'predefinedDefaultObjectAcl=$predefinedDefaultObjectAcl',
      'enableObjectRetention=$enableObjectRetention',
    ].join(',');
    return 'CreateBucketRequest($contents)';
  }
}

/// Request message for ListBuckets.
final class ListBucketsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ListBucketsRequest';

  /// Required. The project whose buckets we are listing.
  final String parent;

  /// Optional. Maximum number of buckets to return in a single response. The
  /// service will use this parameter or 1,000 items, whichever is smaller. If
  /// "acl" is present in the read_mask, the service will use this parameter of
  /// 200 items, whichever is smaller.
  final int pageSize;

  /// Optional. A previously-returned page token representing part of the larger
  /// set of results to view.
  final String pageToken;

  /// Optional. Filter results to buckets whose names begin with this prefix.
  final String prefix;

  /// Mask specifying which fields to read from each result.
  /// If no mask is specified, will default to all fields except items.owner,
  /// items.acl, and items.default_object_acl.
  /// * may be used to mean "all fields".
  final FieldMask? readMask;

  ListBucketsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.prefix = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListBucketsRequest.fromJson(Map<String, dynamic> json) {
    return ListBucketsRequest(
      parent: json['parent'] ?? '',
      pageSize: json['pageSize'] ?? 0,
      pageToken: json['pageToken'] ?? '',
      prefix: json['prefix'] ?? '',
      readMask: decodeCustom(json['readMask'], FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize.isNotDefault) 'pageSize': pageSize,
      if (pageToken.isNotDefault) 'pageToken': pageToken,
      if (prefix.isNotDefault) 'prefix': prefix,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'prefix=$prefix',
    ].join(',');
    return 'ListBucketsRequest($contents)';
  }
}

/// The result of a call to Buckets.ListBuckets
final class ListBucketsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ListBucketsResponse';

  /// The list of items.
  final List<Bucket> buckets;

  /// The continuation token, used to page through large result sets. Provide
  /// this value in a subsequent request to return the next page of results.
  final String nextPageToken;

  ListBucketsResponse({this.buckets = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListBucketsResponse.fromJson(Map<String, dynamic> json) {
    return ListBucketsResponse(
      buckets: decodeListMessage(json['buckets'], Bucket.fromJson) ?? [],
      nextPageToken: json['nextPageToken'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (buckets.isNotDefault) 'buckets': encodeList(buckets),
      if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListBucketsResponse($contents)';
  }
}

/// Request message for LockBucketRetentionPolicyRequest.
final class LockBucketRetentionPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.LockBucketRetentionPolicyRequest';

  /// Required. Name of a bucket.
  final String bucket;

  /// Required. Makes the operation conditional on whether bucket's current
  /// metageneration matches the given value. Must be positive.
  final int ifMetagenerationMatch;

  LockBucketRetentionPolicyRequest({
    required this.bucket,
    required this.ifMetagenerationMatch,
  }) : super(fullyQualifiedName);

  factory LockBucketRetentionPolicyRequest.fromJson(Map<String, dynamic> json) {
    return LockBucketRetentionPolicyRequest(
      bucket: json['bucket'] ?? '',
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']) ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'ifMetagenerationMatch=$ifMetagenerationMatch',
    ].join(',');
    return 'LockBucketRetentionPolicyRequest($contents)';
  }
}

/// Request for UpdateBucket method.
final class UpdateBucketRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.UpdateBucketRequest';

  /// Required. The bucket to update.
  /// The bucket's `name` field will be used to identify the bucket.
  final Bucket? bucket;

  /// If set, will only modify the bucket if its metageneration matches this
  /// value.
  final int? ifMetagenerationMatch;

  /// If set, will only modify the bucket if its metageneration does not match
  /// this value.
  final int? ifMetagenerationNotMatch;

  /// Optional. Apply a predefined set of access controls to this bucket.
  /// Valid values are "authenticatedRead", "private", "projectPrivate",
  /// "publicRead", or "publicReadWrite".
  final String predefinedAcl;

  /// Optional. Apply a predefined set of default object access controls to this
  /// bucket. Valid values are "authenticatedRead", "bucketOwnerFullControl",
  /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
  final String predefinedDefaultObjectAcl;

  /// Required. List of fields to be updated.
  ///
  /// To specify ALL fields, equivalent to the JSON API's "update" function,
  /// specify a single field with the value `*`. Note: not recommended. If a new
  /// field is introduced at a later time, an older client updating with the `*`
  /// may accidentally reset the new field's value.
  ///
  /// Not specifying any fields is an error.
  final FieldMask? updateMask;

  UpdateBucketRequest({
    required this.bucket,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.predefinedAcl = '',
    this.predefinedDefaultObjectAcl = '',
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateBucketRequest.fromJson(Map<String, dynamic> json) {
    return UpdateBucketRequest(
      bucket: decode(json['bucket'], Bucket.fromJson),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      predefinedAcl: json['predefinedAcl'] ?? '',
      predefinedDefaultObjectAcl: json['predefinedDefaultObjectAcl'] ?? '',
      updateMask: decodeCustom(json['updateMask'], FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (bucket != null) 'bucket': bucket!.toJson(),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (predefinedAcl.isNotDefault) 'predefinedAcl': predefinedAcl,
      if (predefinedDefaultObjectAcl.isNotDefault)
        'predefinedDefaultObjectAcl': predefinedDefaultObjectAcl,
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'predefinedAcl=$predefinedAcl',
      'predefinedDefaultObjectAcl=$predefinedDefaultObjectAcl',
    ].join(',');
    return 'UpdateBucketRequest($contents)';
  }
}

/// Request message for ComposeObject.
final class ComposeObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ComposeObjectRequest';

  /// Required. Properties of the resulting object.
  final Object$? destination;

  /// Optional. The list of source objects that will be concatenated into a
  /// single object.
  final List<ComposeObjectRequest_SourceObject> sourceObjects;

  /// Optional. Apply a predefined set of access controls to the destination
  /// object. Valid values are "authenticatedRead", "bucketOwnerFullControl",
  /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
  final String destinationPredefinedAcl;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Optional. Resource name of the Cloud KMS key, of the form
  /// `projects/my-project/locations/my-location/keyRings/my-kr/cryptoKeys/my-key`,
  /// that will be used to encrypt the object. Overrides the object
  /// metadata's `kms_key_name` value, if any.
  final String kmsKey;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  /// Optional. The checksums of the complete object. This will be validated
  /// against the combined checksums of the component objects.
  final ObjectChecksums? objectChecksums;

  ComposeObjectRequest({
    required this.destination,
    this.sourceObjects = const [],
    this.destinationPredefinedAcl = '',
    this.ifGenerationMatch,
    this.ifMetagenerationMatch,
    this.kmsKey = '',
    this.commonObjectRequestParams,
    this.objectChecksums,
  }) : super(fullyQualifiedName);

  factory ComposeObjectRequest.fromJson(Map<String, dynamic> json) {
    return ComposeObjectRequest(
      destination: decode(json['destination'], Object$.fromJson),
      sourceObjects:
          decodeListMessage(
            json['sourceObjects'],
            ComposeObjectRequest_SourceObject.fromJson,
          ) ??
          [],
      destinationPredefinedAcl: json['destinationPredefinedAcl'] ?? '',
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      kmsKey: json['kmsKey'] ?? '',
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
      objectChecksums: decode(
        json['objectChecksums'],
        ObjectChecksums.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (destination != null) 'destination': destination!.toJson(),
      if (sourceObjects.isNotDefault)
        'sourceObjects': encodeList(sourceObjects),
      if (destinationPredefinedAcl.isNotDefault)
        'destinationPredefinedAcl': destinationPredefinedAcl,
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (kmsKey.isNotDefault) 'kmsKey': kmsKey,
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
      if (objectChecksums != null) 'objectChecksums': objectChecksums!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'destinationPredefinedAcl=$destinationPredefinedAcl',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      'kmsKey=$kmsKey',
    ].join(',');
    return 'ComposeObjectRequest($contents)';
  }
}

/// Description of a source object for a composition request.
final class ComposeObjectRequest_SourceObject extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ComposeObjectRequest.SourceObject';

  /// Required. The source object's name. All source objects must reside in the
  /// same bucket.
  final String name;

  /// Optional. The generation of this object to use as the source.
  final int generation;

  /// Optional. Conditions that must be met for this operation to execute.
  final ComposeObjectRequest_SourceObject_ObjectPreconditions?
  objectPreconditions;

  ComposeObjectRequest_SourceObject({
    required this.name,
    this.generation = 0,
    this.objectPreconditions,
  }) : super(fullyQualifiedName);

  factory ComposeObjectRequest_SourceObject.fromJson(
    Map<String, dynamic> json,
  ) {
    return ComposeObjectRequest_SourceObject(
      name: json['name'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      objectPreconditions: decode(
        json['objectPreconditions'],
        ComposeObjectRequest_SourceObject_ObjectPreconditions.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (generation.isNotDefault) 'generation': encodeInt64(generation),
      if (objectPreconditions != null)
        'objectPreconditions': objectPreconditions!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name', 'generation=$generation'].join(',');
    return 'SourceObject($contents)';
  }
}

/// Preconditions for a source object of a composition request.
final class ComposeObjectRequest_SourceObject_ObjectPreconditions
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ComposeObjectRequest.SourceObject.ObjectPreconditions';

  /// Only perform the composition if the generation of the source object
  /// that would be used matches this value.  If this value and a generation
  /// are both specified, they must be the same value or the call will fail.
  final int? ifGenerationMatch;

  ComposeObjectRequest_SourceObject_ObjectPreconditions({
    this.ifGenerationMatch,
  }) : super(fullyQualifiedName);

  factory ComposeObjectRequest_SourceObject_ObjectPreconditions.fromJson(
    Map<String, dynamic> json,
  ) {
    return ComposeObjectRequest_SourceObject_ObjectPreconditions(
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
    );
  }

  @override
  Object toJson() {
    return {
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    };
  }

  @override
  String toString() {
    final contents = [
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
    ].join(',');
    return 'ObjectPreconditions($contents)';
  }
}

/// Message for deleting an object.
/// `bucket` and `object` **must** be set.
final class DeleteObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.DeleteObjectRequest';

  /// Required. Name of the bucket in which the object resides.
  final String bucket;

  /// Required. The name of the finalized object to delete.
  /// Note: If you want to delete an unfinalized resumable upload please use
  /// `CancelResumableWrite`.
  final String object;

  /// Optional. If present, permanently deletes a specific revision of this
  /// object (as opposed to the latest version, the default).
  final int generation;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live generation
  /// does not match the given value. If no live object exists, the precondition
  /// fails. Setting to 0 makes the operation succeed only if there is a live
  /// version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  DeleteObjectRequest({
    required this.bucket,
    required this.object,
    this.generation = 0,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.commonObjectRequestParams,
  }) : super(fullyQualifiedName);

  factory DeleteObjectRequest.fromJson(Map<String, dynamic> json) {
    return DeleteObjectRequest(
      bucket: json['bucket'] ?? '',
      object: json['object'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'object': object,
      if (generation.isNotDefault) 'generation': encodeInt64(generation),
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'object=$object',
      'generation=$generation',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
    ].join(',');
    return 'DeleteObjectRequest($contents)';
  }
}

/// Message for restoring an object.
/// `bucket`, `object`, and `generation` **must** be set.
final class RestoreObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.RestoreObjectRequest';

  /// Required. Name of the bucket in which the object resides.
  final String bucket;

  /// Required. The name of the object to restore.
  final String object;

  /// Required. The specific revision of the object to restore.
  final int generation;

  /// Optional. Restore token used to differentiate soft-deleted objects with the
  /// same name and generation. Only applicable for hierarchical namespace
  /// buckets. This parameter is optional, and is only required in the rare case
  /// when there are multiple soft-deleted objects with the same name and
  /// generation.
  final String restoreToken;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live generation
  /// does not match the given value. If no live object exists, the precondition
  /// fails. Setting to 0 makes the operation succeed only if there is a live
  /// version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// If false or unset, the bucket's default object ACL will be used.
  /// If true, copy the source object's access controls.
  /// Return an error if bucket has UBLA enabled.
  final bool? copySourceAcl;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  RestoreObjectRequest({
    required this.bucket,
    required this.object,
    required this.generation,
    this.restoreToken = '',
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.copySourceAcl,
    this.commonObjectRequestParams,
  }) : super(fullyQualifiedName);

  factory RestoreObjectRequest.fromJson(Map<String, dynamic> json) {
    return RestoreObjectRequest(
      bucket: json['bucket'] ?? '',
      object: json['object'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      restoreToken: json['restoreToken'] ?? '',
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      copySourceAcl: json['copySourceAcl'],
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'object': object,
      'generation': encodeInt64(generation),
      if (restoreToken.isNotDefault) 'restoreToken': restoreToken,
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (copySourceAcl != null) 'copySourceAcl': copySourceAcl,
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'object=$object',
      'generation=$generation',
      'restoreToken=$restoreToken',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (copySourceAcl != null) 'copySourceAcl=$copySourceAcl',
    ].join(',');
    return 'RestoreObjectRequest($contents)';
  }
}

/// Message for canceling an in-progress resumable upload.
/// `upload_id` **must** be set.
final class CancelResumableWriteRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.CancelResumableWriteRequest';

  /// Required. The upload_id of the resumable upload to cancel. This should be
  /// copied from the `upload_id` field of `StartResumableWriteResponse`.
  final String uploadId;

  CancelResumableWriteRequest({required this.uploadId})
    : super(fullyQualifiedName);

  factory CancelResumableWriteRequest.fromJson(Map<String, dynamic> json) {
    return CancelResumableWriteRequest(uploadId: json['uploadId'] ?? '');
  }

  @override
  Object toJson() {
    return {'uploadId': uploadId};
  }

  @override
  String toString() {
    final contents = ['uploadId=$uploadId'].join(',');
    return 'CancelResumableWriteRequest($contents)';
  }
}

/// Empty response message for canceling an in-progress resumable upload, will be
/// extended as needed.
final class CancelResumableWriteResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.CancelResumableWriteResponse';

  CancelResumableWriteResponse() : super(fullyQualifiedName);

  factory CancelResumableWriteResponse.fromJson(Map<String, dynamic> json) {
    return CancelResumableWriteResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'CancelResumableWriteResponse()';
}

/// Request message for ReadObject.
final class ReadObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ReadObjectRequest';

  /// Required. The name of the bucket containing the object to read.
  final String bucket;

  /// Required. The name of the object to read.
  final String object;

  /// Optional. If present, selects a specific revision of this object (as
  /// opposed to the latest version, the default).
  final int generation;

  /// Optional. The offset for the first byte to return in the read, relative to
  /// the start of the object.
  ///
  /// A negative `read_offset` value will be interpreted as the number of bytes
  /// back from the end of the object to be returned. For example, if an object's
  /// length is 15 bytes, a ReadObjectRequest with `read_offset` = -5 and
  /// `read_limit` = 3 would return bytes 10 through 12 of the object. Requesting
  /// a negative offset with magnitude larger than the size of the object will
  /// return the entire object.
  final int readOffset;

  /// Optional. The maximum number of `data` bytes the server is allowed to
  /// return in the sum of all `Object` messages. A `read_limit` of zero
  /// indicates that there is no limit, and a negative `read_limit` will cause an
  /// error.
  ///
  /// If the stream returns fewer bytes than allowed by the `read_limit` and no
  /// error occurred, the stream includes all data from the `read_offset` to the
  /// end of the resource.
  final int readLimit;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live generation
  /// does not match the given value. If no live object exists, the precondition
  /// fails. Setting to 0 makes the operation succeed only if there is a live
  /// version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  /// Mask specifying which fields to read.
  /// The checksummed_data field and its children will always be present.
  /// If no mask is specified, will default to all fields except metadata.owner
  /// and metadata.acl.
  /// * may be used to mean "all fields".
  final FieldMask? readMask;

  ReadObjectRequest({
    required this.bucket,
    required this.object,
    this.generation = 0,
    this.readOffset = 0,
    this.readLimit = 0,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.commonObjectRequestParams,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ReadObjectRequest.fromJson(Map<String, dynamic> json) {
    return ReadObjectRequest(
      bucket: json['bucket'] ?? '',
      object: json['object'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      readOffset: decodeInt64(json['readOffset']) ?? 0,
      readLimit: decodeInt64(json['readLimit']) ?? 0,
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
      readMask: decodeCustom(json['readMask'], FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'object': object,
      if (generation.isNotDefault) 'generation': encodeInt64(generation),
      if (readOffset.isNotDefault) 'readOffset': encodeInt64(readOffset),
      if (readLimit.isNotDefault) 'readLimit': encodeInt64(readLimit),
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'object=$object',
      'generation=$generation',
      'readOffset=$readOffset',
      'readLimit=$readLimit',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
    ].join(',');
    return 'ReadObjectRequest($contents)';
  }
}

/// Request message for GetObject.
final class GetObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.GetObjectRequest';

  /// Required. Name of the bucket in which the object resides.
  final String bucket;

  /// Required. Name of the object.
  final String object;

  /// Optional. If present, selects a specific revision of this object (as
  /// opposed to the latest version, the default).
  final int generation;

  /// If true, return the soft-deleted version of this object.
  final bool? softDeleted;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live generation
  /// does not match the given value. If no live object exists, the precondition
  /// fails. Setting to 0 makes the operation succeed only if there is a live
  /// version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  /// Mask specifying which fields to read.
  /// If no mask is specified, will default to all fields except metadata.acl and
  /// metadata.owner.
  /// * may be used to mean "all fields".
  final FieldMask? readMask;

  /// Optional. Restore token used to differentiate soft-deleted objects with the
  /// same name and generation. Only applicable for hierarchical namespace
  /// buckets and if soft_deleted is set to true. This parameter is optional, and
  /// is only required in the rare case when there are multiple soft-deleted
  /// objects with the same name and generation.
  final String restoreToken;

  GetObjectRequest({
    required this.bucket,
    required this.object,
    this.generation = 0,
    this.softDeleted,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.commonObjectRequestParams,
    this.readMask,
    this.restoreToken = '',
  }) : super(fullyQualifiedName);

  factory GetObjectRequest.fromJson(Map<String, dynamic> json) {
    return GetObjectRequest(
      bucket: json['bucket'] ?? '',
      object: json['object'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      softDeleted: json['softDeleted'],
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
      readMask: decodeCustom(json['readMask'], FieldMask.fromJson),
      restoreToken: json['restoreToken'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'object': object,
      if (generation.isNotDefault) 'generation': encodeInt64(generation),
      if (softDeleted != null) 'softDeleted': softDeleted,
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (restoreToken.isNotDefault) 'restoreToken': restoreToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'object=$object',
      'generation=$generation',
      if (softDeleted != null) 'softDeleted=$softDeleted',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'restoreToken=$restoreToken',
    ].join(',');
    return 'GetObjectRequest($contents)';
  }
}

/// Response message for ReadObject.
final class ReadObjectResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ReadObjectResponse';

  /// A portion of the data for the object. The service **may** leave `data`
  /// empty for any given `ReadResponse`. This enables the service to inform the
  /// client that the request is still live while it is running an operation to
  /// generate more data.
  final ChecksummedData? checksummedData;

  /// The checksums of the complete object. If the object is downloaded in full,
  /// the client should compute one of these checksums over the downloaded object
  /// and compare it against the value provided here.
  final ObjectChecksums? objectChecksums;

  /// If read_offset and or read_limit was specified on the
  /// ReadObjectRequest, ContentRange will be populated on the first
  /// ReadObjectResponse message of the read stream.
  final ContentRange? contentRange;

  /// Metadata of the object whose media is being returned.
  /// Only populated in the first response in the stream.
  final Object$? metadata;

  ReadObjectResponse({
    this.checksummedData,
    this.objectChecksums,
    this.contentRange,
    this.metadata,
  }) : super(fullyQualifiedName);

  factory ReadObjectResponse.fromJson(Map<String, dynamic> json) {
    return ReadObjectResponse(
      checksummedData: decode(
        json['checksummedData'],
        ChecksummedData.fromJson,
      ),
      objectChecksums: decode(
        json['objectChecksums'],
        ObjectChecksums.fromJson,
      ),
      contentRange: decode(json['contentRange'], ContentRange.fromJson),
      metadata: decode(json['metadata'], Object$.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (checksummedData != null) 'checksummedData': checksummedData!.toJson(),
      if (objectChecksums != null) 'objectChecksums': objectChecksums!.toJson(),
      if (contentRange != null) 'contentRange': contentRange!.toJson(),
      if (metadata != null) 'metadata': metadata!.toJson(),
    };
  }

  @override
  String toString() => 'ReadObjectResponse()';
}

/// Describes the object to read in a BidiReadObject request.
final class BidiReadObjectSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiReadObjectSpec';

  /// Required. The name of the bucket containing the object to read.
  final String bucket;

  /// Required. The name of the object to read.
  final String object;

  /// Optional. If present, selects a specific revision of this object (as
  /// opposed to the latest version, the default).
  final int generation;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live generation
  /// does not match the given value. If no live object exists, the precondition
  /// fails. Setting to 0 makes the operation succeed only if there is a live
  /// version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  /// Mask specifying which fields to read.
  /// The checksummed_data field and its children will always be present.
  /// If no mask is specified, will default to all fields except metadata.owner
  /// and metadata.acl.
  /// * may be used to mean "all fields".
  /// As per https://google.aip.dev/161, this field is deprecated.
  /// As an alternative, grpc metadata can be used:
  /// https://cloud.google.com/apis/docs/system-parameters#definitions
  final FieldMask? readMask;

  /// The client can optionally set this field. The read handle is an optimized
  /// way of creating new streams. Read handles are generated and periodically
  /// refreshed from prior reads.
  final BidiReadHandle? readHandle;

  /// The routing token that influences request routing for the stream. Must be
  /// provided if a BidiReadObjectRedirectedError is returned.
  final String? routingToken;

  BidiReadObjectSpec({
    required this.bucket,
    required this.object,
    this.generation = 0,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.commonObjectRequestParams,
    this.readMask,
    this.readHandle,
    this.routingToken,
  }) : super(fullyQualifiedName);

  factory BidiReadObjectSpec.fromJson(Map<String, dynamic> json) {
    return BidiReadObjectSpec(
      bucket: json['bucket'] ?? '',
      object: json['object'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
      readMask: decodeCustom(json['readMask'], FieldMask.fromJson),
      readHandle: decode(json['readHandle'], BidiReadHandle.fromJson),
      routingToken: json['routingToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'object': object,
      if (generation.isNotDefault) 'generation': encodeInt64(generation),
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (readHandle != null) 'readHandle': readHandle!.toJson(),
      if (routingToken != null) 'routingToken': routingToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'object=$object',
      'generation=$generation',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (routingToken != null) 'routingToken=$routingToken',
    ].join(',');
    return 'BidiReadObjectSpec($contents)';
  }
}

/// Request message for BidiReadObject.
final class BidiReadObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiReadObjectRequest';

  /// Optional. The first message of each stream should set this field. If this
  /// is not the first message, an error will be returned. Describes the object
  /// to read.
  final BidiReadObjectSpec? readObjectSpec;

  /// Optional. Provides a list of 0 or more (up to 100) ranges to read. If a
  /// single range is large enough to require multiple responses, they are
  /// guaranteed to be delivered in increasing offset order. There are no
  /// ordering guarantees across ranges. When no ranges are provided, the
  /// response message will not include ObjectRangeData. For full object
  /// downloads, the offset and size can be set to 0.
  final List<ReadRange> readRanges;

  BidiReadObjectRequest({this.readObjectSpec, this.readRanges = const []})
    : super(fullyQualifiedName);

  factory BidiReadObjectRequest.fromJson(Map<String, dynamic> json) {
    return BidiReadObjectRequest(
      readObjectSpec: decode(
        json['readObjectSpec'],
        BidiReadObjectSpec.fromJson,
      ),
      readRanges:
          decodeListMessage(json['readRanges'], ReadRange.fromJson) ?? [],
    );
  }

  @override
  Object toJson() {
    return {
      if (readObjectSpec != null) 'readObjectSpec': readObjectSpec!.toJson(),
      if (readRanges.isNotDefault) 'readRanges': encodeList(readRanges),
    };
  }

  @override
  String toString() => 'BidiReadObjectRequest()';
}

/// Response message for BidiReadObject.
final class BidiReadObjectResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiReadObjectResponse';

  /// A portion of the object's data. The service **may** leave data
  /// empty for any given ReadResponse. This enables the service to inform the
  /// client that the request is still live while it is running an operation to
  /// generate more data.
  /// The service **may** pipeline multiple responses belonging to different read
  /// requests. Each ObjectRangeData entry will have a read_id
  /// set to the same value as the corresponding source read request.
  final List<ObjectRangeData> objectDataRanges;

  /// Metadata of the object whose media is being returned.
  /// Only populated in the first response in the stream and not populated when
  /// the stream is opened with a read handle.
  final Object$? metadata;

  /// This field will be periodically refreshed, however it may not be set in
  /// every response. It allows the client to more efficiently open subsequent
  /// bidirectional streams to the same object.
  final BidiReadHandle? readHandle;

  BidiReadObjectResponse({
    this.objectDataRanges = const [],
    this.metadata,
    this.readHandle,
  }) : super(fullyQualifiedName);

  factory BidiReadObjectResponse.fromJson(Map<String, dynamic> json) {
    return BidiReadObjectResponse(
      objectDataRanges:
          decodeListMessage(
            json['objectDataRanges'],
            ObjectRangeData.fromJson,
          ) ??
          [],
      metadata: decode(json['metadata'], Object$.fromJson),
      readHandle: decode(json['readHandle'], BidiReadHandle.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (objectDataRanges.isNotDefault)
        'objectDataRanges': encodeList(objectDataRanges),
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (readHandle != null) 'readHandle': readHandle!.toJson(),
    };
  }

  @override
  String toString() => 'BidiReadObjectResponse()';
}

/// Error proto containing details for a redirected read. This error may be
/// attached as details for an ABORTED response to BidiReadObject.
final class BidiReadObjectRedirectedError extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiReadObjectRedirectedError';

  /// The read handle for the redirected read. If set, the client may use this in
  /// the BidiReadObjectSpec when retrying the read stream.
  final BidiReadHandle? readHandle;

  /// The routing token the client must use when retrying the read stream.
  /// This value must be provided in the header `x-goog-request-params`, with key
  /// `routing_token` and this string verbatim as the value.
  final String? routingToken;

  BidiReadObjectRedirectedError({this.readHandle, this.routingToken})
    : super(fullyQualifiedName);

  factory BidiReadObjectRedirectedError.fromJson(Map<String, dynamic> json) {
    return BidiReadObjectRedirectedError(
      readHandle: decode(json['readHandle'], BidiReadHandle.fromJson),
      routingToken: json['routingToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (readHandle != null) 'readHandle': readHandle!.toJson(),
      if (routingToken != null) 'routingToken': routingToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (routingToken != null) 'routingToken=$routingToken',
    ].join(',');
    return 'BidiReadObjectRedirectedError($contents)';
  }
}

/// Error proto containing details for a redirected write. This error may be
/// attached as details for an ABORTED response to BidiWriteObject.
final class BidiWriteObjectRedirectedError extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiWriteObjectRedirectedError';

  /// The routing token the client must use when retrying the write stream.
  /// This value must be provided in the header `x-goog-request-params`, with key
  /// `routing_token` and this string verbatim as the value.
  final String? routingToken;

  /// Opaque value describing a previous write. If set, the client must use this
  /// in an AppendObjectSpec first_message when retrying the write stream. If not
  /// set, clients may retry the original request.
  final BidiWriteHandle? writeHandle;

  /// The generation of the object that triggered the redirect. This will be set
  /// iff write_handle is set. If set, the client must use this in an
  /// AppendObjectSpec first_message when retrying the write stream.
  final int? generation;

  BidiWriteObjectRedirectedError({
    this.routingToken,
    this.writeHandle,
    this.generation,
  }) : super(fullyQualifiedName);

  factory BidiWriteObjectRedirectedError.fromJson(Map<String, dynamic> json) {
    return BidiWriteObjectRedirectedError(
      routingToken: json['routingToken'],
      writeHandle: decode(json['writeHandle'], BidiWriteHandle.fromJson),
      generation: decodeInt64(json['generation']),
    );
  }

  @override
  Object toJson() {
    return {
      if (routingToken != null) 'routingToken': routingToken,
      if (writeHandle != null) 'writeHandle': writeHandle!.toJson(),
      if (generation != null) 'generation': encodeInt64(generation),
    };
  }

  @override
  String toString() {
    final contents = [
      if (routingToken != null) 'routingToken=$routingToken',
      if (generation != null) 'generation=$generation',
    ].join(',');
    return 'BidiWriteObjectRedirectedError($contents)';
  }
}

/// Error extension proto containing details for all outstanding reads on the
/// failed stream
final class BidiReadObjectError extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiReadObjectError';

  /// The error code for each outstanding read_range
  final List<ReadRangeError> readRangeErrors;

  BidiReadObjectError({this.readRangeErrors = const []})
    : super(fullyQualifiedName);

  factory BidiReadObjectError.fromJson(Map<String, dynamic> json) {
    return BidiReadObjectError(
      readRangeErrors:
          decodeListMessage(json['readRangeErrors'], ReadRangeError.fromJson) ??
          [],
    );
  }

  @override
  Object toJson() {
    return {
      if (readRangeErrors.isNotDefault)
        'readRangeErrors': encodeList(readRangeErrors),
    };
  }

  @override
  String toString() => 'BidiReadObjectError()';
}

/// Error extension proto containing details for a single range read
final class ReadRangeError extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ReadRangeError';

  /// The id of the corresponding read_range
  final int readId;

  /// The status which should be an enum value of [google.rpc.Code].
  final Status? status;

  ReadRangeError({this.readId = 0, this.status}) : super(fullyQualifiedName);

  factory ReadRangeError.fromJson(Map<String, dynamic> json) {
    return ReadRangeError(
      readId: decodeInt64(json['readId']) ?? 0,
      status: decode(json['status'], Status.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (readId.isNotDefault) 'readId': encodeInt64(readId),
      if (status != null) 'status': status!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['readId=$readId'].join(',');
    return 'ReadRangeError($contents)';
  }
}

/// Describes a range of bytes to read in a BidiReadObjectRanges request.
final class ReadRange extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ReadRange';

  /// Required. The offset for the first byte to return in the read, relative to
  /// the start of the object.
  ///
  /// A negative read_offset value will be interpreted as the number of bytes
  /// back from the end of the object to be returned. For example, if an object's
  /// length is 15 bytes, a ReadObjectRequest with read_offset = -5 and
  /// read_length = 3 would return bytes 10 through 12 of the object. Requesting
  /// a negative offset with magnitude larger than the size of the object will
  /// return the entire object. A read_offset larger than the size of the object
  /// will result in an OutOfRange error.
  final int readOffset;

  /// Optional. The maximum number of data bytes the server is allowed to return
  /// across all response messages with the same read_id. A read_length of zero
  /// indicates to read until the resource end, and a negative read_length will
  /// cause an error. If the stream returns fewer bytes than allowed by the
  /// read_length and no error occurred, the stream includes all data from the
  /// read_offset to the resource end.
  final int readLength;

  /// Required. Read identifier provided by the client. When the client issues
  /// more than one outstanding ReadRange on the same stream, responses can be
  /// mapped back to their corresponding requests using this value. Clients must
  /// ensure that all outstanding requests have different read_id values. The
  /// server may close the stream with an error if this condition is not met.
  final int readId;

  ReadRange({
    required this.readOffset,
    this.readLength = 0,
    required this.readId,
  }) : super(fullyQualifiedName);

  factory ReadRange.fromJson(Map<String, dynamic> json) {
    return ReadRange(
      readOffset: decodeInt64(json['readOffset']) ?? 0,
      readLength: decodeInt64(json['readLength']) ?? 0,
      readId: decodeInt64(json['readId']) ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      'readOffset': encodeInt64(readOffset),
      if (readLength.isNotDefault) 'readLength': encodeInt64(readLength),
      'readId': encodeInt64(readId),
    };
  }

  @override
  String toString() {
    final contents = [
      'readOffset=$readOffset',
      'readLength=$readLength',
      'readId=$readId',
    ].join(',');
    return 'ReadRange($contents)';
  }
}

/// Contains data and metadata for a range of an object.
final class ObjectRangeData extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ObjectRangeData';

  /// A portion of the data for the object.
  final ChecksummedData? checksummedData;

  /// The ReadRange describes the content being returned with read_id set to the
  /// corresponding ReadObjectRequest in the stream. Multiple ObjectRangeData
  /// messages may have the same read_id but increasing offsets.
  /// ReadObjectResponse messages with the same read_id are guaranteed to be
  /// delivered in increasing offset order.
  final ReadRange? readRange;

  /// If set, indicates there are no more bytes to read for the given ReadRange.
  final bool rangeEnd;

  ObjectRangeData({this.checksummedData, this.readRange, this.rangeEnd = false})
    : super(fullyQualifiedName);

  factory ObjectRangeData.fromJson(Map<String, dynamic> json) {
    return ObjectRangeData(
      checksummedData: decode(
        json['checksummedData'],
        ChecksummedData.fromJson,
      ),
      readRange: decode(json['readRange'], ReadRange.fromJson),
      rangeEnd: json['rangeEnd'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (checksummedData != null) 'checksummedData': checksummedData!.toJson(),
      if (readRange != null) 'readRange': readRange!.toJson(),
      if (rangeEnd.isNotDefault) 'rangeEnd': rangeEnd,
    };
  }

  @override
  String toString() {
    final contents = ['rangeEnd=$rangeEnd'].join(',');
    return 'ObjectRangeData($contents)';
  }
}

/// BidiReadHandle contains a handle from a previous BiDiReadObject
/// invocation. The client can use this instead of BidiReadObjectSpec as an
/// optimized way of opening subsequent bidirectional streams to the same object.
final class BidiReadHandle extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.BidiReadHandle';

  /// Required. Opaque value describing a previous read.
  final Uint8List? handle;

  BidiReadHandle({required this.handle}) : super(fullyQualifiedName);

  factory BidiReadHandle.fromJson(Map<String, dynamic> json) {
    return BidiReadHandle(handle: decodeBytes(json['handle']));
  }

  @override
  Object toJson() {
    return {if (handle != null) 'handle': encodeBytes(handle)};
  }

  @override
  String toString() {
    final contents = [if (handle != null) 'handle=$handle'].join(',');
    return 'BidiReadHandle($contents)';
  }
}

/// BidiWriteHandle contains a handle from a previous BidiWriteObject
/// invocation. The client can use this as an optimized way of opening subsequent
/// bidirectional streams to the same object.
final class BidiWriteHandle extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.BidiWriteHandle';

  /// Required. Opaque value describing a previous write.
  final Uint8List? handle;

  BidiWriteHandle({required this.handle}) : super(fullyQualifiedName);

  factory BidiWriteHandle.fromJson(Map<String, dynamic> json) {
    return BidiWriteHandle(handle: decodeBytes(json['handle']));
  }

  @override
  Object toJson() {
    return {if (handle != null) 'handle': encodeBytes(handle)};
  }

  @override
  String toString() {
    final contents = [if (handle != null) 'handle=$handle'].join(',');
    return 'BidiWriteHandle($contents)';
  }
}

/// Describes an attempt to insert an object, possibly over multiple requests.
final class WriteObjectSpec extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.WriteObjectSpec';

  /// Required. Destination object, including its name and its metadata.
  final Object$? resource;

  /// Optional. Apply a predefined set of access controls to this object.
  /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
  /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
  final String predefinedAcl;

  /// Makes the operation conditional on whether the object's current
  /// generation matches the given value. Setting to 0 makes the operation
  /// succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live
  /// generation does not match the given value. If no live object exists, the
  /// precondition fails. Setting to 0 makes the operation succeed only if
  /// there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// The expected final object size being uploaded.
  /// If this value is set, closing the stream after writing fewer or more than
  /// `object_size` bytes will result in an OUT_OF_RANGE error.
  ///
  /// This situation is considered a client error, and if such an error occurs
  /// you must start the upload over from scratch, this time sending the correct
  /// number of bytes.
  final int? objectSize;

  /// If true, the object will be created in appendable mode.
  /// This field may only be set when using BidiWriteObject.
  final bool? appendable;

  WriteObjectSpec({
    required this.resource,
    this.predefinedAcl = '',
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.objectSize,
    this.appendable,
  }) : super(fullyQualifiedName);

  factory WriteObjectSpec.fromJson(Map<String, dynamic> json) {
    return WriteObjectSpec(
      resource: decode(json['resource'], Object$.fromJson),
      predefinedAcl: json['predefinedAcl'] ?? '',
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      objectSize: decodeInt64(json['objectSize']),
      appendable: json['appendable'],
    );
  }

  @override
  Object toJson() {
    return {
      if (resource != null) 'resource': resource!.toJson(),
      if (predefinedAcl.isNotDefault) 'predefinedAcl': predefinedAcl,
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (objectSize != null) 'objectSize': encodeInt64(objectSize),
      if (appendable != null) 'appendable': appendable,
    };
  }

  @override
  String toString() {
    final contents = [
      'predefinedAcl=$predefinedAcl',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (objectSize != null) 'objectSize=$objectSize',
      if (appendable != null) 'appendable=$appendable',
    ].join(',');
    return 'WriteObjectSpec($contents)';
  }
}

/// Request message for WriteObject.
final class WriteObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.WriteObjectRequest';

  /// For resumable uploads. This should be the `upload_id` returned from a
  /// call to `StartResumableWriteResponse`.
  final String? uploadId;

  /// For non-resumable uploads. Describes the overall upload, including the
  /// destination bucket and object name, preconditions, etc.
  final WriteObjectSpec? writeObjectSpec;

  /// Required. The offset from the beginning of the object at which the data
  /// should be written.
  ///
  /// In the first `WriteObjectRequest` of a `WriteObject()` action, it
  /// indicates the initial offset for the `Write()` call. The value **must** be
  /// equal to the `persisted_size` that a call to `QueryWriteStatus()` would
  /// return (0 if this is the first write to the object).
  ///
  /// On subsequent calls, this value **must** be no larger than the sum of the
  /// first `write_offset` and the sizes of all `data` chunks sent previously on
  /// this stream.
  ///
  /// An incorrect value will cause an error.
  final int writeOffset;

  /// The data to insert. If a crc32c checksum is provided that doesn't match
  /// the checksum computed by the service, the request will fail.
  final ChecksummedData? checksummedData;

  /// Optional. Checksums for the complete object. If the checksums computed by
  /// the service don't match the specified checksums the call will fail. May
  /// only be provided in the first or last request (either with first_message,
  /// or finish_write set).
  final ObjectChecksums? objectChecksums;

  /// Optional. If `true`, this indicates that the write is complete. Sending any
  /// `WriteObjectRequest`s subsequent to one in which `finish_write` is `true`
  /// will cause an error.
  /// For a non-resumable write (where the upload_id was not set in the first
  /// message), it is an error not to set this field in the final message of the
  /// stream.
  final bool finishWrite;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  WriteObjectRequest({
    this.uploadId,
    this.writeObjectSpec,
    required this.writeOffset,
    this.checksummedData,
    this.objectChecksums,
    this.finishWrite = false,
    this.commonObjectRequestParams,
  }) : super(fullyQualifiedName);

  factory WriteObjectRequest.fromJson(Map<String, dynamic> json) {
    return WriteObjectRequest(
      uploadId: json['uploadId'],
      writeObjectSpec: decode(
        json['writeObjectSpec'],
        WriteObjectSpec.fromJson,
      ),
      writeOffset: decodeInt64(json['writeOffset']) ?? 0,
      checksummedData: decode(
        json['checksummedData'],
        ChecksummedData.fromJson,
      ),
      objectChecksums: decode(
        json['objectChecksums'],
        ObjectChecksums.fromJson,
      ),
      finishWrite: json['finishWrite'] ?? false,
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (uploadId != null) 'uploadId': uploadId,
      if (writeObjectSpec != null) 'writeObjectSpec': writeObjectSpec!.toJson(),
      'writeOffset': encodeInt64(writeOffset),
      if (checksummedData != null) 'checksummedData': checksummedData!.toJson(),
      if (objectChecksums != null) 'objectChecksums': objectChecksums!.toJson(),
      if (finishWrite.isNotDefault) 'finishWrite': finishWrite,
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (uploadId != null) 'uploadId=$uploadId',
      'writeOffset=$writeOffset',
      'finishWrite=$finishWrite',
    ].join(',');
    return 'WriteObjectRequest($contents)';
  }
}

/// Response message for WriteObject.
final class WriteObjectResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.WriteObjectResponse';

  /// The total number of bytes that have been processed for the given object
  /// from all `WriteObject` calls. Only set if the upload has not finalized.
  final int? persistedSize;

  /// A resource containing the metadata for the uploaded object. Only set if
  /// the upload has finalized.
  final Object$? resource;

  WriteObjectResponse({this.persistedSize, this.resource})
    : super(fullyQualifiedName);

  factory WriteObjectResponse.fromJson(Map<String, dynamic> json) {
    return WriteObjectResponse(
      persistedSize: decodeInt64(json['persistedSize']),
      resource: decode(json['resource'], Object$.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (persistedSize != null) 'persistedSize': encodeInt64(persistedSize),
      if (resource != null) 'resource': resource!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (persistedSize != null) 'persistedSize=$persistedSize',
    ].join(',');
    return 'WriteObjectResponse($contents)';
  }
}

/// Describes an attempt to append to an object, possibly over multiple requests.
final class AppendObjectSpec extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.AppendObjectSpec';

  /// Required. The name of the bucket containing the object to write.
  final String bucket;

  /// Required. The name of the object to open for writing.
  final String object;

  /// Required. The generation number of the object to open for writing.
  final int generation;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  ///
  /// Note that metageneration preconditions are only checked if `write_handle`
  /// is empty.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  ///
  /// Note that metageneration preconditions are only checked if `write_handle`
  /// is empty.
  final int? ifMetagenerationNotMatch;

  /// An optional routing token that influences request routing for the stream.
  /// Must be provided if a BidiWriteObjectRedirectedError is returned.
  final String? routingToken;

  /// An optional write handle returned from a previous BidiWriteObjectResponse
  /// message or a BidiWriteObjectRedirectedError error.
  ///
  /// Note that metageneration preconditions are only checked if `write_handle`
  /// is empty.
  final BidiWriteHandle? writeHandle;

  AppendObjectSpec({
    required this.bucket,
    required this.object,
    required this.generation,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.routingToken,
    this.writeHandle,
  }) : super(fullyQualifiedName);

  factory AppendObjectSpec.fromJson(Map<String, dynamic> json) {
    return AppendObjectSpec(
      bucket: json['bucket'] ?? '',
      object: json['object'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      routingToken: json['routingToken'],
      writeHandle: decode(json['writeHandle'], BidiWriteHandle.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'object': object,
      'generation': encodeInt64(generation),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (routingToken != null) 'routingToken': routingToken,
      if (writeHandle != null) 'writeHandle': writeHandle!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'object=$object',
      'generation=$generation',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (routingToken != null) 'routingToken=$routingToken',
    ].join(',');
    return 'AppendObjectSpec($contents)';
  }
}

/// Request message for BidiWriteObject.
final class BidiWriteObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiWriteObjectRequest';

  /// For resumable uploads. This should be the `upload_id` returned from a
  /// call to `StartResumableWriteResponse`.
  final String? uploadId;

  /// For non-resumable uploads. Describes the overall upload, including the
  /// destination bucket and object name, preconditions, etc.
  final WriteObjectSpec? writeObjectSpec;

  /// For appendable uploads. Describes the object to append to.
  final AppendObjectSpec? appendObjectSpec;

  /// Required. The offset from the beginning of the object at which the data
  /// should be written.
  ///
  /// In the first `WriteObjectRequest` of a `WriteObject()` action, it
  /// indicates the initial offset for the `Write()` call. The value **must** be
  /// equal to the `persisted_size` that a call to `QueryWriteStatus()` would
  /// return (0 if this is the first write to the object).
  ///
  /// On subsequent calls, this value **must** be no larger than the sum of the
  /// first `write_offset` and the sizes of all `data` chunks sent previously on
  /// this stream.
  ///
  /// An invalid value will cause an error.
  final int writeOffset;

  /// The data to insert. If a crc32c checksum is provided that doesn't match
  /// the checksum computed by the service, the request will fail.
  final ChecksummedData? checksummedData;

  /// Optional. Checksums for the complete object. If the checksums computed by
  /// the service don't match the specified checksums the call will fail. May
  /// only be provided in the first request or the last request (with
  /// finish_write set).
  final ObjectChecksums? objectChecksums;

  /// Optional. For each BidiWriteObjectRequest where state_lookup is `true` or
  /// the client closes the stream, the service will send a
  /// BidiWriteObjectResponse containing the current persisted size. The
  /// persisted size sent in responses covers all the bytes the server has
  /// persisted thus far and can be used to decide what data is safe for the
  /// client to drop. Note that the object's current size reported by the
  /// BidiWriteObjectResponse may lag behind the number of bytes written by the
  /// client. This field is ignored if `finish_write` is set to true.
  final bool stateLookup;

  /// Optional. Persists data written on the stream, up to and including the
  /// current message, to permanent storage. This option should be used sparingly
  /// as it may reduce performance. Ongoing writes will periodically be persisted
  /// on the server even when `flush` is not set. This field is ignored if
  /// `finish_write` is set to true since there's no need to checkpoint or flush
  /// if this message completes the write.
  final bool flush;

  /// Optional. If `true`, this indicates that the write is complete. Sending any
  /// `WriteObjectRequest`s subsequent to one in which `finish_write` is `true`
  /// will cause an error.
  /// For a non-resumable write (where the upload_id was not set in the first
  /// message), it is an error not to set this field in the final message of the
  /// stream.
  final bool finishWrite;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  BidiWriteObjectRequest({
    this.uploadId,
    this.writeObjectSpec,
    this.appendObjectSpec,
    required this.writeOffset,
    this.checksummedData,
    this.objectChecksums,
    this.stateLookup = false,
    this.flush = false,
    this.finishWrite = false,
    this.commonObjectRequestParams,
  }) : super(fullyQualifiedName);

  factory BidiWriteObjectRequest.fromJson(Map<String, dynamic> json) {
    return BidiWriteObjectRequest(
      uploadId: json['uploadId'],
      writeObjectSpec: decode(
        json['writeObjectSpec'],
        WriteObjectSpec.fromJson,
      ),
      appendObjectSpec: decode(
        json['appendObjectSpec'],
        AppendObjectSpec.fromJson,
      ),
      writeOffset: decodeInt64(json['writeOffset']) ?? 0,
      checksummedData: decode(
        json['checksummedData'],
        ChecksummedData.fromJson,
      ),
      objectChecksums: decode(
        json['objectChecksums'],
        ObjectChecksums.fromJson,
      ),
      stateLookup: json['stateLookup'] ?? false,
      flush: json['flush'] ?? false,
      finishWrite: json['finishWrite'] ?? false,
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (uploadId != null) 'uploadId': uploadId,
      if (writeObjectSpec != null) 'writeObjectSpec': writeObjectSpec!.toJson(),
      if (appendObjectSpec != null)
        'appendObjectSpec': appendObjectSpec!.toJson(),
      'writeOffset': encodeInt64(writeOffset),
      if (checksummedData != null) 'checksummedData': checksummedData!.toJson(),
      if (objectChecksums != null) 'objectChecksums': objectChecksums!.toJson(),
      if (stateLookup.isNotDefault) 'stateLookup': stateLookup,
      if (flush.isNotDefault) 'flush': flush,
      if (finishWrite.isNotDefault) 'finishWrite': finishWrite,
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (uploadId != null) 'uploadId=$uploadId',
      'writeOffset=$writeOffset',
      'stateLookup=$stateLookup',
      'flush=$flush',
      'finishWrite=$finishWrite',
    ].join(',');
    return 'BidiWriteObjectRequest($contents)';
  }
}

/// Response message for BidiWriteObject.
final class BidiWriteObjectResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BidiWriteObjectResponse';

  /// The total number of bytes that have been processed for the given object
  /// from all `WriteObject` calls. Only set if the upload has not finalized.
  final int? persistedSize;

  /// A resource containing the metadata for the uploaded object. Only set if
  /// the upload has finalized.
  final Object$? resource;

  /// An optional write handle that will periodically be present in response
  /// messages. Clients should save it for later use in establishing a new stream
  /// if a connection is interrupted.
  final BidiWriteHandle? writeHandle;

  BidiWriteObjectResponse({this.persistedSize, this.resource, this.writeHandle})
    : super(fullyQualifiedName);

  factory BidiWriteObjectResponse.fromJson(Map<String, dynamic> json) {
    return BidiWriteObjectResponse(
      persistedSize: decodeInt64(json['persistedSize']),
      resource: decode(json['resource'], Object$.fromJson),
      writeHandle: decode(json['writeHandle'], BidiWriteHandle.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (persistedSize != null) 'persistedSize': encodeInt64(persistedSize),
      if (resource != null) 'resource': resource!.toJson(),
      if (writeHandle != null) 'writeHandle': writeHandle!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (persistedSize != null) 'persistedSize=$persistedSize',
    ].join(',');
    return 'BidiWriteObjectResponse($contents)';
  }
}

/// Request message for ListObjects.
final class ListObjectsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ListObjectsRequest';

  /// Required. Name of the bucket in which to look for objects.
  final String parent;

  /// Optional. Maximum number of `items` plus `prefixes` to return
  /// in a single page of responses. As duplicate `prefixes` are
  /// omitted, fewer total results may be returned than requested. The service
  /// will use this parameter or 1,000 items, whichever is smaller.
  final int pageSize;

  /// Optional. A previously-returned page token representing part of the larger
  /// set of results to view.
  final String pageToken;

  /// Optional. If set, returns results in a directory-like mode. `items` will
  /// contain only objects whose names, aside from the `prefix`, do not contain
  /// `delimiter`. Objects whose names, aside from the `prefix`, contain
  /// `delimiter` will have their name, truncated after the `delimiter`, returned
  /// in `prefixes`. Duplicate `prefixes` are omitted.
  final String delimiter;

  /// Optional. If true, objects that end in exactly one instance of `delimiter`
  /// will have their metadata included in `items` in addition to
  /// `prefixes`.
  final bool includeTrailingDelimiter;

  /// Optional. Filter results to objects whose names begin with this prefix.
  final String prefix;

  /// Optional. If `true`, lists all versions of an object as distinct results.
  /// For more information, see
  /// [Object
  /// Versioning](https://cloud.google.com/storage/docs/object-versioning).
  final bool versions;

  /// Mask specifying which fields to read from each result.
  /// If no mask is specified, will default to all fields except items.acl and
  /// items.owner.
  /// * may be used to mean "all fields".
  final FieldMask? readMask;

  /// Optional. Filter results to objects whose names are lexicographically equal
  /// to or after lexicographic_start. If lexicographic_end is also set, the
  /// objects listed have names between lexicographic_start (inclusive) and
  /// lexicographic_end (exclusive).
  final String lexicographicStart;

  /// Optional. Filter results to objects whose names are lexicographically
  /// before lexicographic_end. If lexicographic_start is also set, the objects
  /// listed have names between lexicographic_start (inclusive) and
  /// lexicographic_end (exclusive).
  final String lexicographicEnd;

  /// Optional. If true, only list all soft-deleted versions of the object.
  /// Soft delete policy is required to set this option.
  final bool softDeleted;

  /// Optional. If true, will also include folders and managed folders (besides
  /// objects) in the returned `prefixes`. Requires `delimiter` to be set to '/'.
  final bool includeFoldersAsPrefixes;

  /// Optional. Filter results to objects and prefixes that match this glob
  /// pattern. See [List Objects Using
  /// Glob](https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob)
  /// for the full syntax.
  final String matchGlob;

  /// Optional. Filter the returned objects. Currently only supported for the
  /// `contexts` field. If `delimiter` is set, the returned `prefixes` are exempt
  /// from this filter.
  final String filter;

  ListObjectsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.delimiter = '',
    this.includeTrailingDelimiter = false,
    this.prefix = '',
    this.versions = false,
    this.readMask,
    this.lexicographicStart = '',
    this.lexicographicEnd = '',
    this.softDeleted = false,
    this.includeFoldersAsPrefixes = false,
    this.matchGlob = '',
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory ListObjectsRequest.fromJson(Map<String, dynamic> json) {
    return ListObjectsRequest(
      parent: json['parent'] ?? '',
      pageSize: json['pageSize'] ?? 0,
      pageToken: json['pageToken'] ?? '',
      delimiter: json['delimiter'] ?? '',
      includeTrailingDelimiter: json['includeTrailingDelimiter'] ?? false,
      prefix: json['prefix'] ?? '',
      versions: json['versions'] ?? false,
      readMask: decodeCustom(json['readMask'], FieldMask.fromJson),
      lexicographicStart: json['lexicographicStart'] ?? '',
      lexicographicEnd: json['lexicographicEnd'] ?? '',
      softDeleted: json['softDeleted'] ?? false,
      includeFoldersAsPrefixes: json['includeFoldersAsPrefixes'] ?? false,
      matchGlob: json['matchGlob'] ?? '',
      filter: json['filter'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize.isNotDefault) 'pageSize': pageSize,
      if (pageToken.isNotDefault) 'pageToken': pageToken,
      if (delimiter.isNotDefault) 'delimiter': delimiter,
      if (includeTrailingDelimiter.isNotDefault)
        'includeTrailingDelimiter': includeTrailingDelimiter,
      if (prefix.isNotDefault) 'prefix': prefix,
      if (versions.isNotDefault) 'versions': versions,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (lexicographicStart.isNotDefault)
        'lexicographicStart': lexicographicStart,
      if (lexicographicEnd.isNotDefault) 'lexicographicEnd': lexicographicEnd,
      if (softDeleted.isNotDefault) 'softDeleted': softDeleted,
      if (includeFoldersAsPrefixes.isNotDefault)
        'includeFoldersAsPrefixes': includeFoldersAsPrefixes,
      if (matchGlob.isNotDefault) 'matchGlob': matchGlob,
      if (filter.isNotDefault) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'delimiter=$delimiter',
      'includeTrailingDelimiter=$includeTrailingDelimiter',
      'prefix=$prefix',
      'versions=$versions',
      'lexicographicStart=$lexicographicStart',
      'lexicographicEnd=$lexicographicEnd',
      'softDeleted=$softDeleted',
      'includeFoldersAsPrefixes=$includeFoldersAsPrefixes',
      'matchGlob=$matchGlob',
      'filter=$filter',
    ].join(',');
    return 'ListObjectsRequest($contents)';
  }
}

/// Request object for `QueryWriteStatus`.
final class QueryWriteStatusRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.QueryWriteStatusRequest';

  /// Required. The name of the resume token for the object whose write status is
  /// being requested.
  final String uploadId;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  QueryWriteStatusRequest({
    required this.uploadId,
    this.commonObjectRequestParams,
  }) : super(fullyQualifiedName);

  factory QueryWriteStatusRequest.fromJson(Map<String, dynamic> json) {
    return QueryWriteStatusRequest(
      uploadId: json['uploadId'] ?? '',
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'uploadId': uploadId,
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['uploadId=$uploadId'].join(',');
    return 'QueryWriteStatusRequest($contents)';
  }
}

/// Response object for `QueryWriteStatus`.
final class QueryWriteStatusResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.QueryWriteStatusResponse';

  /// The total number of bytes that have been processed for the given object
  /// from all `WriteObject` calls. This is the correct value for the
  /// 'write_offset' field to use when resuming the `WriteObject` operation.
  /// Only set if the upload has not finalized.
  final int? persistedSize;

  /// A resource containing the metadata for the uploaded object. Only set if
  /// the upload has finalized.
  final Object$? resource;

  QueryWriteStatusResponse({this.persistedSize, this.resource})
    : super(fullyQualifiedName);

  factory QueryWriteStatusResponse.fromJson(Map<String, dynamic> json) {
    return QueryWriteStatusResponse(
      persistedSize: decodeInt64(json['persistedSize']),
      resource: decode(json['resource'], Object$.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (persistedSize != null) 'persistedSize': encodeInt64(persistedSize),
      if (resource != null) 'resource': resource!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (persistedSize != null) 'persistedSize=$persistedSize',
    ].join(',');
    return 'QueryWriteStatusResponse($contents)';
  }
}

/// Request message for RewriteObject.
/// If the source object is encrypted using a Customer-Supplied Encryption Key
/// the key information must be provided in the copy_source_encryption_algorithm,
/// copy_source_encryption_key_bytes, and copy_source_encryption_key_sha256_bytes
/// fields. If the destination object should be encrypted the keying information
/// should be provided in the encryption_algorithm, encryption_key_bytes, and
/// encryption_key_sha256_bytes fields of the
/// common_object_request_params.customer_encryption field.
final class RewriteObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.RewriteObjectRequest';

  /// Required. Immutable. The name of the destination object.
  /// See the
  /// [Naming Guidelines](https://cloud.google.com/storage/docs/objects#naming).
  /// Example: `test.txt`
  /// The `name` field by itself does not uniquely identify a Cloud Storage
  /// object. A Cloud Storage object is uniquely identified by the tuple of
  /// (bucket, object, generation).
  final String destinationName;

  /// Required. Immutable. The name of the bucket containing the destination
  /// object.
  final String destinationBucket;

  /// Optional. The name of the Cloud KMS key that will be used to encrypt the
  /// destination object. The Cloud KMS key must be located in same location as
  /// the object. If the parameter is not specified, the request uses the
  /// destination bucket's default encryption key, if any, or else the
  /// Google-managed encryption key.
  final String destinationKmsKey;

  /// Optional. Properties of the destination, post-rewrite object.
  /// The `name`, `bucket` and `kms_key` fields must not be populated (these
  /// values are specified in the `destination_name`, `destination_bucket`, and
  /// `destination_kms_key` fields).
  /// If `destination` is present it will be used to construct the destination
  /// object's metadata; otherwise the destination object's metadata will be
  /// copied from the source object.
  final Object$? destination;

  /// Required. Name of the bucket in which to find the source object.
  final String sourceBucket;

  /// Required. Name of the source object.
  final String sourceObject;

  /// Optional. If present, selects a specific revision of the source object (as
  /// opposed to the latest version, the default).
  final int sourceGeneration;

  /// Optional. Include this field (from the previous rewrite response) on each
  /// rewrite request after the first one, until the rewrite response 'done' flag
  /// is true. Calls that provide a rewriteToken can omit all other request
  /// fields, but if included those fields must match the values provided in the
  /// first rewrite request.
  final String rewriteToken;

  /// Optional. Apply a predefined set of access controls to the destination
  /// object. Valid values are "authenticatedRead", "bucketOwnerFullControl",
  /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
  final String destinationPredefinedAcl;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live generation
  /// does not match the given value. If no live object exists, the precondition
  /// fails. Setting to 0 makes the operation succeed only if there is a live
  /// version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the destination object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the destination object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Makes the operation conditional on whether the source object's live
  /// generation matches the given value.
  final int? ifSourceGenerationMatch;

  /// Makes the operation conditional on whether the source object's live
  /// generation does not match the given value.
  final int? ifSourceGenerationNotMatch;

  /// Makes the operation conditional on whether the source object's current
  /// metageneration matches the given value.
  final int? ifSourceMetagenerationMatch;

  /// Makes the operation conditional on whether the source object's current
  /// metageneration does not match the given value.
  final int? ifSourceMetagenerationNotMatch;

  /// Optional. The maximum number of bytes that will be rewritten per rewrite
  /// request. Most callers shouldn't need to specify this parameter - it is
  /// primarily in place to support testing. If specified the value must be an
  /// integral multiple of 1 MiB (1048576). Also, this only applies to requests
  /// where the source and destination span locations and/or storage classes.
  /// Finally, this value must not change across rewrite calls else you'll get an
  /// error that the `rewriteToken` is invalid.
  final int maxBytesRewrittenPerCall;

  /// Optional. The algorithm used to encrypt the source object, if any. Used if
  /// the source object was encrypted with a Customer-Supplied Encryption Key.
  final String copySourceEncryptionAlgorithm;

  /// Optional. The raw bytes (not base64-encoded) AES-256 encryption key used to
  /// encrypt the source object, if it was encrypted with a Customer-Supplied
  /// Encryption Key.
  final Uint8List? copySourceEncryptionKeyBytes;

  /// Optional. The raw bytes (not base64-encoded) SHA256 hash of the encryption
  /// key used to encrypt the source object, if it was encrypted with a
  /// Customer-Supplied Encryption Key.
  final Uint8List? copySourceEncryptionKeySha256Bytes;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  /// Optional. The checksums of the complete object. This will be used to
  /// validate the destination object after rewriting.
  final ObjectChecksums? objectChecksums;

  RewriteObjectRequest({
    required this.destinationName,
    required this.destinationBucket,
    this.destinationKmsKey = '',
    this.destination,
    required this.sourceBucket,
    required this.sourceObject,
    this.sourceGeneration = 0,
    this.rewriteToken = '',
    this.destinationPredefinedAcl = '',
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.ifSourceGenerationMatch,
    this.ifSourceGenerationNotMatch,
    this.ifSourceMetagenerationMatch,
    this.ifSourceMetagenerationNotMatch,
    this.maxBytesRewrittenPerCall = 0,
    this.copySourceEncryptionAlgorithm = '',
    this.copySourceEncryptionKeyBytes,
    this.copySourceEncryptionKeySha256Bytes,
    this.commonObjectRequestParams,
    this.objectChecksums,
  }) : super(fullyQualifiedName);

  factory RewriteObjectRequest.fromJson(Map<String, dynamic> json) {
    return RewriteObjectRequest(
      destinationName: json['destinationName'] ?? '',
      destinationBucket: json['destinationBucket'] ?? '',
      destinationKmsKey: json['destinationKmsKey'] ?? '',
      destination: decode(json['destination'], Object$.fromJson),
      sourceBucket: json['sourceBucket'] ?? '',
      sourceObject: json['sourceObject'] ?? '',
      sourceGeneration: decodeInt64(json['sourceGeneration']) ?? 0,
      rewriteToken: json['rewriteToken'] ?? '',
      destinationPredefinedAcl: json['destinationPredefinedAcl'] ?? '',
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      ifSourceGenerationMatch: decodeInt64(json['ifSourceGenerationMatch']),
      ifSourceGenerationNotMatch: decodeInt64(
        json['ifSourceGenerationNotMatch'],
      ),
      ifSourceMetagenerationMatch: decodeInt64(
        json['ifSourceMetagenerationMatch'],
      ),
      ifSourceMetagenerationNotMatch: decodeInt64(
        json['ifSourceMetagenerationNotMatch'],
      ),
      maxBytesRewrittenPerCall:
          decodeInt64(json['maxBytesRewrittenPerCall']) ?? 0,
      copySourceEncryptionAlgorithm:
          json['copySourceEncryptionAlgorithm'] ?? '',
      copySourceEncryptionKeyBytes: decodeBytes(
        json['copySourceEncryptionKeyBytes'],
      ),
      copySourceEncryptionKeySha256Bytes: decodeBytes(
        json['copySourceEncryptionKeySha256Bytes'],
      ),
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
      objectChecksums: decode(
        json['objectChecksums'],
        ObjectChecksums.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'destinationName': destinationName,
      'destinationBucket': destinationBucket,
      if (destinationKmsKey.isNotDefault)
        'destinationKmsKey': destinationKmsKey,
      if (destination != null) 'destination': destination!.toJson(),
      'sourceBucket': sourceBucket,
      'sourceObject': sourceObject,
      if (sourceGeneration.isNotDefault)
        'sourceGeneration': encodeInt64(sourceGeneration),
      if (rewriteToken.isNotDefault) 'rewriteToken': rewriteToken,
      if (destinationPredefinedAcl.isNotDefault)
        'destinationPredefinedAcl': destinationPredefinedAcl,
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (ifSourceGenerationMatch != null)
        'ifSourceGenerationMatch': encodeInt64(ifSourceGenerationMatch),
      if (ifSourceGenerationNotMatch != null)
        'ifSourceGenerationNotMatch': encodeInt64(ifSourceGenerationNotMatch),
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch': encodeInt64(ifSourceMetagenerationMatch),
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch': encodeInt64(
          ifSourceMetagenerationNotMatch,
        ),
      if (maxBytesRewrittenPerCall.isNotDefault)
        'maxBytesRewrittenPerCall': encodeInt64(maxBytesRewrittenPerCall),
      if (copySourceEncryptionAlgorithm.isNotDefault)
        'copySourceEncryptionAlgorithm': copySourceEncryptionAlgorithm,
      if (copySourceEncryptionKeyBytes != null)
        'copySourceEncryptionKeyBytes': encodeBytes(
          copySourceEncryptionKeyBytes,
        ),
      if (copySourceEncryptionKeySha256Bytes != null)
        'copySourceEncryptionKeySha256Bytes': encodeBytes(
          copySourceEncryptionKeySha256Bytes,
        ),
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
      if (objectChecksums != null) 'objectChecksums': objectChecksums!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'destinationName=$destinationName',
      'destinationBucket=$destinationBucket',
      'destinationKmsKey=$destinationKmsKey',
      'sourceBucket=$sourceBucket',
      'sourceObject=$sourceObject',
      'sourceGeneration=$sourceGeneration',
      'rewriteToken=$rewriteToken',
      'destinationPredefinedAcl=$destinationPredefinedAcl',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (ifSourceGenerationMatch != null)
        'ifSourceGenerationMatch=$ifSourceGenerationMatch',
      if (ifSourceGenerationNotMatch != null)
        'ifSourceGenerationNotMatch=$ifSourceGenerationNotMatch',
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch=$ifSourceMetagenerationMatch',
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch=$ifSourceMetagenerationNotMatch',
      'maxBytesRewrittenPerCall=$maxBytesRewrittenPerCall',
      'copySourceEncryptionAlgorithm=$copySourceEncryptionAlgorithm',
      if (copySourceEncryptionKeyBytes != null)
        'copySourceEncryptionKeyBytes=$copySourceEncryptionKeyBytes',
      if (copySourceEncryptionKeySha256Bytes != null)
        'copySourceEncryptionKeySha256Bytes=$copySourceEncryptionKeySha256Bytes',
    ].join(',');
    return 'RewriteObjectRequest($contents)';
  }
}

/// A rewrite response.
final class RewriteResponse extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.RewriteResponse';

  /// The total bytes written so far, which can be used to provide a waiting user
  /// with a progress indicator. This property is always present in the response.
  final int totalBytesRewritten;

  /// The total size of the object being copied in bytes. This property is always
  /// present in the response.
  final int objectSize;

  /// `true` if the copy is finished; otherwise, `false` if
  /// the copy is in progress. This property is always present in the response.
  final bool done;

  /// A token to use in subsequent requests to continue copying data. This token
  /// is present in the response only when there is more data to copy.
  final String rewriteToken;

  /// A resource containing the metadata for the copied-to object. This property
  /// is present in the response only when copying completes.
  final Object$? resource;

  RewriteResponse({
    this.totalBytesRewritten = 0,
    this.objectSize = 0,
    this.done = false,
    this.rewriteToken = '',
    this.resource,
  }) : super(fullyQualifiedName);

  factory RewriteResponse.fromJson(Map<String, dynamic> json) {
    return RewriteResponse(
      totalBytesRewritten: decodeInt64(json['totalBytesRewritten']) ?? 0,
      objectSize: decodeInt64(json['objectSize']) ?? 0,
      done: json['done'] ?? false,
      rewriteToken: json['rewriteToken'] ?? '',
      resource: decode(json['resource'], Object$.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (totalBytesRewritten.isNotDefault)
        'totalBytesRewritten': encodeInt64(totalBytesRewritten),
      if (objectSize.isNotDefault) 'objectSize': encodeInt64(objectSize),
      if (done.isNotDefault) 'done': done,
      if (rewriteToken.isNotDefault) 'rewriteToken': rewriteToken,
      if (resource != null) 'resource': resource!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'totalBytesRewritten=$totalBytesRewritten',
      'objectSize=$objectSize',
      'done=$done',
      'rewriteToken=$rewriteToken',
    ].join(',');
    return 'RewriteResponse($contents)';
  }
}

/// Request message for MoveObject.
final class MoveObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.MoveObjectRequest';

  /// Required. Name of the bucket in which the object resides.
  final String bucket;

  /// Required. Name of the source object.
  final String sourceObject;

  /// Required. Name of the destination object.
  final String destinationObject;

  /// Optional. Makes the operation conditional on whether the source object's
  /// current generation matches the given value. `if_source_generation_match`
  /// and `if_source_generation_not_match` conditions are mutually exclusive:
  /// it's an error for both of them to be set in the request.
  final int? ifSourceGenerationMatch;

  /// Optional. Makes the operation conditional on whether the source object's
  /// current generation does not match the given value.
  /// `if_source_generation_match` and `if_source_generation_not_match`
  /// conditions are mutually exclusive: it's an error for both of them to be set
  /// in the request.
  final int? ifSourceGenerationNotMatch;

  /// Optional. Makes the operation conditional on whether the source object's
  /// current metageneration matches the given value.
  /// `if_source_metageneration_match` and `if_source_metageneration_not_match`
  /// conditions are mutually exclusive: it's an error for both of them to be set
  /// in the request.
  final int? ifSourceMetagenerationMatch;

  /// Optional. Makes the operation conditional on whether the source object's
  /// current metageneration does not match the given value.
  /// `if_source_metageneration_match` and `if_source_metageneration_not_match`
  /// conditions are mutually exclusive: it's an error for both of them to be set
  /// in the request.
  final int? ifSourceMetagenerationNotMatch;

  /// Optional. Makes the operation conditional on whether the destination
  /// object's current generation matches the given value. Setting to 0 makes the
  /// operation succeed only if there are no live versions of the object.
  /// `if_generation_match` and `if_generation_not_match` conditions are mutually
  /// exclusive: it's an error for both of them to be set in the request.
  final int? ifGenerationMatch;

  /// Optional. Makes the operation conditional on whether the destination
  /// object's current generation does not match the given value. If no live
  /// object exists, the precondition fails. Setting to 0 makes the operation
  /// succeed only if there is a live version of the object.
  /// `if_generation_match` and `if_generation_not_match` conditions are mutually
  /// exclusive: it's an error for both of them to be set in the request.
  final int? ifGenerationNotMatch;

  /// Optional. Makes the operation conditional on whether the destination
  /// object's current metageneration matches the given value.
  /// `if_metageneration_match` and `if_metageneration_not_match` conditions are
  /// mutually exclusive: it's an error for both of them to be set in the
  /// request.
  final int? ifMetagenerationMatch;

  /// Optional. Makes the operation conditional on whether the destination
  /// object's current metageneration does not match the given value.
  /// `if_metageneration_match` and `if_metageneration_not_match` conditions are
  /// mutually exclusive: it's an error for both of them to be set in the
  /// request.
  final int? ifMetagenerationNotMatch;

  MoveObjectRequest({
    required this.bucket,
    required this.sourceObject,
    required this.destinationObject,
    this.ifSourceGenerationMatch,
    this.ifSourceGenerationNotMatch,
    this.ifSourceMetagenerationMatch,
    this.ifSourceMetagenerationNotMatch,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
  }) : super(fullyQualifiedName);

  factory MoveObjectRequest.fromJson(Map<String, dynamic> json) {
    return MoveObjectRequest(
      bucket: json['bucket'] ?? '',
      sourceObject: json['sourceObject'] ?? '',
      destinationObject: json['destinationObject'] ?? '',
      ifSourceGenerationMatch: decodeInt64(json['ifSourceGenerationMatch']),
      ifSourceGenerationNotMatch: decodeInt64(
        json['ifSourceGenerationNotMatch'],
      ),
      ifSourceMetagenerationMatch: decodeInt64(
        json['ifSourceMetagenerationMatch'],
      ),
      ifSourceMetagenerationNotMatch: decodeInt64(
        json['ifSourceMetagenerationNotMatch'],
      ),
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
    );
  }

  @override
  Object toJson() {
    return {
      'bucket': bucket,
      'sourceObject': sourceObject,
      'destinationObject': destinationObject,
      if (ifSourceGenerationMatch != null)
        'ifSourceGenerationMatch': encodeInt64(ifSourceGenerationMatch),
      if (ifSourceGenerationNotMatch != null)
        'ifSourceGenerationNotMatch': encodeInt64(ifSourceGenerationNotMatch),
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch': encodeInt64(ifSourceMetagenerationMatch),
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch': encodeInt64(
          ifSourceMetagenerationNotMatch,
        ),
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    };
  }

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'sourceObject=$sourceObject',
      'destinationObject=$destinationObject',
      if (ifSourceGenerationMatch != null)
        'ifSourceGenerationMatch=$ifSourceGenerationMatch',
      if (ifSourceGenerationNotMatch != null)
        'ifSourceGenerationNotMatch=$ifSourceGenerationNotMatch',
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch=$ifSourceMetagenerationMatch',
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch=$ifSourceMetagenerationNotMatch',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
    ].join(',');
    return 'MoveObjectRequest($contents)';
  }
}

/// Request message StartResumableWrite.
final class StartResumableWriteRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.StartResumableWriteRequest';

  /// Required. Contains the information necessary to start a resumable write.
  final WriteObjectSpec? writeObjectSpec;

  /// Optional. A set of parameters common to Storage API requests related to an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  /// Optional. The checksums of the complete object. This is used to validate
  /// the uploaded object. For each upload, `object_checksums` can be provided
  /// when initiating a resumable upload with`StartResumableWriteRequest` or when
  /// completing a write with `WriteObjectRequest` with
  /// `finish_write` set to `true`.
  final ObjectChecksums? objectChecksums;

  StartResumableWriteRequest({
    required this.writeObjectSpec,
    this.commonObjectRequestParams,
    this.objectChecksums,
  }) : super(fullyQualifiedName);

  factory StartResumableWriteRequest.fromJson(Map<String, dynamic> json) {
    return StartResumableWriteRequest(
      writeObjectSpec: decode(
        json['writeObjectSpec'],
        WriteObjectSpec.fromJson,
      ),
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
      objectChecksums: decode(
        json['objectChecksums'],
        ObjectChecksums.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (writeObjectSpec != null) 'writeObjectSpec': writeObjectSpec!.toJson(),
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
      if (objectChecksums != null) 'objectChecksums': objectChecksums!.toJson(),
    };
  }

  @override
  String toString() => 'StartResumableWriteRequest()';
}

/// Response object for `StartResumableWrite`.
final class StartResumableWriteResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.StartResumableWriteResponse';

  /// A unique identifier for the initiated resumable write operation.
  /// As the ID grants write access, you should keep it confidential during
  /// the upload to prevent unauthorized access and data tampering during your
  /// upload. This ID should be included in subsequent `WriteObject` requests to
  /// upload the object data.
  final String uploadId;

  StartResumableWriteResponse({this.uploadId = ''}) : super(fullyQualifiedName);

  factory StartResumableWriteResponse.fromJson(Map<String, dynamic> json) {
    return StartResumableWriteResponse(uploadId: json['uploadId'] ?? '');
  }

  @override
  Object toJson() {
    return {if (uploadId.isNotDefault) 'uploadId': uploadId};
  }

  @override
  String toString() {
    final contents = ['uploadId=$uploadId'].join(',');
    return 'StartResumableWriteResponse($contents)';
  }
}

/// Request message for UpdateObject.
final class UpdateObjectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.UpdateObjectRequest';

  /// Required. The object to update.
  /// The object's bucket and name fields are used to identify the object to
  /// update. If present, the object's generation field selects a specific
  /// revision of this object whose metadata should be updated. Otherwise,
  /// assumes the live version of the object.
  final Object$? object;

  /// Makes the operation conditional on whether the object's current generation
  /// matches the given value. Setting to 0 makes the operation succeed only if
  /// there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's live generation
  /// does not match the given value. If no live object exists, the precondition
  /// fails. Setting to 0 makes the operation succeed only if there is a live
  /// version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current
  /// metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Optional. Apply a predefined set of access controls to this object.
  /// Valid values are "authenticatedRead", "bucketOwnerFullControl",
  /// "bucketOwnerRead", "private", "projectPrivate", or "publicRead".
  final String predefinedAcl;

  /// Required. List of fields to be updated.
  ///
  /// To specify ALL fields, equivalent to the JSON API's "update" function,
  /// specify a single field with the value `*`. Note: not recommended. If a new
  /// field is introduced at a later time, an older client updating with the `*`
  /// may accidentally reset the new field's value.
  ///
  /// Not specifying any fields is an error.
  final FieldMask? updateMask;

  /// Optional. A set of parameters common to Storage API requests concerning an
  /// object.
  final CommonObjectRequestParams? commonObjectRequestParams;

  /// Optional. Overrides the unlocked retention config on the object.
  final bool overrideUnlockedRetention;

  UpdateObjectRequest({
    required this.object,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.predefinedAcl = '',
    required this.updateMask,
    this.commonObjectRequestParams,
    this.overrideUnlockedRetention = false,
  }) : super(fullyQualifiedName);

  factory UpdateObjectRequest.fromJson(Map<String, dynamic> json) {
    return UpdateObjectRequest(
      object: decode(json['object'], Object$.fromJson),
      ifGenerationMatch: decodeInt64(json['ifGenerationMatch']),
      ifGenerationNotMatch: decodeInt64(json['ifGenerationNotMatch']),
      ifMetagenerationMatch: decodeInt64(json['ifMetagenerationMatch']),
      ifMetagenerationNotMatch: decodeInt64(json['ifMetagenerationNotMatch']),
      predefinedAcl: json['predefinedAcl'] ?? '',
      updateMask: decodeCustom(json['updateMask'], FieldMask.fromJson),
      commonObjectRequestParams: decode(
        json['commonObjectRequestParams'],
        CommonObjectRequestParams.fromJson,
      ),
      overrideUnlockedRetention: json['overrideUnlockedRetention'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (object != null) 'object': object!.toJson(),
      if (ifGenerationMatch != null)
        'ifGenerationMatch': encodeInt64(ifGenerationMatch),
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
      if (predefinedAcl.isNotDefault) 'predefinedAcl': predefinedAcl,
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      if (commonObjectRequestParams != null)
        'commonObjectRequestParams': commonObjectRequestParams!.toJson(),
      if (overrideUnlockedRetention.isNotDefault)
        'overrideUnlockedRetention': overrideUnlockedRetention,
    };
  }

  @override
  String toString() {
    final contents = [
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'predefinedAcl=$predefinedAcl',
      'overrideUnlockedRetention=$overrideUnlockedRetention',
    ].join(',');
    return 'UpdateObjectRequest($contents)';
  }
}

/// Parameters that can be passed to any object request.
final class CommonObjectRequestParams extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.CommonObjectRequestParams';

  /// Optional. Encryption algorithm used with the Customer-Supplied Encryption
  /// Keys feature.
  final String encryptionAlgorithm;

  /// Optional. Encryption key used with the Customer-Supplied Encryption Keys
  /// feature. In raw bytes format (not base64-encoded).
  final Uint8List? encryptionKeyBytes;

  /// Optional. SHA256 hash of encryption key used with the Customer-Supplied
  /// Encryption Keys feature.
  final Uint8List? encryptionKeySha256Bytes;

  CommonObjectRequestParams({
    this.encryptionAlgorithm = '',
    this.encryptionKeyBytes,
    this.encryptionKeySha256Bytes,
  }) : super(fullyQualifiedName);

  factory CommonObjectRequestParams.fromJson(Map<String, dynamic> json) {
    return CommonObjectRequestParams(
      encryptionAlgorithm: json['encryptionAlgorithm'] ?? '',
      encryptionKeyBytes: decodeBytes(json['encryptionKeyBytes']),
      encryptionKeySha256Bytes: decodeBytes(json['encryptionKeySha256Bytes']),
    );
  }

  @override
  Object toJson() {
    return {
      if (encryptionAlgorithm.isNotDefault)
        'encryptionAlgorithm': encryptionAlgorithm,
      if (encryptionKeyBytes != null)
        'encryptionKeyBytes': encodeBytes(encryptionKeyBytes),
      if (encryptionKeySha256Bytes != null)
        'encryptionKeySha256Bytes': encodeBytes(encryptionKeySha256Bytes),
    };
  }

  @override
  String toString() {
    final contents = [
      'encryptionAlgorithm=$encryptionAlgorithm',
      if (encryptionKeyBytes != null) 'encryptionKeyBytes=$encryptionKeyBytes',
      if (encryptionKeySha256Bytes != null)
        'encryptionKeySha256Bytes=$encryptionKeySha256Bytes',
    ].join(',');
    return 'CommonObjectRequestParams($contents)';
  }
}

/// Shared constants.
final class ServiceConstants extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ServiceConstants';

  ServiceConstants() : super(fullyQualifiedName);

  factory ServiceConstants.fromJson(Map<String, dynamic> json) {
    return ServiceConstants();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ServiceConstants()';
}

/// A collection of constant values meaningful to the Storage API.
final class ServiceConstants_Values extends ProtoEnum {
  /// Unused. Proto3 requires first enum to be 0.
  static const valuesUnspecified = ServiceConstants_Values(
    'VALUES_UNSPECIFIED',
  );

  /// The maximum size chunk that can will be returned in a single
  /// ReadRequest.
  /// 2 MiB.
  static const maxReadChunkBytes = ServiceConstants_Values(
    'MAX_READ_CHUNK_BYTES',
  );

  /// The maximum size chunk that can be sent in a single WriteObjectRequest.
  /// 2 MiB.
  static const maxWriteChunkBytes = ServiceConstants_Values(
    'MAX_WRITE_CHUNK_BYTES',
  );

  /// The maximum size of an object in MB - whether written in a single stream
  /// or composed from multiple other objects.
  /// 5 TiB.
  static const maxObjectSizeMb = ServiceConstants_Values('MAX_OBJECT_SIZE_MB');

  /// The maximum length field name that can be sent in a single
  /// custom metadata field.
  /// 1 KiB.
  static const maxCustomMetadataFieldNameBytes = ServiceConstants_Values(
    'MAX_CUSTOM_METADATA_FIELD_NAME_BYTES',
  );

  /// The maximum length field value that can be sent in a single
  /// custom_metadata field.
  /// 4 KiB.
  static const maxCustomMetadataFieldValueBytes = ServiceConstants_Values(
    'MAX_CUSTOM_METADATA_FIELD_VALUE_BYTES',
  );

  /// The maximum total bytes that can be populated into all field names and
  /// values of the custom_metadata for one object.
  /// 8 KiB.
  static const maxCustomMetadataTotalSizeBytes = ServiceConstants_Values(
    'MAX_CUSTOM_METADATA_TOTAL_SIZE_BYTES',
  );

  /// The maximum total bytes that can be populated into all bucket metadata
  /// fields.
  /// 20 KiB.
  static const maxBucketMetadataTotalSizeBytes = ServiceConstants_Values(
    'MAX_BUCKET_METADATA_TOTAL_SIZE_BYTES',
  );

  /// The maximum number of NotificationConfigs that can be registered
  /// for a given bucket.
  static const maxNotificationConfigsPerBucket = ServiceConstants_Values(
    'MAX_NOTIFICATION_CONFIGS_PER_BUCKET',
  );

  /// The maximum number of LifecycleRules that can be registered for a given
  /// bucket.
  static const maxLifecycleRulesPerBucket = ServiceConstants_Values(
    'MAX_LIFECYCLE_RULES_PER_BUCKET',
  );

  /// The maximum number of custom attributes per NotificationConfigs.
  static const maxNotificationCustomAttributes = ServiceConstants_Values(
    'MAX_NOTIFICATION_CUSTOM_ATTRIBUTES',
  );

  /// The maximum length of a custom attribute key included in
  /// NotificationConfig.
  static const maxNotificationCustomAttributeKeyLength =
      ServiceConstants_Values('MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_KEY_LENGTH');

  /// The maximum length of a custom attribute value included in a
  /// NotificationConfig.
  static const maxNotificationCustomAttributeValueLength =
      ServiceConstants_Values('MAX_NOTIFICATION_CUSTOM_ATTRIBUTE_VALUE_LENGTH');

  /// The maximum number of key/value entries per bucket label.
  static const maxLabelsEntriesCount = ServiceConstants_Values(
    'MAX_LABELS_ENTRIES_COUNT',
  );

  /// The maximum character length of the key or value in a bucket
  /// label map.
  static const maxLabelsKeyValueLength = ServiceConstants_Values(
    'MAX_LABELS_KEY_VALUE_LENGTH',
  );

  /// The maximum byte size of the key or value in a bucket label
  /// map.
  static const maxLabelsKeyValueBytes = ServiceConstants_Values(
    'MAX_LABELS_KEY_VALUE_BYTES',
  );

  /// The maximum number of object IDs that can be included in a
  /// DeleteObjectsRequest.
  static const maxObjectIdsPerDeleteObjectsRequest = ServiceConstants_Values(
    'MAX_OBJECT_IDS_PER_DELETE_OBJECTS_REQUEST',
  );

  /// The maximum number of days for which a token returned by the
  /// GetListObjectsSplitPoints RPC is valid.
  static const splitTokenMaxValidDays = ServiceConstants_Values(
    'SPLIT_TOKEN_MAX_VALID_DAYS',
  );

  /// The default value for [ServiceConstants_Values].
  static const $default = valuesUnspecified;

  const ServiceConstants_Values(super.value);

  factory ServiceConstants_Values.fromJson(String json) =>
      ServiceConstants_Values(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Values.$value';
}

/// A bucket.
final class Bucket extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket';

  /// Identifier. The name of the bucket.
  /// Format: `projects/{project}/buckets/{bucket}`
  final String name;

  /// Output only. The user-chosen part of the bucket name. The `{bucket}`
  /// portion of the `name` field. For globally unique buckets, this is equal to
  /// the "bucket name" of other Cloud Storage APIs. Example: "pub".
  final String bucketId;

  /// The etag of the bucket.
  /// If included in the metadata of an UpdateBucketRequest, the operation will
  /// only be performed if the etag matches that of the bucket.
  final String etag;

  /// Immutable. The project which owns this bucket, in the format of
  /// "projects/{projectIdentifier}".
  /// {projectIdentifier} can be the project ID or project number.
  /// Output values will always be in project number format.
  final String project;

  /// Output only. The metadata generation of this bucket.
  final int metageneration;

  /// Immutable. The location of the bucket. Object data for objects in the
  /// bucket resides in physical storage within this region.  Defaults to `US`.
  /// See the
  /// [https://developers.google.com/storage/docs/concepts-techniques#specifyinglocations"][developer's
  /// guide] for the authoritative list. Attempting to update this field after
  /// the bucket is created will result in an error.
  final String location;

  /// Output only. The location type of the bucket (region, dual-region,
  /// multi-region, etc).
  final String locationType;

  /// Optional. The bucket's default storage class, used whenever no storageClass
  /// is specified for a newly-created object. This defines how objects in the
  /// bucket are stored and determines the SLA and the cost of storage.
  /// If this value is not specified when the bucket is created, it will default
  /// to `STANDARD`. For more information, see
  /// https://developers.google.com/storage/docs/storage-classes.
  final String storageClass;

  /// Optional. The recovery point objective for cross-region replication of the
  /// bucket. Applicable only for dual- and multi-region buckets. "DEFAULT" uses
  /// default replication. "ASYNC_TURBO" enables turbo replication, valid for
  /// dual-region buckets only. If rpo is not specified when the bucket is
  /// created, it defaults to "DEFAULT". For more information, see
  /// https://cloud.google.com/storage/docs/availability-durability#turbo-replication.
  final String rpo;

  /// Optional. Access controls on the bucket.
  /// If iam_config.uniform_bucket_level_access is enabled on this bucket,
  /// requests to set, read, or modify acl is an error.
  final List<BucketAccessControl> acl;

  /// Optional. Default access controls to apply to new objects when no ACL is
  /// provided. If iam_config.uniform_bucket_level_access is enabled on this
  /// bucket, requests to set, read, or modify acl is an error.
  final List<ObjectAccessControl> defaultObjectAcl;

  /// Optional. The bucket's lifecycle config. See
  /// [https://developers.google.com/storage/docs/lifecycle]Lifecycle Management]
  /// for more information.
  final Bucket_Lifecycle? lifecycle;

  /// Output only. The creation time of the bucket.
  final Timestamp? createTime;

  /// Optional. The bucket's [https://www.w3.org/TR/cors/][Cross-Origin Resource
  /// Sharing] (CORS) config.
  final List<Bucket_Cors> cors;

  /// Output only. The modification time of the bucket.
  final Timestamp? updateTime;

  /// Optional. The default value for event-based hold on newly created objects
  /// in this bucket.  Event-based hold is a way to retain objects indefinitely
  /// until an event occurs, signified by the hold's release. After being
  /// released, such objects will be subject to bucket-level retention (if any).
  /// One sample use case of this flag is for banks to hold loan documents for at
  /// least 3 years after loan is paid in full. Here, bucket-level retention is 3
  /// years and the event is loan being paid in full. In this example, these
  /// objects will be held intact for any number of years until the event has
  /// occurred (event-based hold on the object is released) and then 3 more years
  /// after that. That means retention duration of the objects begins from the
  /// moment event-based hold transitioned from true to false.  Objects under
  /// event-based hold cannot be deleted, overwritten or archived until the hold
  /// is removed.
  final bool defaultEventBasedHold;

  /// Optional. User-provided labels, in key/value pairs.
  final Map<String, String> labels;

  /// Optional. The bucket's website config, controlling how the service behaves
  /// when accessing bucket contents as a web site. See the
  /// [https://cloud.google.com/storage/docs/static-website][Static Website
  /// Examples] for more information.
  final Bucket_Website? website;

  /// Optional. The bucket's versioning config.
  final Bucket_Versioning? versioning;

  /// Optional. The bucket's logging config, which defines the destination bucket
  /// and name prefix (if any) for the current bucket's logs.
  final Bucket_Logging? logging;

  /// Output only. The owner of the bucket. This is always the project team's
  /// owner group.
  final Owner? owner;

  /// Optional. Encryption config for a bucket.
  final Bucket_Encryption? encryption;

  /// Optional. The bucket's billing config.
  final Bucket_Billing? billing;

  /// Optional. The bucket's retention policy. The retention policy enforces a
  /// minimum retention time for all objects contained in the bucket, based on
  /// their creation time. Any attempt to overwrite or delete objects younger
  /// than the retention period will result in a PERMISSION_DENIED error.  An
  /// unlocked retention policy can be modified or removed from the bucket via a
  /// storage.buckets.update operation. A locked retention policy cannot be
  /// removed or shortened in duration for the lifetime of the bucket.
  /// Attempting to remove or decrease period of a locked retention policy will
  /// result in a PERMISSION_DENIED error.
  final Bucket_RetentionPolicy? retentionPolicy;

  /// Optional. The bucket's IAM config.
  final Bucket_IamConfig? iamConfig;

  /// Optional. Reserved for future use.
  final bool satisfiesPzs;

  /// Optional. Configuration that, if present, specifies the data placement for
  /// a
  /// [https://cloud.google.com/storage/docs/locations#location-dr][configurable
  /// dual-region].
  final Bucket_CustomPlacementConfig? customPlacementConfig;

  /// Optional. The bucket's Autoclass configuration. If there is no
  /// configuration, the Autoclass feature will be disabled and have no effect on
  /// the bucket.
  final Bucket_Autoclass? autoclass;

  /// Optional. The bucket's hierarchical namespace configuration. If there is no
  /// configuration, the hierarchical namespace feature will be disabled and have
  /// no effect on the bucket.
  final Bucket_HierarchicalNamespace? hierarchicalNamespace;

  /// Optional. The bucket's soft delete policy. The soft delete policy prevents
  /// soft-deleted objects from being permanently deleted.
  final Bucket_SoftDeletePolicy? softDeletePolicy;

  /// Optional. The bucket's object retention configuration. Must be enabled
  /// before objects in the bucket may have retention configured.
  final Bucket_ObjectRetention? objectRetention;

  /// Optional. The bucket's IP filter configuration.
  final Bucket_IpFilter? ipFilter;

  Bucket({
    this.name = '',
    this.bucketId = '',
    this.etag = '',
    this.project = '',
    this.metageneration = 0,
    this.location = '',
    this.locationType = '',
    this.storageClass = '',
    this.rpo = '',
    this.acl = const [],
    this.defaultObjectAcl = const [],
    this.lifecycle,
    this.createTime,
    this.cors = const [],
    this.updateTime,
    this.defaultEventBasedHold = false,
    this.labels = const {},
    this.website,
    this.versioning,
    this.logging,
    this.owner,
    this.encryption,
    this.billing,
    this.retentionPolicy,
    this.iamConfig,
    this.satisfiesPzs = false,
    this.customPlacementConfig,
    this.autoclass,
    this.hierarchicalNamespace,
    this.softDeletePolicy,
    this.objectRetention,
    this.ipFilter,
  }) : super(fullyQualifiedName);

  factory Bucket.fromJson(Map<String, dynamic> json) {
    return Bucket(
      name: json['name'] ?? '',
      bucketId: json['bucketId'] ?? '',
      etag: json['etag'] ?? '',
      project: json['project'] ?? '',
      metageneration: decodeInt64(json['metageneration']) ?? 0,
      location: json['location'] ?? '',
      locationType: json['locationType'] ?? '',
      storageClass: json['storageClass'] ?? '',
      rpo: json['rpo'] ?? '',
      acl: decodeListMessage(json['acl'], BucketAccessControl.fromJson) ?? [],
      defaultObjectAcl:
          decodeListMessage(
            json['defaultObjectAcl'],
            ObjectAccessControl.fromJson,
          ) ??
          [],
      lifecycle: decode(json['lifecycle'], Bucket_Lifecycle.fromJson),
      createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
      cors: decodeListMessage(json['cors'], Bucket_Cors.fromJson) ?? [],
      updateTime: decodeCustom(json['updateTime'], Timestamp.fromJson),
      defaultEventBasedHold: json['defaultEventBasedHold'] ?? false,
      labels: decodeMap(json['labels']) ?? {},
      website: decode(json['website'], Bucket_Website.fromJson),
      versioning: decode(json['versioning'], Bucket_Versioning.fromJson),
      logging: decode(json['logging'], Bucket_Logging.fromJson),
      owner: decode(json['owner'], Owner.fromJson),
      encryption: decode(json['encryption'], Bucket_Encryption.fromJson),
      billing: decode(json['billing'], Bucket_Billing.fromJson),
      retentionPolicy: decode(
        json['retentionPolicy'],
        Bucket_RetentionPolicy.fromJson,
      ),
      iamConfig: decode(json['iamConfig'], Bucket_IamConfig.fromJson),
      satisfiesPzs: json['satisfiesPzs'] ?? false,
      customPlacementConfig: decode(
        json['customPlacementConfig'],
        Bucket_CustomPlacementConfig.fromJson,
      ),
      autoclass: decode(json['autoclass'], Bucket_Autoclass.fromJson),
      hierarchicalNamespace: decode(
        json['hierarchicalNamespace'],
        Bucket_HierarchicalNamespace.fromJson,
      ),
      softDeletePolicy: decode(
        json['softDeletePolicy'],
        Bucket_SoftDeletePolicy.fromJson,
      ),
      objectRetention: decode(
        json['objectRetention'],
        Bucket_ObjectRetention.fromJson,
      ),
      ipFilter: decode(json['ipFilter'], Bucket_IpFilter.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name.isNotDefault) 'name': name,
      if (bucketId.isNotDefault) 'bucketId': bucketId,
      if (etag.isNotDefault) 'etag': etag,
      if (project.isNotDefault) 'project': project,
      if (metageneration.isNotDefault)
        'metageneration': encodeInt64(metageneration),
      if (location.isNotDefault) 'location': location,
      if (locationType.isNotDefault) 'locationType': locationType,
      if (storageClass.isNotDefault) 'storageClass': storageClass,
      if (rpo.isNotDefault) 'rpo': rpo,
      if (acl.isNotDefault) 'acl': encodeList(acl),
      if (defaultObjectAcl.isNotDefault)
        'defaultObjectAcl': encodeList(defaultObjectAcl),
      if (lifecycle != null) 'lifecycle': lifecycle!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (cors.isNotDefault) 'cors': encodeList(cors),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (defaultEventBasedHold.isNotDefault)
        'defaultEventBasedHold': defaultEventBasedHold,
      if (labels.isNotDefault) 'labels': labels,
      if (website != null) 'website': website!.toJson(),
      if (versioning != null) 'versioning': versioning!.toJson(),
      if (logging != null) 'logging': logging!.toJson(),
      if (owner != null) 'owner': owner!.toJson(),
      if (encryption != null) 'encryption': encryption!.toJson(),
      if (billing != null) 'billing': billing!.toJson(),
      if (retentionPolicy != null) 'retentionPolicy': retentionPolicy!.toJson(),
      if (iamConfig != null) 'iamConfig': iamConfig!.toJson(),
      if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
      if (customPlacementConfig != null)
        'customPlacementConfig': customPlacementConfig!.toJson(),
      if (autoclass != null) 'autoclass': autoclass!.toJson(),
      if (hierarchicalNamespace != null)
        'hierarchicalNamespace': hierarchicalNamespace!.toJson(),
      if (softDeletePolicy != null)
        'softDeletePolicy': softDeletePolicy!.toJson(),
      if (objectRetention != null) 'objectRetention': objectRetention!.toJson(),
      if (ipFilter != null) 'ipFilter': ipFilter!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      'bucketId=$bucketId',
      'etag=$etag',
      'project=$project',
      'metageneration=$metageneration',
      'location=$location',
      'locationType=$locationType',
      'storageClass=$storageClass',
      'rpo=$rpo',
      'defaultEventBasedHold=$defaultEventBasedHold',
      'satisfiesPzs=$satisfiesPzs',
    ].join(',');
    return 'Bucket($contents)';
  }
}

/// Billing properties of a bucket.
final class Bucket_Billing extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.Billing';

  /// Optional. When set to true, Requester Pays is enabled for this bucket.
  final bool requesterPays;

  Bucket_Billing({this.requesterPays = false}) : super(fullyQualifiedName);

  factory Bucket_Billing.fromJson(Map<String, dynamic> json) {
    return Bucket_Billing(requesterPays: json['requesterPays'] ?? false);
  }

  @override
  Object toJson() {
    return {if (requesterPays.isNotDefault) 'requesterPays': requesterPays};
  }

  @override
  String toString() {
    final contents = ['requesterPays=$requesterPays'].join(',');
    return 'Billing($contents)';
  }
}

/// Cross-Origin Response sharing (CORS) properties for a bucket.
/// For more on Cloud Storage and CORS, see
/// https://cloud.google.com/storage/docs/cross-origin.
/// For more on CORS in general, see https://tools.ietf.org/html/rfc6454.
final class Bucket_Cors extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.Cors';

  /// Optional. The list of Origins eligible to receive CORS response headers.
  /// See [https://tools.ietf.org/html/rfc6454][RFC 6454] for more on origins.
  /// Note: "*" is permitted in the list of origins, and means "any Origin".
  final List<String> origin;

  /// Optional. The list of HTTP methods on which to include CORS response
  /// headers,
  /// (`GET`, `OPTIONS`, `POST`, etc) Note: "*" is permitted in the list of
  /// methods, and means "any method".
  final List<String> method;

  /// Optional. The list of HTTP headers other than the
  /// [https://www.w3.org/TR/cors/#simple-response-header][simple response
  /// headers] to give permission for the user-agent to share across domains.
  final List<String> responseHeader;

  /// Optional. The value, in seconds, to return in the
  /// [https://www.w3.org/TR/cors/#access-control-max-age-response-header][Access-Control-Max-Age
  /// header] used in preflight responses.
  final int maxAgeSeconds;

  Bucket_Cors({
    this.origin = const [],
    this.method = const [],
    this.responseHeader = const [],
    this.maxAgeSeconds = 0,
  }) : super(fullyQualifiedName);

  factory Bucket_Cors.fromJson(Map<String, dynamic> json) {
    return Bucket_Cors(
      origin: decodeList(json['origin']) ?? [],
      method: decodeList(json['method']) ?? [],
      responseHeader: decodeList(json['responseHeader']) ?? [],
      maxAgeSeconds: json['maxAgeSeconds'] ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      if (origin.isNotDefault) 'origin': origin,
      if (method.isNotDefault) 'method': method,
      if (responseHeader.isNotDefault) 'responseHeader': responseHeader,
      if (maxAgeSeconds.isNotDefault) 'maxAgeSeconds': maxAgeSeconds,
    };
  }

  @override
  String toString() {
    final contents = ['maxAgeSeconds=$maxAgeSeconds'].join(',');
    return 'Cors($contents)';
  }
}

/// Encryption properties of a bucket.
final class Bucket_Encryption extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Encryption';

  /// Optional. The name of the Cloud KMS key that will be used to encrypt
  /// objects inserted into this bucket, if no encryption method is specified.
  final String defaultKmsKey;

  /// Optional. If omitted, then new objects with GMEK encryption-type is
  /// allowed. If set, then new objects created in this bucket must comply with
  /// enforcement config. Changing this has no effect on existing objects; it
  /// applies to new objects only.
  final Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig?
  googleManagedEncryptionEnforcementConfig;

  /// Optional. If omitted, then new objects with CMEK encryption-type is
  /// allowed. If set, then new objects created in this bucket must comply with
  /// enforcement config. Changing this has no effect on existing objects; it
  /// applies to new objects only.
  final Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig?
  customerManagedEncryptionEnforcementConfig;

  /// Optional. If omitted, then new objects with CSEK encryption-type is
  /// allowed. If set, then new objects created in this bucket must comply with
  /// enforcement config. Changing this has no effect on existing objects; it
  /// applies to new objects only.
  final Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig?
  customerSuppliedEncryptionEnforcementConfig;

  Bucket_Encryption({
    this.defaultKmsKey = '',
    this.googleManagedEncryptionEnforcementConfig,
    this.customerManagedEncryptionEnforcementConfig,
    this.customerSuppliedEncryptionEnforcementConfig,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption.fromJson(Map<String, dynamic> json) {
    return Bucket_Encryption(
      defaultKmsKey: json['defaultKmsKey'] ?? '',
      googleManagedEncryptionEnforcementConfig: decode(
        json['googleManagedEncryptionEnforcementConfig'],
        Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig.fromJson,
      ),
      customerManagedEncryptionEnforcementConfig: decode(
        json['customerManagedEncryptionEnforcementConfig'],
        Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig.fromJson,
      ),
      customerSuppliedEncryptionEnforcementConfig: decode(
        json['customerSuppliedEncryptionEnforcementConfig'],
        Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (defaultKmsKey.isNotDefault) 'defaultKmsKey': defaultKmsKey,
      if (googleManagedEncryptionEnforcementConfig != null)
        'googleManagedEncryptionEnforcementConfig':
            googleManagedEncryptionEnforcementConfig!.toJson(),
      if (customerManagedEncryptionEnforcementConfig != null)
        'customerManagedEncryptionEnforcementConfig':
            customerManagedEncryptionEnforcementConfig!.toJson(),
      if (customerSuppliedEncryptionEnforcementConfig != null)
        'customerSuppliedEncryptionEnforcementConfig':
            customerSuppliedEncryptionEnforcementConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['defaultKmsKey=$defaultKmsKey'].join(',');
    return 'Encryption($contents)';
  }
}

/// Google Managed Encryption (GMEK) enforcement config of a bucket.
final class Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Encryption.GoogleManagedEncryptionEnforcementConfig';

  /// Restriction mode for google-managed encryption for new objects within
  /// the bucket. Valid values are: "NotRestricted", "FullyRestricted".
  /// If `NotRestricted` or unset, creation of new objects with
  /// google-managed encryption is allowed.
  /// If `FullyRestricted`, new objects can't be created using google-managed
  /// encryption.
  final String? restrictionMode;

  /// Time from which the config was effective. This is service-provided.
  final Timestamp? effectiveTime;

  Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig({
    this.restrictionMode,
    this.effectiveTime,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig(
      restrictionMode: json['restrictionMode'],
      effectiveTime: decodeCustom(json['effectiveTime'], Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (restrictionMode != null) 'restrictionMode': restrictionMode,
      if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (restrictionMode != null) 'restrictionMode=$restrictionMode',
    ].join(',');
    return 'GoogleManagedEncryptionEnforcementConfig($contents)';
  }
}

/// Customer Managed Encryption (CMEK) enforcement config of a bucket.
final class Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Encryption.CustomerManagedEncryptionEnforcementConfig';

  /// Restriction mode for customer-managed encryption for new objects within
  /// the bucket. Valid values are: "NotRestricted", "FullyRestricted".
  /// If `NotRestricted` or unset, creation of new objects with
  /// customer-managed encryption is allowed.
  /// If `FullyRestricted`, new objects can't be created using
  /// customer-managed encryption.
  final String? restrictionMode;

  /// Time from which the config was effective. This is service-provided.
  final Timestamp? effectiveTime;

  Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig({
    this.restrictionMode,
    this.effectiveTime,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig(
      restrictionMode: json['restrictionMode'],
      effectiveTime: decodeCustom(json['effectiveTime'], Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (restrictionMode != null) 'restrictionMode': restrictionMode,
      if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (restrictionMode != null) 'restrictionMode=$restrictionMode',
    ].join(',');
    return 'CustomerManagedEncryptionEnforcementConfig($contents)';
  }
}

/// Customer Supplied Encryption (CSEK) enforcement config of a bucket.
final class Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Encryption.CustomerSuppliedEncryptionEnforcementConfig';

  /// Restriction mode for customer-supplied encryption for new objects
  /// within the bucket. Valid values are: "NotRestricted",
  /// "FullyRestricted".
  /// If `NotRestricted` or unset, creation of new objects with
  /// customer-supplied encryption is allowed.
  /// If `FullyRestricted`, new objects can't be created using
  /// customer-supplied encryption.
  final String? restrictionMode;

  /// Time from which the config was effective. This is service-provided.
  final Timestamp? effectiveTime;

  Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig({
    this.restrictionMode,
    this.effectiveTime,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig(
      restrictionMode: json['restrictionMode'],
      effectiveTime: decodeCustom(json['effectiveTime'], Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (restrictionMode != null) 'restrictionMode': restrictionMode,
      if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (restrictionMode != null) 'restrictionMode=$restrictionMode',
    ].join(',');
    return 'CustomerSuppliedEncryptionEnforcementConfig($contents)';
  }
}

/// Bucket restriction options.
final class Bucket_IamConfig extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.IamConfig';

  /// Optional. Bucket restriction options currently enforced on the bucket.
  final Bucket_IamConfig_UniformBucketLevelAccess? uniformBucketLevelAccess;

  /// Optional. Whether IAM will enforce public access prevention. Valid values
  /// are "enforced" or "inherited".
  final String publicAccessPrevention;

  Bucket_IamConfig({
    this.uniformBucketLevelAccess,
    this.publicAccessPrevention = '',
  }) : super(fullyQualifiedName);

  factory Bucket_IamConfig.fromJson(Map<String, dynamic> json) {
    return Bucket_IamConfig(
      uniformBucketLevelAccess: decode(
        json['uniformBucketLevelAccess'],
        Bucket_IamConfig_UniformBucketLevelAccess.fromJson,
      ),
      publicAccessPrevention: json['publicAccessPrevention'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (uniformBucketLevelAccess != null)
        'uniformBucketLevelAccess': uniformBucketLevelAccess!.toJson(),
      if (publicAccessPrevention.isNotDefault)
        'publicAccessPrevention': publicAccessPrevention,
    };
  }

  @override
  String toString() {
    final contents = [
      'publicAccessPrevention=$publicAccessPrevention',
    ].join(',');
    return 'IamConfig($contents)';
  }
}

/// Settings for Uniform Bucket level access.
/// See https://cloud.google.com/storage/docs/uniform-bucket-level-access.
final class Bucket_IamConfig_UniformBucketLevelAccess extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.IamConfig.UniformBucketLevelAccess';

  /// Optional. If set, access checks only use bucket-level IAM policies or
  /// above.
  final bool enabled;

  /// Optional. The deadline time for changing
  /// `iam_config.uniform_bucket_level_access.enabled` from `true` to
  /// `false`. Mutable until the specified deadline is reached, but not
  /// afterward.
  final Timestamp? lockTime;

  Bucket_IamConfig_UniformBucketLevelAccess({
    this.enabled = false,
    this.lockTime,
  }) : super(fullyQualifiedName);

  factory Bucket_IamConfig_UniformBucketLevelAccess.fromJson(
    Map<String, dynamic> json,
  ) {
    return Bucket_IamConfig_UniformBucketLevelAccess(
      enabled: json['enabled'] ?? false,
      lockTime: decodeCustom(json['lockTime'], Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (enabled.isNotDefault) 'enabled': enabled,
      if (lockTime != null) 'lockTime': lockTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['enabled=$enabled'].join(',');
    return 'UniformBucketLevelAccess($contents)';
  }
}

/// Lifecycle properties of a bucket.
/// For more information, see https://cloud.google.com/storage/docs/lifecycle.
final class Bucket_Lifecycle extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.Lifecycle';

  /// Optional. A lifecycle management rule, which is made of an action to take
  /// and the condition(s) under which the action will be taken.
  final List<Bucket_Lifecycle_Rule> rule;

  Bucket_Lifecycle({this.rule = const []}) : super(fullyQualifiedName);

  factory Bucket_Lifecycle.fromJson(Map<String, dynamic> json) {
    return Bucket_Lifecycle(
      rule:
          decodeListMessage(json['rule'], Bucket_Lifecycle_Rule.fromJson) ?? [],
    );
  }

  @override
  Object toJson() {
    return {if (rule.isNotDefault) 'rule': encodeList(rule)};
  }

  @override
  String toString() => 'Lifecycle()';
}

/// A lifecycle Rule, combining an action to take on an object and a
/// condition which will trigger that action.
final class Bucket_Lifecycle_Rule extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Lifecycle.Rule';

  /// Optional. The action to take.
  final Bucket_Lifecycle_Rule_Action? action;

  /// Optional. The condition(s) under which the action will be taken.
  final Bucket_Lifecycle_Rule_Condition? condition;

  Bucket_Lifecycle_Rule({this.action, this.condition})
    : super(fullyQualifiedName);

  factory Bucket_Lifecycle_Rule.fromJson(Map<String, dynamic> json) {
    return Bucket_Lifecycle_Rule(
      action: decode(json['action'], Bucket_Lifecycle_Rule_Action.fromJson),
      condition: decode(
        json['condition'],
        Bucket_Lifecycle_Rule_Condition.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (action != null) 'action': action!.toJson(),
      if (condition != null) 'condition': condition!.toJson(),
    };
  }

  @override
  String toString() => 'Rule()';
}

/// An action to take on an object.
final class Bucket_Lifecycle_Rule_Action extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Lifecycle.Rule.Action';

  /// Optional. Type of the action. Currently, only `Delete`,
  /// `SetStorageClass`, and `AbortIncompleteMultipartUpload` are
  /// supported.
  final String type;

  /// Optional. Target storage class. Required iff the type of the action
  /// is SetStorageClass.
  final String storageClass;

  Bucket_Lifecycle_Rule_Action({this.type = '', this.storageClass = ''})
    : super(fullyQualifiedName);

  factory Bucket_Lifecycle_Rule_Action.fromJson(Map<String, dynamic> json) {
    return Bucket_Lifecycle_Rule_Action(
      type: json['type'] ?? '',
      storageClass: json['storageClass'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (type.isNotDefault) 'type': type,
      if (storageClass.isNotDefault) 'storageClass': storageClass,
    };
  }

  @override
  String toString() {
    final contents = ['type=$type', 'storageClass=$storageClass'].join(',');
    return 'Action($contents)';
  }
}

/// A condition of an object which triggers some action.
final class Bucket_Lifecycle_Rule_Condition extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Lifecycle.Rule.Condition';

  /// Age of an object (in days). This condition is satisfied when an
  /// object reaches the specified age.
  /// A value of 0 indicates that all objects immediately match this
  /// condition.
  final int? ageDays;

  /// Optional. This condition is satisfied when an object is created
  /// before midnight of the specified date in UTC.
  final Date? createdBefore;

  /// Relevant only for versioned objects. If the value is
  /// `true`, this condition matches live objects; if the value
  /// is `false`, it matches archived objects.
  final bool? isLive;

  /// Relevant only for versioned objects. If the value is N, this
  /// condition is satisfied when there are at least N versions (including
  /// the live version) newer than this version of the object.
  final int? numNewerVersions;

  /// Optional. Objects having any of the storage classes specified by this
  /// condition will be matched. Values include `MULTI_REGIONAL`,
  /// `REGIONAL`, `NEARLINE`, `COLDLINE`, `STANDARD`, and
  /// `DURABLE_REDUCED_AVAILABILITY`.
  final List<String> matchesStorageClass;

  /// Number of days that have elapsed since the custom timestamp set on an
  /// object.
  /// The value of the field must be a nonnegative integer.
  final int? daysSinceCustomTime;

  /// Optional. An object matches this condition if the custom timestamp
  /// set on the object is before the specified date in UTC.
  final Date? customTimeBefore;

  /// This condition is relevant only for versioned objects. An object
  /// version satisfies this condition only if these many days have been
  /// passed since it became noncurrent. The value of the field must be a
  /// nonnegative integer. If it's zero, the object version will become
  /// eligible for Lifecycle action as soon as it becomes noncurrent.
  final int? daysSinceNoncurrentTime;

  /// Optional. This condition is relevant only for versioned objects. An
  /// object version satisfies this condition only if it became noncurrent
  /// before the specified date in UTC.
  final Date? noncurrentTimeBefore;

  /// Optional. List of object name prefixes. If any prefix exactly matches
  /// the beginning of the object name, the condition evaluates to true.
  final List<String> matchesPrefix;

  /// Optional. List of object name suffixes. If any suffix exactly matches
  /// the end of the object name, the condition evaluates to true.
  final List<String> matchesSuffix;

  Bucket_Lifecycle_Rule_Condition({
    this.ageDays,
    this.createdBefore,
    this.isLive,
    this.numNewerVersions,
    this.matchesStorageClass = const [],
    this.daysSinceCustomTime,
    this.customTimeBefore,
    this.daysSinceNoncurrentTime,
    this.noncurrentTimeBefore,
    this.matchesPrefix = const [],
    this.matchesSuffix = const [],
  }) : super(fullyQualifiedName);

  factory Bucket_Lifecycle_Rule_Condition.fromJson(Map<String, dynamic> json) {
    return Bucket_Lifecycle_Rule_Condition(
      ageDays: json['ageDays'],
      createdBefore: decode(json['createdBefore'], Date.fromJson),
      isLive: json['isLive'],
      numNewerVersions: json['numNewerVersions'],
      matchesStorageClass: decodeList(json['matchesStorageClass']) ?? [],
      daysSinceCustomTime: json['daysSinceCustomTime'],
      customTimeBefore: decode(json['customTimeBefore'], Date.fromJson),
      daysSinceNoncurrentTime: json['daysSinceNoncurrentTime'],
      noncurrentTimeBefore: decode(json['noncurrentTimeBefore'], Date.fromJson),
      matchesPrefix: decodeList(json['matchesPrefix']) ?? [],
      matchesSuffix: decodeList(json['matchesSuffix']) ?? [],
    );
  }

  @override
  Object toJson() {
    return {
      if (ageDays != null) 'ageDays': ageDays,
      if (createdBefore != null) 'createdBefore': createdBefore!.toJson(),
      if (isLive != null) 'isLive': isLive,
      if (numNewerVersions != null) 'numNewerVersions': numNewerVersions,
      if (matchesStorageClass.isNotDefault)
        'matchesStorageClass': matchesStorageClass,
      if (daysSinceCustomTime != null)
        'daysSinceCustomTime': daysSinceCustomTime,
      if (customTimeBefore != null)
        'customTimeBefore': customTimeBefore!.toJson(),
      if (daysSinceNoncurrentTime != null)
        'daysSinceNoncurrentTime': daysSinceNoncurrentTime,
      if (noncurrentTimeBefore != null)
        'noncurrentTimeBefore': noncurrentTimeBefore!.toJson(),
      if (matchesPrefix.isNotDefault) 'matchesPrefix': matchesPrefix,
      if (matchesSuffix.isNotDefault) 'matchesSuffix': matchesSuffix,
    };
  }

  @override
  String toString() {
    final contents = [
      if (ageDays != null) 'ageDays=$ageDays',
      if (isLive != null) 'isLive=$isLive',
      if (numNewerVersions != null) 'numNewerVersions=$numNewerVersions',
      if (daysSinceCustomTime != null)
        'daysSinceCustomTime=$daysSinceCustomTime',
      if (daysSinceNoncurrentTime != null)
        'daysSinceNoncurrentTime=$daysSinceNoncurrentTime',
    ].join(',');
    return 'Condition($contents)';
  }
}

/// Logging-related properties of a bucket.
final class Bucket_Logging extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.Logging';

  /// Optional. The destination bucket where the current bucket's logs should
  /// be placed, using path format (like `projects/123456/buckets/foo`).
  final String logBucket;

  /// Optional. A prefix for log object names.
  final String logObjectPrefix;

  Bucket_Logging({this.logBucket = '', this.logObjectPrefix = ''})
    : super(fullyQualifiedName);

  factory Bucket_Logging.fromJson(Map<String, dynamic> json) {
    return Bucket_Logging(
      logBucket: json['logBucket'] ?? '',
      logObjectPrefix: json['logObjectPrefix'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (logBucket.isNotDefault) 'logBucket': logBucket,
      if (logObjectPrefix.isNotDefault) 'logObjectPrefix': logObjectPrefix,
    };
  }

  @override
  String toString() {
    final contents = [
      'logBucket=$logBucket',
      'logObjectPrefix=$logObjectPrefix',
    ].join(',');
    return 'Logging($contents)';
  }
}

/// Object Retention related properties of a bucket.
final class Bucket_ObjectRetention extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.ObjectRetention';

  /// Optional. Output only. If true, object retention is enabled for the
  /// bucket.
  final bool enabled;

  Bucket_ObjectRetention({this.enabled = false}) : super(fullyQualifiedName);

  factory Bucket_ObjectRetention.fromJson(Map<String, dynamic> json) {
    return Bucket_ObjectRetention(enabled: json['enabled'] ?? false);
  }

  @override
  Object toJson() {
    return {if (enabled.isNotDefault) 'enabled': enabled};
  }

  @override
  String toString() {
    final contents = ['enabled=$enabled'].join(',');
    return 'ObjectRetention($contents)';
  }
}

/// Retention policy properties of a bucket.
final class Bucket_RetentionPolicy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.RetentionPolicy';

  /// Optional. Server-determined value that indicates the time from which
  /// policy was enforced and effective.
  final Timestamp? effectiveTime;

  /// Optional. Once locked, an object retention policy cannot be modified.
  final bool isLocked;

  /// Optional. The duration that objects need to be retained. Retention
  /// duration must be greater than zero and less than 100 years. Note that
  /// enforcement of retention periods less than a day is not guaranteed. Such
  /// periods should only be used for testing purposes. Any `nanos` value
  /// specified will be rounded down to the nearest second.
  final Duration? retentionDuration;

  Bucket_RetentionPolicy({
    this.effectiveTime,
    this.isLocked = false,
    this.retentionDuration,
  }) : super(fullyQualifiedName);

  factory Bucket_RetentionPolicy.fromJson(Map<String, dynamic> json) {
    return Bucket_RetentionPolicy(
      effectiveTime: decodeCustom(json['effectiveTime'], Timestamp.fromJson),
      isLocked: json['isLocked'] ?? false,
      retentionDuration: decodeCustom(
        json['retentionDuration'],
        Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
      if (isLocked.isNotDefault) 'isLocked': isLocked,
      if (retentionDuration != null)
        'retentionDuration': retentionDuration!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['isLocked=$isLocked'].join(',');
    return 'RetentionPolicy($contents)';
  }
}

/// Soft delete policy properties of a bucket.
final class Bucket_SoftDeletePolicy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.SoftDeletePolicy';

  /// The period of time that soft-deleted objects in the bucket must be
  /// retained and cannot be permanently deleted. The duration must be greater
  /// than or equal to 7 days and less than 1 year.
  final Duration? retentionDuration;

  /// Time from which the policy was effective. This is service-provided.
  final Timestamp? effectiveTime;

  Bucket_SoftDeletePolicy({this.retentionDuration, this.effectiveTime})
    : super(fullyQualifiedName);

  factory Bucket_SoftDeletePolicy.fromJson(Map<String, dynamic> json) {
    return Bucket_SoftDeletePolicy(
      retentionDuration: decodeCustom(
        json['retentionDuration'],
        Duration.fromJson,
      ),
      effectiveTime: decodeCustom(json['effectiveTime'], Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (retentionDuration != null)
        'retentionDuration': retentionDuration!.toJson(),
      if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    };
  }

  @override
  String toString() => 'SoftDeletePolicy()';
}

/// Properties of a bucket related to versioning.
/// For more on Cloud Storage versioning, see
/// https://cloud.google.com/storage/docs/object-versioning.
final class Bucket_Versioning extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.Versioning';

  /// Optional. While set to true, versioning is fully enabled for this bucket.
  final bool enabled;

  Bucket_Versioning({this.enabled = false}) : super(fullyQualifiedName);

  factory Bucket_Versioning.fromJson(Map<String, dynamic> json) {
    return Bucket_Versioning(enabled: json['enabled'] ?? false);
  }

  @override
  Object toJson() {
    return {if (enabled.isNotDefault) 'enabled': enabled};
  }

  @override
  String toString() {
    final contents = ['enabled=$enabled'].join(',');
    return 'Versioning($contents)';
  }
}

/// Properties of a bucket related to accessing the contents as a static
/// website. For more on hosting a static website via Cloud Storage, see
/// https://cloud.google.com/storage/docs/hosting-static-website.
final class Bucket_Website extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.Website';

  /// Optional. If the requested object path is missing, the service will
  /// ensure the path has a trailing '/', append this suffix, and attempt to
  /// retrieve the resulting object. This allows the creation of `index.html`
  /// objects to represent directory pages.
  final String mainPageSuffix;

  /// Optional. If the requested object path is missing, and any
  /// `mainPageSuffix` object is missing, if applicable, the service
  /// will return the named object from this bucket as the content for a
  /// [https://tools.ietf.org/html/rfc7231#section-6.5.4][404 Not Found]
  /// result.
  final String notFoundPage;

  Bucket_Website({this.mainPageSuffix = '', this.notFoundPage = ''})
    : super(fullyQualifiedName);

  factory Bucket_Website.fromJson(Map<String, dynamic> json) {
    return Bucket_Website(
      mainPageSuffix: json['mainPageSuffix'] ?? '',
      notFoundPage: json['notFoundPage'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (mainPageSuffix.isNotDefault) 'mainPageSuffix': mainPageSuffix,
      if (notFoundPage.isNotDefault) 'notFoundPage': notFoundPage,
    };
  }

  @override
  String toString() {
    final contents = [
      'mainPageSuffix=$mainPageSuffix',
      'notFoundPage=$notFoundPage',
    ].join(',');
    return 'Website($contents)';
  }
}

/// Configuration for Custom Dual Regions.  It should specify precisely two
/// eligible regions within the same Multiregion. More information on regions
/// may be found [here](https://cloud.google.com/storage/docs/locations).
final class Bucket_CustomPlacementConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.CustomPlacementConfig';

  /// Optional. List of locations to use for data placement.
  final List<String> dataLocations;

  Bucket_CustomPlacementConfig({this.dataLocations = const []})
    : super(fullyQualifiedName);

  factory Bucket_CustomPlacementConfig.fromJson(Map<String, dynamic> json) {
    return Bucket_CustomPlacementConfig(
      dataLocations: decodeList(json['dataLocations']) ?? [],
    );
  }

  @override
  Object toJson() {
    return {if (dataLocations.isNotDefault) 'dataLocations': dataLocations};
  }

  @override
  String toString() => 'CustomPlacementConfig()';
}

/// Configuration for a bucket's Autoclass feature.
final class Bucket_Autoclass extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.Autoclass';

  /// Optional. Enables Autoclass.
  final bool enabled;

  /// Output only. Latest instant at which the `enabled` field was set to true
  /// after being disabled/unconfigured or set to false after being enabled. If
  /// Autoclass is enabled when the bucket is created, the toggle_time is set
  /// to the bucket creation time.
  final Timestamp? toggleTime;

  /// An object in an Autoclass bucket will eventually cool down to the
  /// terminal storage class if there is no access to the object.
  /// The only valid values are NEARLINE and ARCHIVE.
  final String? terminalStorageClass;

  /// Output only. Latest instant at which the autoclass terminal storage class
  /// was updated.
  final Timestamp? terminalStorageClassUpdateTime;

  Bucket_Autoclass({
    this.enabled = false,
    this.toggleTime,
    this.terminalStorageClass,
    this.terminalStorageClassUpdateTime,
  }) : super(fullyQualifiedName);

  factory Bucket_Autoclass.fromJson(Map<String, dynamic> json) {
    return Bucket_Autoclass(
      enabled: json['enabled'] ?? false,
      toggleTime: decodeCustom(json['toggleTime'], Timestamp.fromJson),
      terminalStorageClass: json['terminalStorageClass'],
      terminalStorageClassUpdateTime: decodeCustom(
        json['terminalStorageClassUpdateTime'],
        Timestamp.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (enabled.isNotDefault) 'enabled': enabled,
      if (toggleTime != null) 'toggleTime': toggleTime!.toJson(),
      if (terminalStorageClass != null)
        'terminalStorageClass': terminalStorageClass,
      if (terminalStorageClassUpdateTime != null)
        'terminalStorageClassUpdateTime': terminalStorageClassUpdateTime!
            .toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'enabled=$enabled',
      if (terminalStorageClass != null)
        'terminalStorageClass=$terminalStorageClass',
    ].join(',');
    return 'Autoclass($contents)';
  }
}

/// The [bucket IP
/// filtering](https://cloud.google.com/storage/docs/ip-filtering-overview)
/// configuration. Specifies the network sources that can access the bucket, as
/// well as its underlying objects.
final class Bucket_IpFilter extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Bucket.IpFilter';

  /// The state of the IP filter configuration. Valid values are `Enabled` and
  /// `Disabled`. When set to `Enabled`, IP filtering rules are applied to a
  /// bucket and all incoming requests to the bucket are evaluated against
  /// these rules. When set to `Disabled`, IP filtering rules are not applied
  /// to a bucket.".
  final String? mode;

  /// Public IPs allowed to operate or access the bucket.
  final Bucket_IpFilter_PublicNetworkSource? publicNetworkSource;

  /// Optional. The list of network sources that are allowed to access
  /// operations on the bucket or the underlying objects.
  final List<Bucket_IpFilter_VpcNetworkSource> vpcNetworkSources;

  /// Optional. Whether or not to allow VPCs from orgs different than the
  /// bucket's parent org to access the bucket. When set to true, validations
  /// on the existence of the VPCs won't be performed. If set to false, each
  /// VPC network source will be checked to belong to the same org as the
  /// bucket as well as validated for existence.
  final bool allowCrossOrgVpcs;

  /// Whether or not to allow all P4SA access to the bucket. When set to true,
  /// IP filter config validation will not apply.
  final bool? allowAllServiceAgentAccess;

  Bucket_IpFilter({
    this.mode,
    this.publicNetworkSource,
    this.vpcNetworkSources = const [],
    this.allowCrossOrgVpcs = false,
    this.allowAllServiceAgentAccess,
  }) : super(fullyQualifiedName);

  factory Bucket_IpFilter.fromJson(Map<String, dynamic> json) {
    return Bucket_IpFilter(
      mode: json['mode'],
      publicNetworkSource: decode(
        json['publicNetworkSource'],
        Bucket_IpFilter_PublicNetworkSource.fromJson,
      ),
      vpcNetworkSources:
          decodeListMessage(
            json['vpcNetworkSources'],
            Bucket_IpFilter_VpcNetworkSource.fromJson,
          ) ??
          [],
      allowCrossOrgVpcs: json['allowCrossOrgVpcs'] ?? false,
      allowAllServiceAgentAccess: json['allowAllServiceAgentAccess'],
    );
  }

  @override
  Object toJson() {
    return {
      if (mode != null) 'mode': mode,
      if (publicNetworkSource != null)
        'publicNetworkSource': publicNetworkSource!.toJson(),
      if (vpcNetworkSources.isNotDefault)
        'vpcNetworkSources': encodeList(vpcNetworkSources),
      if (allowCrossOrgVpcs.isNotDefault)
        'allowCrossOrgVpcs': allowCrossOrgVpcs,
      if (allowAllServiceAgentAccess != null)
        'allowAllServiceAgentAccess': allowAllServiceAgentAccess,
    };
  }

  @override
  String toString() {
    final contents = [
      if (mode != null) 'mode=$mode',
      'allowCrossOrgVpcs=$allowCrossOrgVpcs',
      if (allowAllServiceAgentAccess != null)
        'allowAllServiceAgentAccess=$allowAllServiceAgentAccess',
    ].join(',');
    return 'IpFilter($contents)';
  }
}

/// The public network IP address ranges that can access the bucket and its
/// data.
final class Bucket_IpFilter_PublicNetworkSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.IpFilter.PublicNetworkSource';

  /// Optional. The list of IPv4 and IPv6 cidr blocks that are allowed to
  /// operate or access the bucket and its underlying objects.
  final List<String> allowedIpCidrRanges;

  Bucket_IpFilter_PublicNetworkSource({this.allowedIpCidrRanges = const []})
    : super(fullyQualifiedName);

  factory Bucket_IpFilter_PublicNetworkSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return Bucket_IpFilter_PublicNetworkSource(
      allowedIpCidrRanges: decodeList(json['allowedIpCidrRanges']) ?? [],
    );
  }

  @override
  Object toJson() {
    return {
      if (allowedIpCidrRanges.isNotDefault)
        'allowedIpCidrRanges': allowedIpCidrRanges,
    };
  }

  @override
  String toString() => 'PublicNetworkSource()';
}

/// The list of VPC networks that can access the bucket.
final class Bucket_IpFilter_VpcNetworkSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.IpFilter.VpcNetworkSource';

  /// Name of the network.
  ///
  /// Format: `projects/PROJECT_ID/global/networks/NETWORK_NAME`
  final String? network;

  /// Optional. The list of public or private IPv4 and IPv6 CIDR ranges that
  /// can access the bucket. In the CIDR IP address block, the specified IP
  /// address must be properly truncated, meaning all the host bits must be
  /// zero or else the input is considered malformed. For example,
  /// `192.0.2.0/24` is accepted but `192.0.2.1/24` is not. Similarly, for
  /// IPv6, `2001:db8::/32` is accepted whereas `2001:db8::1/32` is not.
  final List<String> allowedIpCidrRanges;

  Bucket_IpFilter_VpcNetworkSource({
    this.network,
    this.allowedIpCidrRanges = const [],
  }) : super(fullyQualifiedName);

  factory Bucket_IpFilter_VpcNetworkSource.fromJson(Map<String, dynamic> json) {
    return Bucket_IpFilter_VpcNetworkSource(
      network: json['network'],
      allowedIpCidrRanges: decodeList(json['allowedIpCidrRanges']) ?? [],
    );
  }

  @override
  Object toJson() {
    return {
      if (network != null) 'network': network,
      if (allowedIpCidrRanges.isNotDefault)
        'allowedIpCidrRanges': allowedIpCidrRanges,
    };
  }

  @override
  String toString() {
    final contents = [if (network != null) 'network=$network'].join(',');
    return 'VpcNetworkSource($contents)';
  }
}

/// Configuration for a bucket's hierarchical namespace feature.
final class Bucket_HierarchicalNamespace extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.Bucket.HierarchicalNamespace';

  /// Optional. Enables the hierarchical namespace feature.
  final bool enabled;

  Bucket_HierarchicalNamespace({this.enabled = false})
    : super(fullyQualifiedName);

  factory Bucket_HierarchicalNamespace.fromJson(Map<String, dynamic> json) {
    return Bucket_HierarchicalNamespace(enabled: json['enabled'] ?? false);
  }

  @override
  Object toJson() {
    return {if (enabled.isNotDefault) 'enabled': enabled};
  }

  @override
  String toString() {
    final contents = ['enabled=$enabled'].join(',');
    return 'HierarchicalNamespace($contents)';
  }
}

/// An access-control entry.
final class BucketAccessControl extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.BucketAccessControl';

  /// Optional. The access permission for the entity.
  final String role;

  /// Optional. The ID of the access-control entry.
  final String id;

  /// Optional. The entity holding the permission, in one of the following forms:
  /// * `user-{userid}`
  /// * `user-{email}`
  /// * `group-{groupid}`
  /// * `group-{email}`
  /// * `domain-{domain}`
  /// * `project-{team}-{projectnumber}`
  /// * `project-{team}-{projectid}`
  /// * `allUsers`
  /// * `allAuthenticatedUsers`
  /// Examples:
  /// * The user `liz@example.com` would be `user-liz@example.com`.
  /// * The group `example@googlegroups.com` would be
  /// `group-example@googlegroups.com`
  /// * All members of the Google Apps for Business domain `example.com` would be
  /// `domain-example.com`
  /// For project entities, `project-{team}-{projectnumber}` format will be
  /// returned on response.
  final String entity;

  /// Output only. The alternative entity format, if exists. For project
  /// entities, `project-{team}-{projectid}` format will be returned on response.
  final String entityAlt;

  /// Optional. The ID for the entity, if any.
  final String entityId;

  /// Optional. The etag of the BucketAccessControl.
  /// If included in the metadata of an update or delete request message, the
  /// operation operation will only be performed if the etag matches that of the
  /// bucket's BucketAccessControl.
  final String etag;

  /// Optional. The email address associated with the entity, if any.
  final String email;

  /// Optional. The domain associated with the entity, if any.
  final String domain;

  /// Optional. The project team associated with the entity, if any.
  final ProjectTeam? projectTeam;

  BucketAccessControl({
    this.role = '',
    this.id = '',
    this.entity = '',
    this.entityAlt = '',
    this.entityId = '',
    this.etag = '',
    this.email = '',
    this.domain = '',
    this.projectTeam,
  }) : super(fullyQualifiedName);

  factory BucketAccessControl.fromJson(Map<String, dynamic> json) {
    return BucketAccessControl(
      role: json['role'] ?? '',
      id: json['id'] ?? '',
      entity: json['entity'] ?? '',
      entityAlt: json['entityAlt'] ?? '',
      entityId: json['entityId'] ?? '',
      etag: json['etag'] ?? '',
      email: json['email'] ?? '',
      domain: json['domain'] ?? '',
      projectTeam: decode(json['projectTeam'], ProjectTeam.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (role.isNotDefault) 'role': role,
      if (id.isNotDefault) 'id': id,
      if (entity.isNotDefault) 'entity': entity,
      if (entityAlt.isNotDefault) 'entityAlt': entityAlt,
      if (entityId.isNotDefault) 'entityId': entityId,
      if (etag.isNotDefault) 'etag': etag,
      if (email.isNotDefault) 'email': email,
      if (domain.isNotDefault) 'domain': domain,
      if (projectTeam != null) 'projectTeam': projectTeam!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'role=$role',
      'id=$id',
      'entity=$entity',
      'entityAlt=$entityAlt',
      'entityId=$entityId',
      'etag=$etag',
      'email=$email',
      'domain=$domain',
    ].join(',');
    return 'BucketAccessControl($contents)';
  }
}

/// Message used to convey content being read or written, along with an optional
/// checksum.
final class ChecksummedData extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ChecksummedData';

  /// Optional. The data.
  final Uint8List? content;

  /// If set, the CRC32C digest of the content field.
  final int? crc32C;

  ChecksummedData({this.content, this.crc32C}) : super(fullyQualifiedName);

  factory ChecksummedData.fromJson(Map<String, dynamic> json) {
    return ChecksummedData(
      content: decodeBytes(json['content']),
      crc32C: json['crc32c'],
    );
  }

  @override
  Object toJson() {
    return {
      if (content != null) 'content': encodeBytes(content),
      if (crc32C != null) 'crc32c': crc32C,
    };
  }

  @override
  String toString() {
    final contents = [
      if (content != null) 'content=$content',
      if (crc32C != null) 'crc32c=$crc32C',
    ].join(',');
    return 'ChecksummedData($contents)';
  }
}

/// Message used for storing full (not subrange) object checksums.
final class ObjectChecksums extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ObjectChecksums';

  /// CRC32C digest of the object data. Computed by the Cloud Storage service for
  /// all written objects.
  /// If set in a WriteObjectRequest, service will validate that the stored
  /// object matches this checksum.
  final int? crc32C;

  /// Optional. 128 bit MD5 hash of the object data.
  /// For more information about using the MD5 hash, see
  /// [https://cloud.google.com/storage/docs/hashes-etags#json-api][Hashes and
  /// ETags: Best Practices].
  /// Not all objects will provide an MD5 hash. For example, composite objects
  /// provide only crc32c hashes. This value is equivalent to running `cat
  /// object.txt | openssl md5 -binary`
  final Uint8List? md5Hash;

  ObjectChecksums({this.crc32C, this.md5Hash}) : super(fullyQualifiedName);

  factory ObjectChecksums.fromJson(Map<String, dynamic> json) {
    return ObjectChecksums(
      crc32C: json['crc32c'],
      md5Hash: decodeBytes(json['md5Hash']),
    );
  }

  @override
  Object toJson() {
    return {
      if (crc32C != null) 'crc32c': crc32C,
      if (md5Hash != null) 'md5Hash': encodeBytes(md5Hash),
    };
  }

  @override
  String toString() {
    final contents = [
      if (crc32C != null) 'crc32c=$crc32C',
      if (md5Hash != null) 'md5Hash=$md5Hash',
    ].join(',');
    return 'ObjectChecksums($contents)';
  }
}

/// The payload of a single user-defined object context.
final class ObjectCustomContextPayload extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ObjectCustomContextPayload';

  /// Required. The value of the object context.
  final String value;

  /// Output only. The time at which the object context was created.
  final Timestamp? createTime;

  /// Output only. The time at which the object context was last updated.
  final Timestamp? updateTime;

  ObjectCustomContextPayload({
    required this.value,
    this.createTime,
    this.updateTime,
  }) : super(fullyQualifiedName);

  factory ObjectCustomContextPayload.fromJson(Map<String, dynamic> json) {
    return ObjectCustomContextPayload(
      value: json['value'] ?? '',
      createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'value': value,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['value=$value'].join(',');
    return 'ObjectCustomContextPayload($contents)';
  }
}

/// All contexts of an object grouped by type.
final class ObjectContexts extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ObjectContexts';

  /// Optional. User-defined object contexts.
  final Map<String, ObjectCustomContextPayload> custom;

  ObjectContexts({this.custom = const {}}) : super(fullyQualifiedName);

  factory ObjectContexts.fromJson(Map<String, dynamic> json) {
    return ObjectContexts(
      custom:
          decodeMapMessage(
            json['custom'],
            ObjectCustomContextPayload.fromJson,
          ) ??
          {},
    );
  }

  @override
  Object toJson() {
    return {if (custom.isNotDefault) 'custom': encodeMap(custom)};
  }

  @override
  String toString() => 'ObjectContexts()';
}

/// Describes the Customer-Supplied Encryption Key mechanism used to store an
/// Object's data at rest.
final class CustomerEncryption extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.CustomerEncryption';

  /// Optional. The encryption algorithm.
  final String encryptionAlgorithm;

  /// Optional. SHA256 hash value of the encryption key.
  /// In raw bytes format (not base64-encoded).
  final Uint8List? keySha256Bytes;

  CustomerEncryption({this.encryptionAlgorithm = '', this.keySha256Bytes})
    : super(fullyQualifiedName);

  factory CustomerEncryption.fromJson(Map<String, dynamic> json) {
    return CustomerEncryption(
      encryptionAlgorithm: json['encryptionAlgorithm'] ?? '',
      keySha256Bytes: decodeBytes(json['keySha256Bytes']),
    );
  }

  @override
  Object toJson() {
    return {
      if (encryptionAlgorithm.isNotDefault)
        'encryptionAlgorithm': encryptionAlgorithm,
      if (keySha256Bytes != null) 'keySha256Bytes': encodeBytes(keySha256Bytes),
    };
  }

  @override
  String toString() {
    final contents = [
      'encryptionAlgorithm=$encryptionAlgorithm',
      if (keySha256Bytes != null) 'keySha256Bytes=$keySha256Bytes',
    ].join(',');
    return 'CustomerEncryption($contents)';
  }
}

/// An object.
final class Object$ extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Object';

  /// Immutable. The name of this object. Nearly any sequence of unicode
  /// characters is valid. See
  /// [Guidelines](https://cloud.google.com/storage/docs/objects#naming).
  /// Example: `test.txt`
  /// The `name` field by itself does not uniquely identify a Cloud Storage
  /// object. A Cloud Storage object is uniquely identified by the tuple of
  /// (bucket, object, generation).
  final String name;

  /// Immutable. The name of the bucket containing this object.
  final String bucket;

  /// Optional. The etag of the object.
  /// If included in the metadata of an update or delete request message, the
  /// operation will only be performed if the etag matches that of the live
  /// object.
  final String etag;

  /// Immutable. The content generation of this object. Used for object
  /// versioning.
  final int generation;

  /// Output only. Restore token used to differentiate deleted objects with the
  /// same name and generation. This field is output only, and only set for
  /// deleted objects in HNS buckets.
  final String? restoreToken;

  /// Output only. The version of the metadata for this generation of this
  /// object. Used for preconditions and for detecting changes in metadata. A
  /// metageneration number is only meaningful in the context of a particular
  /// generation of a particular object.
  final int metageneration;

  /// Optional. Storage class of the object.
  final String storageClass;

  /// Output only. Content-Length of the object data in bytes, matching
  /// [https://tools.ietf.org/html/rfc7230#section-3.3.2][RFC 7230 3.3.2].
  final int size;

  /// Optional. Content-Encoding of the object data, matching
  /// [https://tools.ietf.org/html/rfc7231#section-3.1.2.2][RFC 7231 3.1.2.2]
  final String contentEncoding;

  /// Optional. Content-Disposition of the object data, matching
  /// [https://tools.ietf.org/html/rfc6266][RFC 6266].
  final String contentDisposition;

  /// Optional. Cache-Control directive for the object data, matching
  /// [https://tools.ietf.org/html/rfc7234#section-5.2"][RFC 7234 5.2].
  /// If omitted, and the object is accessible to all anonymous users, the
  /// default will be `public, max-age=3600`.
  final String cacheControl;

  /// Optional. Access controls on the object.
  /// If iam_config.uniform_bucket_level_access is enabled on the parent
  /// bucket, requests to set, read, or modify acl is an error.
  final List<ObjectAccessControl> acl;

  /// Optional. Content-Language of the object data, matching
  /// [https://tools.ietf.org/html/rfc7231#section-3.1.3.2][RFC 7231 3.1.3.2].
  final String contentLanguage;

  /// Output only. If this object is noncurrent, this is the time when the object
  /// became noncurrent.
  final Timestamp? deleteTime;

  /// Output only. The time when the object was finalized.
  final Timestamp? finalizeTime;

  /// Optional. Content-Type of the object data, matching
  /// [https://tools.ietf.org/html/rfc7231#section-3.1.1.5][RFC 7231 3.1.1.5].
  /// If an object is stored without a Content-Type, it is served as
  /// `application/octet-stream`.
  final String contentType;

  /// Output only. The creation time of the object.
  final Timestamp? createTime;

  /// Output only. Number of underlying components that make up this object.
  /// Components are accumulated by compose operations.
  final int componentCount;

  /// Output only. Hashes for the data part of this object. This field is used
  /// for output only and will be silently ignored if provided in requests. The
  /// checksums of the complete object regardless of data range. If the object is
  /// downloaded in full, the client should compute one of these checksums over
  /// the downloaded object and compare it against the value provided here.
  final ObjectChecksums? checksums;

  /// Output only. The modification time of the object metadata.
  /// Set initially to object creation time and then updated whenever any
  /// metadata of the object changes. This includes changes made by a requester,
  /// such as modifying custom metadata, as well as changes made by Cloud Storage
  /// on behalf of a requester, such as changing the storage class based on an
  /// Object Lifecycle Configuration.
  final Timestamp? updateTime;

  /// Optional. Cloud KMS Key used to encrypt this object, if the object is
  /// encrypted by such a key.
  final String kmsKey;

  /// Output only. The time at which the object's storage class was last changed.
  /// When the object is initially created, it will be set to time_created.
  final Timestamp? updateStorageClassTime;

  /// Optional. Whether an object is under temporary hold. While this flag is set
  /// to true, the object is protected against deletion and overwrites.  A common
  /// use case of this flag is regulatory investigations where objects need to be
  /// retained while the investigation is ongoing. Note that unlike event-based
  /// hold, temporary hold does not impact retention expiration time of an
  /// object.
  final bool temporaryHold;

  /// Optional. A server-determined value that specifies the earliest time that
  /// the object's retention period expires. Note 1: This field is not provided
  /// for objects with an active event-based hold, since retention expiration is
  /// unknown until the hold is removed. Note 2: This value can be provided even
  /// when temporary hold is set (so that the user can reason about policy
  /// without having to first unset the temporary hold).
  final Timestamp? retentionExpireTime;

  /// Optional. User-provided metadata, in key/value pairs.
  final Map<String, String> metadata;

  /// Optional. User-defined or system-defined object contexts. Each object
  /// context is a key-payload pair, where the key provides the identification
  /// and the payload holds the associated value and additional metadata.
  final ObjectContexts? contexts;

  /// Whether an object is under event-based hold.
  /// An event-based hold is a way to force the retention of an object until
  /// after some event occurs. Once the hold is released by explicitly setting
  /// this field to false, the object will become subject to any bucket-level
  /// retention policy, except that the retention duration will be calculated
  /// from the time the event based hold was lifted, rather than the time the
  /// object was created.
  ///
  /// In a WriteObject request, not setting this field implies that the value
  /// should be taken from the parent bucket's "default_event_based_hold" field.
  /// In a response, this field will always be set to true or false.
  final bool? eventBasedHold;

  /// Output only. The owner of the object. This will always be the uploader of
  /// the object.
  final Owner? owner;

  /// Optional. Metadata of Customer-Supplied Encryption Key, if the object is
  /// encrypted by such a key.
  final CustomerEncryption? customerEncryption;

  /// Optional. A user-specified timestamp set on an object.
  final Timestamp? customTime;

  /// Output only. This is the time when the object became soft-deleted.
  ///
  /// Soft-deleted objects are only accessible if a soft_delete_policy is
  /// enabled. Also see hard_delete_time.
  final Timestamp? softDeleteTime;

  /// Output only. The time when the object will be permanently deleted.
  ///
  /// Only set when an object becomes soft-deleted with a soft_delete_policy.
  /// Otherwise, the object will not be accessible.
  final Timestamp? hardDeleteTime;

  /// Optional. Retention configuration of this object.
  /// May only be configured if the bucket has object retention enabled.
  final Object$_Retention? retention;

  Object$({
    this.name = '',
    this.bucket = '',
    this.etag = '',
    this.generation = 0,
    this.restoreToken,
    this.metageneration = 0,
    this.storageClass = '',
    this.size = 0,
    this.contentEncoding = '',
    this.contentDisposition = '',
    this.cacheControl = '',
    this.acl = const [],
    this.contentLanguage = '',
    this.deleteTime,
    this.finalizeTime,
    this.contentType = '',
    this.createTime,
    this.componentCount = 0,
    this.checksums,
    this.updateTime,
    this.kmsKey = '',
    this.updateStorageClassTime,
    this.temporaryHold = false,
    this.retentionExpireTime,
    this.metadata = const {},
    this.contexts,
    this.eventBasedHold,
    this.owner,
    this.customerEncryption,
    this.customTime,
    this.softDeleteTime,
    this.hardDeleteTime,
    this.retention,
  }) : super(fullyQualifiedName);

  factory Object$.fromJson(Map<String, dynamic> json) {
    return Object$(
      name: json['name'] ?? '',
      bucket: json['bucket'] ?? '',
      etag: json['etag'] ?? '',
      generation: decodeInt64(json['generation']) ?? 0,
      restoreToken: json['restoreToken'],
      metageneration: decodeInt64(json['metageneration']) ?? 0,
      storageClass: json['storageClass'] ?? '',
      size: decodeInt64(json['size']) ?? 0,
      contentEncoding: json['contentEncoding'] ?? '',
      contentDisposition: json['contentDisposition'] ?? '',
      cacheControl: json['cacheControl'] ?? '',
      acl: decodeListMessage(json['acl'], ObjectAccessControl.fromJson) ?? [],
      contentLanguage: json['contentLanguage'] ?? '',
      deleteTime: decodeCustom(json['deleteTime'], Timestamp.fromJson),
      finalizeTime: decodeCustom(json['finalizeTime'], Timestamp.fromJson),
      contentType: json['contentType'] ?? '',
      createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
      componentCount: json['componentCount'] ?? 0,
      checksums: decode(json['checksums'], ObjectChecksums.fromJson),
      updateTime: decodeCustom(json['updateTime'], Timestamp.fromJson),
      kmsKey: json['kmsKey'] ?? '',
      updateStorageClassTime: decodeCustom(
        json['updateStorageClassTime'],
        Timestamp.fromJson,
      ),
      temporaryHold: json['temporaryHold'] ?? false,
      retentionExpireTime: decodeCustom(
        json['retentionExpireTime'],
        Timestamp.fromJson,
      ),
      metadata: decodeMap(json['metadata']) ?? {},
      contexts: decode(json['contexts'], ObjectContexts.fromJson),
      eventBasedHold: json['eventBasedHold'],
      owner: decode(json['owner'], Owner.fromJson),
      customerEncryption: decode(
        json['customerEncryption'],
        CustomerEncryption.fromJson,
      ),
      customTime: decodeCustom(json['customTime'], Timestamp.fromJson),
      softDeleteTime: decodeCustom(json['softDeleteTime'], Timestamp.fromJson),
      hardDeleteTime: decodeCustom(json['hardDeleteTime'], Timestamp.fromJson),
      retention: decode(json['retention'], Object$_Retention.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name.isNotDefault) 'name': name,
      if (bucket.isNotDefault) 'bucket': bucket,
      if (etag.isNotDefault) 'etag': etag,
      if (generation.isNotDefault) 'generation': encodeInt64(generation),
      if (restoreToken != null) 'restoreToken': restoreToken,
      if (metageneration.isNotDefault)
        'metageneration': encodeInt64(metageneration),
      if (storageClass.isNotDefault) 'storageClass': storageClass,
      if (size.isNotDefault) 'size': encodeInt64(size),
      if (contentEncoding.isNotDefault) 'contentEncoding': contentEncoding,
      if (contentDisposition.isNotDefault)
        'contentDisposition': contentDisposition,
      if (cacheControl.isNotDefault) 'cacheControl': cacheControl,
      if (acl.isNotDefault) 'acl': encodeList(acl),
      if (contentLanguage.isNotDefault) 'contentLanguage': contentLanguage,
      if (deleteTime != null) 'deleteTime': deleteTime!.toJson(),
      if (finalizeTime != null) 'finalizeTime': finalizeTime!.toJson(),
      if (contentType.isNotDefault) 'contentType': contentType,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (componentCount.isNotDefault) 'componentCount': componentCount,
      if (checksums != null) 'checksums': checksums!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (kmsKey.isNotDefault) 'kmsKey': kmsKey,
      if (updateStorageClassTime != null)
        'updateStorageClassTime': updateStorageClassTime!.toJson(),
      if (temporaryHold.isNotDefault) 'temporaryHold': temporaryHold,
      if (retentionExpireTime != null)
        'retentionExpireTime': retentionExpireTime!.toJson(),
      if (metadata.isNotDefault) 'metadata': metadata,
      if (contexts != null) 'contexts': contexts!.toJson(),
      if (eventBasedHold != null) 'eventBasedHold': eventBasedHold,
      if (owner != null) 'owner': owner!.toJson(),
      if (customerEncryption != null)
        'customerEncryption': customerEncryption!.toJson(),
      if (customTime != null) 'customTime': customTime!.toJson(),
      if (softDeleteTime != null) 'softDeleteTime': softDeleteTime!.toJson(),
      if (hardDeleteTime != null) 'hardDeleteTime': hardDeleteTime!.toJson(),
      if (retention != null) 'retention': retention!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      'bucket=$bucket',
      'etag=$etag',
      'generation=$generation',
      if (restoreToken != null) 'restoreToken=$restoreToken',
      'metageneration=$metageneration',
      'storageClass=$storageClass',
      'size=$size',
      'contentEncoding=$contentEncoding',
      'contentDisposition=$contentDisposition',
      'cacheControl=$cacheControl',
      'contentLanguage=$contentLanguage',
      'contentType=$contentType',
      'componentCount=$componentCount',
      'kmsKey=$kmsKey',
      'temporaryHold=$temporaryHold',
      if (eventBasedHold != null) 'eventBasedHold=$eventBasedHold',
    ].join(',');
    return 'Object($contents)';
  }
}

/// Specifies retention parameters of the object. Objects under retention
/// cannot be deleted or overwritten until their retention expires.
final class Object$_Retention extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Object.Retention';

  /// Optional. The mode of the Retention.
  final Object$_Retention_Mode mode;

  /// Optional. The timestamp that the object needs to be retained until.
  /// Value cannot be set in the past or more than 100 years in the future.
  final Timestamp? retainUntilTime;

  Object$_Retention({
    this.mode = Object$_Retention_Mode.$default,
    this.retainUntilTime,
  }) : super(fullyQualifiedName);

  factory Object$_Retention.fromJson(Map<String, dynamic> json) {
    return Object$_Retention(
      mode:
          decodeEnum(json['mode'], Object$_Retention_Mode.fromJson) ??
          Object$_Retention_Mode.$default,
      retainUntilTime: decodeCustom(
        json['retainUntilTime'],
        Timestamp.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (mode.isNotDefault) 'mode': mode.toJson(),
      if (retainUntilTime != null) 'retainUntilTime': retainUntilTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['mode=$mode'].join(',');
    return 'Retention($contents)';
  }
}

/// Retention mode values.
final class Object$_Retention_Mode extends ProtoEnum {
  /// No specified mode. Object is not under retention.
  static const modeUnspecified = Object$_Retention_Mode('MODE_UNSPECIFIED');

  /// Retention period may be decreased or increased.
  /// The Retention configuration may be removed.
  /// The mode may be changed to locked.
  static const unlocked = Object$_Retention_Mode('UNLOCKED');

  /// Retention period may be increased.
  /// The Retention configuration cannot be removed.
  /// The mode cannot be changed.
  static const locked = Object$_Retention_Mode('LOCKED');

  /// The default value for [Object$_Retention_Mode].
  static const $default = modeUnspecified;

  const Object$_Retention_Mode(super.value);

  factory Object$_Retention_Mode.fromJson(String json) =>
      Object$_Retention_Mode(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Mode.$value';
}

/// An access-control entry.
final class ObjectAccessControl extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ObjectAccessControl';

  /// Optional. The access permission for the entity. One of the following
  /// values:
  /// * `READER`
  /// * `WRITER`
  /// * `OWNER`
  final String role;

  /// Optional. The ID of the access-control entry.
  final String id;

  /// Optional. The entity holding the permission, in one of the following forms:
  /// * `user-{userid}`
  /// * `user-{email}`
  /// * `group-{groupid}`
  /// * `group-{email}`
  /// * `domain-{domain}`
  /// * `project-{team}-{projectnumber}`
  /// * `project-{team}-{projectid}`
  /// * `allUsers`
  /// * `allAuthenticatedUsers`
  /// Examples:
  /// * The user `liz@example.com` would be `user-liz@example.com`.
  /// * The group `example@googlegroups.com` would be
  /// `group-example@googlegroups.com`.
  /// * All members of the Google Apps for Business domain `example.com` would be
  /// `domain-example.com`.
  /// For project entities, `project-{team}-{projectnumber}` format will be
  /// returned on response.
  final String entity;

  /// Output only. The alternative entity format, if exists. For project
  /// entities, `project-{team}-{projectid}` format will be returned on response.
  final String entityAlt;

  /// Optional. The ID for the entity, if any.
  final String entityId;

  /// Optional. The etag of the ObjectAccessControl.
  /// If included in the metadata of an update or delete request message, the
  /// operation will only be performed if the etag matches that of the live
  /// object's ObjectAccessControl.
  final String etag;

  /// Optional. The email address associated with the entity, if any.
  final String email;

  /// Optional. The domain associated with the entity, if any.
  final String domain;

  /// Optional. The project team associated with the entity, if any.
  final ProjectTeam? projectTeam;

  ObjectAccessControl({
    this.role = '',
    this.id = '',
    this.entity = '',
    this.entityAlt = '',
    this.entityId = '',
    this.etag = '',
    this.email = '',
    this.domain = '',
    this.projectTeam,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControl.fromJson(Map<String, dynamic> json) {
    return ObjectAccessControl(
      role: json['role'] ?? '',
      id: json['id'] ?? '',
      entity: json['entity'] ?? '',
      entityAlt: json['entityAlt'] ?? '',
      entityId: json['entityId'] ?? '',
      etag: json['etag'] ?? '',
      email: json['email'] ?? '',
      domain: json['domain'] ?? '',
      projectTeam: decode(json['projectTeam'], ProjectTeam.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (role.isNotDefault) 'role': role,
      if (id.isNotDefault) 'id': id,
      if (entity.isNotDefault) 'entity': entity,
      if (entityAlt.isNotDefault) 'entityAlt': entityAlt,
      if (entityId.isNotDefault) 'entityId': entityId,
      if (etag.isNotDefault) 'etag': etag,
      if (email.isNotDefault) 'email': email,
      if (domain.isNotDefault) 'domain': domain,
      if (projectTeam != null) 'projectTeam': projectTeam!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'role=$role',
      'id=$id',
      'entity=$entity',
      'entityAlt=$entityAlt',
      'entityId=$entityId',
      'etag=$etag',
      'email=$email',
      'domain=$domain',
    ].join(',');
    return 'ObjectAccessControl($contents)';
  }
}

/// The result of a call to Objects.ListObjects
final class ListObjectsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.storage.v2.ListObjectsResponse';

  /// The list of items.
  final List<Object$> objects;

  /// The list of prefixes of objects matching-but-not-listed up to and including
  /// the requested delimiter.
  final List<String> prefixes;

  /// The continuation token, used to page through large result sets. Provide
  /// this value in a subsequent request to return the next page of results.
  final String nextPageToken;

  ListObjectsResponse({
    this.objects = const [],
    this.prefixes = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListObjectsResponse.fromJson(Map<String, dynamic> json) {
    return ListObjectsResponse(
      objects: decodeListMessage(json['objects'], Object$.fromJson) ?? [],
      prefixes: decodeList(json['prefixes']) ?? [],
      nextPageToken: json['nextPageToken'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (objects.isNotDefault) 'objects': encodeList(objects),
      if (prefixes.isNotDefault) 'prefixes': prefixes,
      if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListObjectsResponse($contents)';
  }
}

/// Represents the Viewers, Editors, or Owners of a given project.
final class ProjectTeam extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ProjectTeam';

  /// Optional. The project number.
  final String projectNumber;

  /// Optional. The team.
  final String team;

  ProjectTeam({this.projectNumber = '', this.team = ''})
    : super(fullyQualifiedName);

  factory ProjectTeam.fromJson(Map<String, dynamic> json) {
    return ProjectTeam(
      projectNumber: json['projectNumber'] ?? '',
      team: json['team'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (projectNumber.isNotDefault) 'projectNumber': projectNumber,
      if (team.isNotDefault) 'team': team,
    };
  }

  @override
  String toString() {
    final contents = ['projectNumber=$projectNumber', 'team=$team'].join(',');
    return 'ProjectTeam($contents)';
  }
}

/// The owner of a specific resource.
final class Owner extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.Owner';

  /// Optional. The entity, in the form `user-`*userId*.
  final String entity;

  /// Optional. The ID for the entity.
  final String entityId;

  Owner({this.entity = '', this.entityId = ''}) : super(fullyQualifiedName);

  factory Owner.fromJson(Map<String, dynamic> json) {
    return Owner(
      entity: json['entity'] ?? '',
      entityId: json['entityId'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (entity.isNotDefault) 'entity': entity,
      if (entityId.isNotDefault) 'entityId': entityId,
    };
  }

  @override
  String toString() {
    final contents = ['entity=$entity', 'entityId=$entityId'].join(',');
    return 'Owner($contents)';
  }
}

/// Specifies a requested range of bytes to download.
final class ContentRange extends ProtoMessage {
  static const String fullyQualifiedName = 'google.storage.v2.ContentRange';

  /// The starting offset of the object data. This value is inclusive.
  final int start;

  /// The ending offset of the object data. This value is exclusive.
  final int end;

  /// The complete length of the object data.
  final int completeLength;

  ContentRange({this.start = 0, this.end = 0, this.completeLength = 0})
    : super(fullyQualifiedName);

  factory ContentRange.fromJson(Map<String, dynamic> json) {
    return ContentRange(
      start: decodeInt64(json['start']) ?? 0,
      end: decodeInt64(json['end']) ?? 0,
      completeLength: decodeInt64(json['completeLength']) ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      if (start.isNotDefault) 'start': encodeInt64(start),
      if (end.isNotDefault) 'end': encodeInt64(end),
      if (completeLength.isNotDefault)
        'completeLength': encodeInt64(completeLength),
    };
  }

  @override
  String toString() {
    final contents = [
      'start=$start',
      'end=$end',
      'completeLength=$completeLength',
    ].join(',');
    return 'ContentRange($contents)';
  }
}

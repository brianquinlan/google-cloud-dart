// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Cloud Storage JSON API.
///
/// Stores and retrieves potentially large, immutable data objects.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// Service for the `anywhereCaches` resource.
final class anywhereCaches {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `anywhereCaches` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `anywhereCaches`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  anywhereCaches({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `anywhereCaches` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory anywhereCaches.fromApiKey([String? apiKey]) =>
      anywhereCaches(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Disables an Anywhere Cache instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnywhereCache> disable(AnywhereCaches_DisableRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/anywhereCaches/${request.anywhereCacheId}/disable',
    );
    final response = await _client.post(url);
    return AnywhereCache.fromJson(response);
  }

  /// Returns the metadata of an Anywhere Cache instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnywhereCache> get(AnywhereCaches_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/anywhereCaches/${request.anywhereCacheId}',
    );
    final response = await _client.get(url);
    return AnywhereCache.fromJson(response);
  }

  /// Creates an Anywhere Cache instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GoogleLongrunningOperation> insert(
    AnywhereCaches_InsertRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/anywhereCaches',
    );
    final response = await _client.post(url, body: request.body);
    return GoogleLongrunningOperation.fromJson(response);
  }

  /// Returns a list of Anywhere Cache instances of the bucket matching the criteria.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnywhereCaches> list(AnywhereCaches_ListRequest request) async {
    final url =
        Uri.https(_host, '/storage/v1/b/${request.bucket}/anywhereCaches', {
          if (request.pageSize case final $1?) 'pageSize': '${$1}',
          if (request.pageToken case final $1?) 'pageToken': $1,
        });
    final response = await _client.get(url);
    return AnywhereCaches.fromJson(response);
  }

  /// Pauses an Anywhere Cache instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnywhereCache> pause(AnywhereCaches_PauseRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/anywhereCaches/${request.anywhereCacheId}/pause',
    );
    final response = await _client.post(url);
    return AnywhereCache.fromJson(response);
  }

  /// Resumes a paused or disabled Anywhere Cache instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnywhereCache> resume(AnywhereCaches_ResumeRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/anywhereCaches/${request.anywhereCacheId}/resume',
    );
    final response = await _client.post(url);
    return AnywhereCache.fromJson(response);
  }

  /// Updates the config(ttl and admissionPolicy) of an Anywhere Cache instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GoogleLongrunningOperation> update(
    AnywhereCaches_UpdateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/anywhereCaches/${request.anywhereCacheId}',
    );
    final response = await _client.patch(url, body: request.body);
    return GoogleLongrunningOperation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `bucketAccessControls` resource.
final class bucketAccessControls {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `bucketAccessControls` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `bucketAccessControls`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  bucketAccessControls({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `bucketAccessControls` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory bucketAccessControls.fromApiKey([String? apiKey]) =>
      bucketAccessControls(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Permanently deletes the ACL entry for the specified entity on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(BucketAccessControls_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/acl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    await _client.delete(url);
  }

  /// Returns the ACL entry for the specified entity on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BucketAccessControl> get(
    BucketAccessControls_GetRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/acl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.get(url);
    return BucketAccessControl.fromJson(response);
  }

  /// Creates a new ACL entry on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BucketAccessControl> insert(
    BucketAccessControls_InsertRequest request,
  ) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/acl', {
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.post(url, body: request.body);
    return BucketAccessControl.fromJson(response);
  }

  /// Retrieves ACL entries on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BucketAccessControls> list(
    BucketAccessControls_ListRequest request,
  ) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/acl', {
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.get(url);
    return BucketAccessControls.fromJson(response);
  }

  /// Patches an ACL entry on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BucketAccessControl> patch(
    BucketAccessControls_PatchRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/acl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.patch(url, body: request.body);
    return BucketAccessControl.fromJson(response);
  }

  /// Updates an ACL entry on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BucketAccessControl> update(
    BucketAccessControls_UpdateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/acl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.put(url, body: request.body);
    return BucketAccessControl.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `buckets` resource.
final class buckets {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `buckets` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `buckets`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  buckets({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `buckets` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory buckets.fromApiKey([String? apiKey]) =>
      buckets(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Deletes an empty bucket. Deletions are permanent unless soft delete is enabled on the bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(Buckets_DeleteRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}', {
      if (request.ifMetagenerationMatch case final $1?)
        'ifMetagenerationMatch': '${$1}',
      if (request.ifMetagenerationNotMatch case final $1?)
        'ifMetagenerationNotMatch': '${$1}',
      if (request.userProject case final $1?) 'userProject': $1,
    });
    await _client.delete(url);
  }

  /// Returns metadata for the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Bucket> get(Buckets_GetRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}', {
      if (request.generation case final $1?) 'generation': '${$1}',
      if (request.ifMetagenerationMatch case final $1?)
        'ifMetagenerationMatch': '${$1}',
      if (request.ifMetagenerationNotMatch case final $1?)
        'ifMetagenerationNotMatch': '${$1}',
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.softDeleted case final $1?) 'softDeleted': '${$1}',
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.get(url);
    return Bucket.fromJson(response);
  }

  /// Returns an IAM policy for the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(Buckets_GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/iam', {
      if (request.optionsRequestedPolicyVersion case final $1?)
        'optionsRequestedPolicyVersion': '${$1}',
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Returns the storage layout configuration for the specified bucket. Note that this operation requires storage.objects.list permission.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BucketStorageLayout> getStorageLayout(
    Buckets_GetStorageLayoutRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/storageLayout',
      {if (request.prefix case final $1?) 'prefix': $1},
    );
    final response = await _client.get(url);
    return BucketStorageLayout.fromJson(response);
  }

  /// Creates a new bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Bucket> insert(Buckets_InsertRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b', {
      if (request.enableObjectRetention case final $1?)
        'enableObjectRetention': '${$1}',
      if (request.predefinedAcl case final $1?) 'predefinedAcl': $1.value,
      if (request.predefinedDefaultObjectAcl case final $1?)
        'predefinedDefaultObjectAcl': $1.value,
      if (request.project case final $1 when $1.isNotDefault) 'project': $1,
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.post(url, body: request.body);
    return Bucket.fromJson(response);
  }

  /// Retrieves a list of buckets for a given project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Buckets> list(Buckets_ListRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b', {
      if (request.maxResults case final $1?) 'maxResults': '${$1}',
      if (request.pageToken case final $1?) 'pageToken': $1,
      if (request.prefix case final $1?) 'prefix': $1,
      if (request.project case final $1 when $1.isNotDefault) 'project': $1,
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.softDeleted case final $1?) 'softDeleted': '${$1}',
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.get(url);
    return Buckets.fromJson(response);
  }

  /// Locks retention policy on a bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Bucket> lockRetentionPolicy(
    Buckets_LockRetentionPolicyRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/lockRetentionPolicy',
      {
        if (request.ifMetagenerationMatch case final $1 when $1.isNotDefault)
          'ifMetagenerationMatch': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.post(url);
    return Bucket.fromJson(response);
  }

  /// Patches a bucket. Changes to the bucket will be readable immediately after writing, but configuration changes may take time to propagate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Bucket> patch(Buckets_PatchRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}', {
      if (request.ifMetagenerationMatch case final $1?)
        'ifMetagenerationMatch': '${$1}',
      if (request.ifMetagenerationNotMatch case final $1?)
        'ifMetagenerationNotMatch': '${$1}',
      if (request.predefinedAcl case final $1?) 'predefinedAcl': $1.value,
      if (request.predefinedDefaultObjectAcl case final $1?)
        'predefinedDefaultObjectAcl': $1.value,
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.patch(url, body: request.body);
    return Bucket.fromJson(response);
  }

  /// Initiates a long-running Relocate Bucket operation on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GoogleLongrunningOperation> relocate(
    Buckets_RelocateRequest request,
  ) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/relocate');
    final response = await _client.post(url, body: request.body);
    return GoogleLongrunningOperation.fromJson(response);
  }

  /// Restores a soft-deleted bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Bucket> restore(Buckets_RestoreRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/restore', {
      if (request.generation case final $1 when $1.isNotDefault)
        'generation': '${$1}',
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.post(url);
    return Bucket.fromJson(response);
  }

  /// Updates an IAM policy for the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(Buckets_SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/iam', {
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.put(url, body: request.body);
    return Policy.fromJson(response);
  }

  /// Tests a set of permissions on the given bucket to see which, if any, are held by the caller.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    Buckets_TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/iam/testPermissions',
      {
        if (request.permissions case final $1 when $1.isNotDefault)
          'permissions': $1,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Updates a bucket. Changes to the bucket will be readable immediately after writing, but configuration changes may take time to propagate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Bucket> update(Buckets_UpdateRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}', {
      if (request.ifMetagenerationMatch case final $1?)
        'ifMetagenerationMatch': '${$1}',
      if (request.ifMetagenerationNotMatch case final $1?)
        'ifMetagenerationNotMatch': '${$1}',
      if (request.predefinedAcl case final $1?) 'predefinedAcl': $1.value,
      if (request.predefinedDefaultObjectAcl case final $1?)
        'predefinedDefaultObjectAcl': $1.value,
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.userProject case final $1?) 'userProject': $1,
    });
    final response = await _client.put(url, body: request.body);
    return Bucket.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `channels` resource.
final class channels {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `channels` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `channels`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  channels({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `channels` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory channels.fromApiKey([String? apiKey]) =>
      channels(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Stop watching resources through this channel
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> stop(Channels_StopRequest request) async {
    final url = Uri.https(_host, '/storage/v1/channels/stop');
    await _client.post(url, body: request.body);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `defaultObjectAccessControls` resource.
final class defaultObjectAccessControls {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `defaultObjectAccessControls` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `defaultObjectAccessControls`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  defaultObjectAccessControls({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `defaultObjectAccessControls` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory defaultObjectAccessControls.fromApiKey([String? apiKey]) =>
      defaultObjectAccessControls(
        client: httpClientFromApiKey(apiKey, _apiKeys),
      );

  /// Permanently deletes the default object ACL entry for the specified entity on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(DefaultObjectAccessControls_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/defaultObjectAcl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    await _client.delete(url);
  }

  /// Returns the default object ACL entry for the specified entity on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> get(
    DefaultObjectAccessControls_GetRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/defaultObjectAcl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.get(url);
    return ObjectAccessControl.fromJson(response);
  }

  /// Creates a new default object ACL entry on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> insert(
    DefaultObjectAccessControls_InsertRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/defaultObjectAcl',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.post(url, body: request.body);
    return ObjectAccessControl.fromJson(response);
  }

  /// Retrieves default object ACL entries on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControls> list(
    DefaultObjectAccessControls_ListRequest request,
  ) async {
    final url =
        Uri.https(_host, '/storage/v1/b/${request.bucket}/defaultObjectAcl', {
          if (request.ifMetagenerationMatch case final $1?)
            'ifMetagenerationMatch': '${$1}',
          if (request.ifMetagenerationNotMatch case final $1?)
            'ifMetagenerationNotMatch': '${$1}',
          if (request.userProject case final $1?) 'userProject': $1,
        });
    final response = await _client.get(url);
    return ObjectAccessControls.fromJson(response);
  }

  /// Patches a default object ACL entry on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> patch(
    DefaultObjectAccessControls_PatchRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/defaultObjectAcl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.patch(url, body: request.body);
    return ObjectAccessControl.fromJson(response);
  }

  /// Updates a default object ACL entry on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> update(
    DefaultObjectAccessControls_UpdateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/defaultObjectAcl/${request.entity}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.put(url, body: request.body);
    return ObjectAccessControl.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `folders` resource.
final class folders {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `folders` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `folders`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  folders({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `folders` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory folders.fromApiKey([String? apiKey]) =>
      folders(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Permanently deletes a folder. Only applicable to buckets with hierarchical namespace enabled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(Folders_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/folders/${request.folder}',
      {
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
      },
    );
    await _client.delete(url);
  }

  /// Returns metadata for the specified folder. Only applicable to buckets with hierarchical namespace enabled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Folder> get(Folders_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/folders/${request.folder}',
      {
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
      },
    );
    final response = await _client.get(url);
    return Folder.fromJson(response);
  }

  /// Creates a new folder. Only applicable to buckets with hierarchical namespace enabled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Folder> insert(Folders_InsertRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/folders', {
      if (request.recursive case final $1?) 'recursive': '${$1}',
    });
    final response = await _client.post(url, body: request.body);
    return Folder.fromJson(response);
  }

  /// Retrieves a list of folders matching the criteria. Only applicable to buckets with hierarchical namespace enabled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Folders> list(Folders_ListRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/folders', {
      if (request.delimiter case final $1?) 'delimiter': $1,
      if (request.endOffset case final $1?) 'endOffset': $1,
      if (request.pageSize case final $1?) 'pageSize': '${$1}',
      if (request.pageToken case final $1?) 'pageToken': $1,
      if (request.prefix case final $1?) 'prefix': $1,
      if (request.startOffset case final $1?) 'startOffset': $1,
    });
    final response = await _client.get(url);
    return Folders.fromJson(response);
  }

  /// Renames a source folder to a destination folder. Only applicable to buckets with hierarchical namespace enabled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GoogleLongrunningOperation> rename(
    Folders_RenameRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/folders/${request.sourceFolder}/renameTo/folders/${request.destinationFolder}',
      {
        if (request.ifSourceMetagenerationMatch case final $1?)
          'ifSourceMetagenerationMatch': '${$1}',
        if (request.ifSourceMetagenerationNotMatch case final $1?)
          'ifSourceMetagenerationNotMatch': '${$1}',
      },
    );
    final response = await _client.post(url);
    return GoogleLongrunningOperation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `hmacKeys` resource.
final class hmacKeys {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `hmacKeys` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `hmacKeys`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  hmacKeys({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `hmacKeys` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory hmacKeys.fromApiKey([String? apiKey]) =>
      hmacKeys(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a new HMAC key for the specified service account.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HmacKey> create(HmacKeys_CreateRequest request) async {
    final url =
        Uri.https(_host, '/storage/v1/projects/${request.projectId}/hmacKeys', {
          if (request.serviceAccountEmail case final $1 when $1.isNotDefault)
            'serviceAccountEmail': $1,
          if (request.userProject case final $1?) 'userProject': $1,
        });
    final response = await _client.post(url);
    return HmacKey.fromJson(response);
  }

  /// Deletes an HMAC key.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(HmacKeys_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/projects/${request.projectId}/hmacKeys/${request.accessId}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    await _client.delete(url);
  }

  /// Retrieves an HMAC key's metadata
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HmacKeyMetadata> get(HmacKeys_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/projects/${request.projectId}/hmacKeys/${request.accessId}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.get(url);
    return HmacKeyMetadata.fromJson(response);
  }

  /// Retrieves a list of HMAC keys matching the criteria.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HmacKeysMetadata> list(HmacKeys_ListRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/projects/${request.projectId}/hmacKeys',
      {
        if (request.maxResults case final $1?) 'maxResults': '${$1}',
        if (request.pageToken case final $1?) 'pageToken': $1,
        if (request.serviceAccountEmail case final $1?)
          'serviceAccountEmail': $1,
        if (request.showDeletedKeys case final $1?) 'showDeletedKeys': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return HmacKeysMetadata.fromJson(response);
  }

  /// Updates the state of an HMAC key. See the [HMAC Key resource descriptor](https://cloud.google.com/storage/docs/json_api/v1/projects/hmacKeys/update#request-body) for valid states.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HmacKeyMetadata> update(HmacKeys_UpdateRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/projects/${request.projectId}/hmacKeys/${request.accessId}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.put(url, body: request.body);
    return HmacKeyMetadata.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `managedFolders` resource.
final class managedFolders {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `managedFolders` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `managedFolders`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  managedFolders({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `managedFolders` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory managedFolders.fromApiKey([String? apiKey]) =>
      managedFolders(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Permanently deletes a managed folder.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(ManagedFolders_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/managedFolders/${request.managedFolder}',
      {
        if (request.allowNonEmpty case final $1?) 'allowNonEmpty': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
      },
    );
    await _client.delete(url);
  }

  /// Returns metadata of the specified managed folder.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ManagedFolder> get(ManagedFolders_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/managedFolders/${request.managedFolder}',
      {
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
      },
    );
    final response = await _client.get(url);
    return ManagedFolder.fromJson(response);
  }

  /// Returns an IAM policy for the specified managed folder.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(
    ManagedFolders_GetIamPolicyRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/managedFolders/${request.managedFolder}/iam',
      {
        if (request.optionsRequestedPolicyVersion case final $1?)
          'optionsRequestedPolicyVersion': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Creates a new managed folder.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ManagedFolder> insert(ManagedFolders_InsertRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/managedFolders',
    );
    final response = await _client.post(url, body: request.body);
    return ManagedFolder.fromJson(response);
  }

  /// Lists managed folders in the given bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ManagedFolders> list(ManagedFolders_ListRequest request) async {
    final url =
        Uri.https(_host, '/storage/v1/b/${request.bucket}/managedFolders', {
          if (request.pageSize case final $1?) 'pageSize': '${$1}',
          if (request.pageToken case final $1?) 'pageToken': $1,
          if (request.prefix case final $1?) 'prefix': $1,
        });
    final response = await _client.get(url);
    return ManagedFolders.fromJson(response);
  }

  /// Updates an IAM policy for the specified managed folder.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(
    ManagedFolders_SetIamPolicyRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/managedFolders/${request.managedFolder}/iam',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.put(url, body: request.body);
    return Policy.fromJson(response);
  }

  /// Tests a set of permissions on the given managed folder to see which, if any, are held by the caller.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    ManagedFolders_TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/managedFolders/${request.managedFolder}/iam/testPermissions',
      {
        if (request.permissions case final $1 when $1.isNotDefault)
          'permissions': $1,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `notifications` resource.
final class notifications {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `notifications` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `notifications`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  notifications({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `notifications` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory notifications.fromApiKey([String? apiKey]) =>
      notifications(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Permanently deletes a notification subscription.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(Notifications_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/notificationConfigs/${request.notification}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    await _client.delete(url);
  }

  /// View a notification configuration.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Notification> get(Notifications_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/notificationConfigs/${request.notification}',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.get(url);
    return Notification.fromJson(response);
  }

  /// Creates a notification subscription for a given bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Notification> insert(Notifications_InsertRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/notificationConfigs',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.post(url, body: request.body);
    return Notification.fromJson(response);
  }

  /// Retrieves a list of notification subscriptions for a given bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Notifications> list(Notifications_ListRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/notificationConfigs',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.get(url);
    return Notifications.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `objectAccessControls` resource.
final class objectAccessControls {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `objectAccessControls` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `objectAccessControls`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  objectAccessControls({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `objectAccessControls` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory objectAccessControls.fromApiKey([String? apiKey]) =>
      objectAccessControls(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Permanently deletes the ACL entry for the specified entity on the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(ObjectAccessControls_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/acl/${request.entity}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    await _client.delete(url);
  }

  /// Returns the ACL entry for the specified entity on the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> get(
    ObjectAccessControls_GetRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/acl/${request.entity}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return ObjectAccessControl.fromJson(response);
  }

  /// Creates a new ACL entry on the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> insert(
    ObjectAccessControls_InsertRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/acl',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.post(url, body: request.body);
    return ObjectAccessControl.fromJson(response);
  }

  /// Retrieves ACL entries on the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControls> list(
    ObjectAccessControls_ListRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/acl',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return ObjectAccessControls.fromJson(response);
  }

  /// Patches an ACL entry on the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> patch(
    ObjectAccessControls_PatchRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/acl/${request.entity}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.patch(url, body: request.body);
    return ObjectAccessControl.fromJson(response);
  }

  /// Updates an ACL entry on the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ObjectAccessControl> update(
    ObjectAccessControls_UpdateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/acl/${request.entity}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.put(url, body: request.body);
    return ObjectAccessControl.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `objects` resource.
final class objects {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `objects` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `objects`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  objects({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `objects` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory objects.fromApiKey([String? apiKey]) =>
      objects(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Initiates a long-running bulk restore operation on the specified bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GoogleLongrunningOperation> bulkRestore(
    Objects_BulkRestoreRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/bulkRestore',
    );
    final response = await _client.post(url, body: request.body);
    return GoogleLongrunningOperation.fromJson(response);
  }

  /// Concatenates a list of existing objects into a new object in the same bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Object$> compose(Objects_ComposeRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.destinationBucket}/o/${request.destinationObject}/compose',
      {
        if (request.destinationPredefinedAcl case final $1?)
          'destinationPredefinedAcl': $1.value,
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.kmsKeyName case final $1?) 'kmsKeyName': $1,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.post(url, body: request.body);
    return Object$.fromJson(response);
  }

  /// Copies a source object to a destination object. Optionally overrides metadata.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Object$> copy(Objects_CopyRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.sourceBucket}/o/${request.sourceObject}/copyTo/b/${request.destinationBucket}/o/${request.destinationObject}',
      {
        if (request.destinationKmsKeyName case final $1?)
          'destinationKmsKeyName': $1,
        if (request.destinationPredefinedAcl case final $1?)
          'destinationPredefinedAcl': $1.value,
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.ifSourceGenerationMatch case final $1?)
          'ifSourceGenerationMatch': '${$1}',
        if (request.ifSourceGenerationNotMatch case final $1?)
          'ifSourceGenerationNotMatch': '${$1}',
        if (request.ifSourceMetagenerationMatch case final $1?)
          'ifSourceMetagenerationMatch': '${$1}',
        if (request.ifSourceMetagenerationNotMatch case final $1?)
          'ifSourceMetagenerationNotMatch': '${$1}',
        if (request.projection case final $1?) 'projection': $1.value,
        if (request.sourceGeneration case final $1?)
          'sourceGeneration': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.post(url, body: request.body);
    return Object$.fromJson(response);
  }

  /// Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> delete(Objects_DeleteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    await _client.delete(url);
  }

  /// Retrieves an object or its metadata.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Object$> get(Objects_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.projection case final $1?) 'projection': $1.value,
        if (request.restoreToken case final $1?) 'restoreToken': $1,
        if (request.softDeleted case final $1?) 'softDeleted': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return Object$.fromJson(response);
  }

  /// Returns an IAM policy for the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(Objects_GetIamPolicyRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/iam',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Retrieves a list of objects matching the criteria.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Objects> list(Objects_ListRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/o', {
      if (request.delimiter case final $1?) 'delimiter': $1,
      if (request.endOffset case final $1?) 'endOffset': $1,
      if (request.filter case final $1?) 'filter': $1,
      if (request.includeFoldersAsPrefixes case final $1?)
        'includeFoldersAsPrefixes': '${$1}',
      if (request.includeTrailingDelimiter case final $1?)
        'includeTrailingDelimiter': '${$1}',
      if (request.matchGlob case final $1?) 'matchGlob': $1,
      if (request.maxResults case final $1?) 'maxResults': '${$1}',
      if (request.pageToken case final $1?) 'pageToken': $1,
      if (request.prefix case final $1?) 'prefix': $1,
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.softDeleted case final $1?) 'softDeleted': '${$1}',
      if (request.startOffset case final $1?) 'startOffset': $1,
      if (request.userProject case final $1?) 'userProject': $1,
      if (request.versions case final $1?) 'versions': '${$1}',
    });
    final response = await _client.get(url);
    return Objects.fromJson(response);
  }

  /// Moves the source object to the destination object in the same bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Object$> move(Objects_MoveRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.sourceObject}/moveTo/o/${request.destinationObject}',
      {
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.ifSourceGenerationMatch case final $1?)
          'ifSourceGenerationMatch': '${$1}',
        if (request.ifSourceGenerationNotMatch case final $1?)
          'ifSourceGenerationNotMatch': '${$1}',
        if (request.ifSourceMetagenerationMatch case final $1?)
          'ifSourceMetagenerationMatch': '${$1}',
        if (request.ifSourceMetagenerationNotMatch case final $1?)
          'ifSourceMetagenerationNotMatch': '${$1}',
        if (request.projection case final $1?) 'projection': $1.value,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.post(url);
    return Object$.fromJson(response);
  }

  /// Patches an object's metadata.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Object$> patch(Objects_PatchRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.overrideUnlockedRetention case final $1?)
          'overrideUnlockedRetention': '${$1}',
        if (request.predefinedAcl case final $1?) 'predefinedAcl': $1.value,
        if (request.projection case final $1?) 'projection': $1.value,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.patch(url, body: request.body);
    return Object$.fromJson(response);
  }

  /// Restores a soft-deleted object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Object$> restore(Objects_RestoreRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/restore',
      {
        if (request.copySourceAcl case final $1?) 'copySourceAcl': '${$1}',
        if (request.generation case final $1 when $1.isNotDefault)
          'generation': '${$1}',
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.projection case final $1?) 'projection': $1.value,
        if (request.restoreToken case final $1?) 'restoreToken': $1,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.post(url);
    return Object$.fromJson(response);
  }

  /// Rewrites a source object to a destination object. Optionally overrides metadata.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RewriteResponse> rewrite(Objects_RewriteRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.sourceBucket}/o/${request.sourceObject}/rewriteTo/b/${request.destinationBucket}/o/${request.destinationObject}',
      {
        if (request.destinationKmsKeyName case final $1?)
          'destinationKmsKeyName': $1,
        if (request.destinationPredefinedAcl case final $1?)
          'destinationPredefinedAcl': $1.value,
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.ifSourceGenerationMatch case final $1?)
          'ifSourceGenerationMatch': '${$1}',
        if (request.ifSourceGenerationNotMatch case final $1?)
          'ifSourceGenerationNotMatch': '${$1}',
        if (request.ifSourceMetagenerationMatch case final $1?)
          'ifSourceMetagenerationMatch': '${$1}',
        if (request.ifSourceMetagenerationNotMatch case final $1?)
          'ifSourceMetagenerationNotMatch': '${$1}',
        if (request.maxBytesRewrittenPerCall case final $1?)
          'maxBytesRewrittenPerCall': '${$1}',
        if (request.projection case final $1?) 'projection': $1.value,
        if (request.rewriteToken case final $1?) 'rewriteToken': $1,
        if (request.sourceGeneration case final $1?)
          'sourceGeneration': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.post(url, body: request.body);
    return RewriteResponse.fromJson(response);
  }

  /// Updates an IAM policy for the specified object.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(Objects_SetIamPolicyRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/iam',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.put(url, body: request.body);
    return Policy.fromJson(response);
  }

  /// Tests a set of permissions on the given object to see which, if any, are held by the caller.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    Objects_TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}/iam/testPermissions',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.permissions case final $1 when $1.isNotDefault)
          'permissions': $1,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.get(url);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Updates an object's metadata.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Object$> update(Objects_UpdateRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/o/${request.object}',
      {
        if (request.generation case final $1?) 'generation': '${$1}',
        if (request.ifGenerationMatch case final $1?)
          'ifGenerationMatch': '${$1}',
        if (request.ifGenerationNotMatch case final $1?)
          'ifGenerationNotMatch': '${$1}',
        if (request.ifMetagenerationMatch case final $1?)
          'ifMetagenerationMatch': '${$1}',
        if (request.ifMetagenerationNotMatch case final $1?)
          'ifMetagenerationNotMatch': '${$1}',
        if (request.overrideUnlockedRetention case final $1?)
          'overrideUnlockedRetention': '${$1}',
        if (request.predefinedAcl case final $1?) 'predefinedAcl': $1.value,
        if (request.projection case final $1?) 'projection': $1.value,
        if (request.userProject case final $1?) 'userProject': $1,
      },
    );
    final response = await _client.put(url, body: request.body);
    return Object$.fromJson(response);
  }

  /// Watch for changes on all objects in a bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Channel> watchAll(Objects_WatchAllRequest request) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/o/watch', {
      if (request.delimiter case final $1?) 'delimiter': $1,
      if (request.endOffset case final $1?) 'endOffset': $1,
      if (request.includeTrailingDelimiter case final $1?)
        'includeTrailingDelimiter': '${$1}',
      if (request.maxResults case final $1?) 'maxResults': '${$1}',
      if (request.pageToken case final $1?) 'pageToken': $1,
      if (request.prefix case final $1?) 'prefix': $1,
      if (request.projection case final $1?) 'projection': $1.value,
      if (request.startOffset case final $1?) 'startOffset': $1,
      if (request.userProject case final $1?) 'userProject': $1,
      if (request.versions case final $1?) 'versions': '${$1}',
    });
    final response = await _client.post(url, body: request.body);
    return Channel.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `operations` resource.
final class operations {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `operations` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `operations`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  operations({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `operations` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory operations.fromApiKey([String? apiKey]) =>
      operations(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Starts asynchronous advancement of the relocate bucket operation in the case of required write downtime, to allow it to lock the bucket at the source location, and proceed with the bucket location swap. The server makes a best effort to advance the relocate bucket operation, but success is not guaranteed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> advanceRelocateBucket(
    Operations_AdvanceRelocateBucketRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/operations/${request.operationId}/advanceRelocateBucket',
    );
    await _client.post(url, body: request.body);
  }

  /// Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancel(Operations_CancelRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/operations/${request.operationId}/cancel',
    );
    await _client.post(url);
  }

  /// Gets the latest state of a long-running operation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GoogleLongrunningOperation> get(Operations_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/b/${request.bucket}/operations/${request.operationId}',
    );
    final response = await _client.get(url);
    return GoogleLongrunningOperation.fromJson(response);
  }

  /// Lists operations that match the specified filter in the request.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GoogleLongrunningListOperationsResponse> list(
    Operations_ListRequest request,
  ) async {
    final url = Uri.https(_host, '/storage/v1/b/${request.bucket}/operations', {
      if (request.filter case final $1?) 'filter': $1,
      if (request.pageSize case final $1?) 'pageSize': '${$1}',
      if (request.pageToken case final $1?) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return GoogleLongrunningListOperationsResponse.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for the `serviceAccount` resource.
final class serviceAccount {
  static const _host = 'storage.googleapis.com';

  final ServiceClient _client;

  /// Creates a `serviceAccount` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `serviceAccount`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  serviceAccount({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `serviceAccount` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory serviceAccount.fromApiKey([String? apiKey]) =>
      serviceAccount(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Get the email address of this project's Google Cloud Storage service account.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ServiceAccount> get(ServiceAccount_GetRequest request) async {
    final url = Uri.https(
      _host,
      '/storage/v1/projects/${request.projectId}/serviceAccount',
      {if (request.userProject case final $1?) 'userProject': $1},
    );
    final response = await _client.get(url);
    return ServiceAccount.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// An AdvanceRelocateBucketOperation request.
final class AdvanceRelocateBucketOperationRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.AdvanceRelocateBucketOperationRequest';

  /// Specifies the time when the relocation will revert to the sync stage if the relocation hasn't succeeded.
  final Timestamp? expireTime;

  /// Specifies the duration after which the relocation will revert to the sync stage if the relocation hasn't succeeded. Optional, if not supplied, a default value of 12h will be used.
  final Duration? ttl;

  AdvanceRelocateBucketOperationRequest({this.expireTime, this.ttl})
    : super(fullyQualifiedName);

  factory AdvanceRelocateBucketOperationRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AdvanceRelocateBucketOperationRequest(
      expireTime: switch (json['expireTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      ttl: switch (json['ttl']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (expireTime != null) 'expireTime': expireTime!.toJson(),
    if (ttl != null) 'ttl': ttl!.toJson(),
  };

  @override
  String toString() => 'AdvanceRelocateBucketOperationRequest()';
}

/// An Anywhere Cache instance.
final class AnywhereCache extends ProtoMessage {
  static const String fullyQualifiedName = '.AnywhereCache';

  /// The cache-level entry admission policy.
  final String? admissionPolicy;

  /// The ID of the Anywhere cache instance.
  final String? anywhereCacheId;

  /// The name of the bucket containing this cache instance.
  final String? bucket;

  /// The creation time of the cache instance in RFC 3339 format.
  final Timestamp? createTime;

  /// The ID of the resource, including the project number, bucket name and anywhere cache ID.
  final String? id;

  /// The kind of item this is. For Anywhere Cache, this is always storage#anywhereCache.
  final String? kind;

  /// True if the cache instance has an active Update long-running operation.
  final bool? pendingUpdate;

  /// The link to this cache instance.
  final String? selfLink;

  /// The current state of the cache instance.
  final String? state;

  /// The TTL of all cache entries in whole seconds. e.g., "7200s".
  final Duration? ttl;

  /// The modification time of the cache instance metadata in RFC 3339 format.
  final Timestamp? updateTime;

  /// The zone in which the cache instance is running. For example, us-central1-a.
  final String? zone;

  AnywhereCache({
    this.admissionPolicy,
    this.anywhereCacheId,
    this.bucket,
    this.createTime,
    this.id,
    this.kind,
    this.pendingUpdate,
    this.selfLink,
    this.state,
    this.ttl,
    this.updateTime,
    this.zone,
  }) : super(fullyQualifiedName);

  factory AnywhereCache.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCache(
      admissionPolicy: switch (json['admissionPolicy']) {
        null => null,
        Object $1 => decodeString($1),
      },
      anywhereCacheId: switch (json['anywhereCacheId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      bucket: switch (json['bucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      pendingUpdate: switch (json['pendingUpdate']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => null,
        Object $1 => decodeString($1),
      },
      ttl: switch (json['ttl']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      zone: switch (json['zone']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (admissionPolicy != null) 'admissionPolicy': admissionPolicy,
    if (anywhereCacheId != null) 'anywhereCacheId': anywhereCacheId,
    if (bucket != null) 'bucket': bucket,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (pendingUpdate != null) 'pendingUpdate': pendingUpdate,
    if (selfLink != null) 'selfLink': selfLink,
    if (state != null) 'state': state,
    if (ttl != null) 'ttl': ttl!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (zone != null) 'zone': zone,
  };

  @override
  String toString() {
    final contents = [
      if (admissionPolicy != null) 'admissionPolicy=$admissionPolicy',
      if (anywhereCacheId != null) 'anywhereCacheId=$anywhereCacheId',
      if (bucket != null) 'bucket=$bucket',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (pendingUpdate != null) 'pendingUpdate=$pendingUpdate',
      if (selfLink != null) 'selfLink=$selfLink',
      if (state != null) 'state=$state',
      if (zone != null) 'zone=$zone',
    ].join(',');
    return 'AnywhereCache($contents)';
  }
}

/// A list of Anywhere Caches.
final class AnywhereCaches extends ProtoMessage {
  static const String fullyQualifiedName = '.AnywhereCaches';

  /// The list of items.
  final List<AnywhereCache> items;

  /// The kind of item this is. For lists of Anywhere Caches, this is always storage#anywhereCaches.
  final String? kind;

  /// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
  final String? nextPageToken;

  AnywhereCaches({this.items = const [], this.kind, this.nextPageToken})
    : super(fullyQualifiedName);

  factory AnywhereCaches.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) AnywhereCache.fromJson(i)],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
    if (nextPageToken != null) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'AnywhereCaches($contents)';
  }
}

/// A bucket.
final class Bucket extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket';

  /// Access controls on the bucket.
  final List<BucketAccessControl> acl;

  /// The bucket's Autoclass configuration.
  final Bucket_Autoclass? autoclass;

  /// The bucket's billing configuration.
  final Bucket_Billing? billing;

  /// The bucket's Cross-Origin Resource Sharing (CORS) configuration.
  final List<Bucket_Cors> cors;

  /// The bucket's custom placement configuration for Custom Dual Regions.
  final Bucket_CustomPlacementConfig? customPlacementConfig;

  /// The default value for event-based hold on newly created objects in this bucket. Event-based hold is a way to retain objects indefinitely until an event occurs, signified by the hold's release. After being released, such objects will be subject to bucket-level retention (if any). One sample use case of this flag is for banks to hold loan documents for at least 3 years after loan is paid in full. Here, bucket-level retention is 3 years and the event is loan being paid in full. In this example, these objects will be held intact for any number of years until the event has occurred (event-based hold on the object is released) and then 3 more years after that. That means retention duration of the objects begins from the moment event-based hold transitioned from true to false. Objects under event-based hold cannot be deleted, overwritten or archived until the hold is removed.
  final bool? defaultEventBasedHold;

  /// Default access controls to apply to new objects when no ACL is provided.
  final List<ObjectAccessControl> defaultObjectAcl;

  /// Encryption configuration for a bucket.
  final Bucket_Encryption? encryption;

  /// HTTP 1.1 Entity tag for the bucket.
  final String? etag;

  /// The generation of this bucket.
  final int? generation;

  /// The hard delete time of the bucket in RFC 3339 format.
  final Timestamp? hardDeleteTime;

  /// The bucket's hierarchical namespace configuration.
  final Bucket_HierarchicalNamespace? hierarchicalNamespace;

  /// The bucket's IAM configuration.
  final Bucket_IamConfiguration? iamConfiguration;

  /// The ID of the bucket. For buckets, the id and name properties are the same.
  final String? id;

  /// The bucket's IP filter configuration. Specifies the network sources that are allowed to access the operations on the bucket, as well as its underlying objects. Only enforced when the mode is set to 'Enabled'.
  final Bucket_IpFilter? ipFilter;

  /// The kind of item this is. For buckets, this is always storage#bucket.
  final String? kind;

  /// User-provided labels, in key/value pairs.
  final Map<String, String> labels;

  /// The bucket's lifecycle configuration. See [Lifecycle Management](https://cloud.google.com/storage/docs/lifecycle) for more information.
  final Bucket_Lifecycle? lifecycle;

  /// The location of the bucket. Object data for objects in the bucket resides in physical storage within this region. Defaults to US. See the [Developer's Guide](https://cloud.google.com/storage/docs/locations) for the authoritative list.
  final String? location;

  /// The type of the bucket location.
  final String? locationType;

  /// The bucket's logging configuration, which defines the destination bucket and optional name prefix for the current bucket's logs.
  final Bucket_Logging? logging;

  /// The metadata generation of this bucket.
  final int? metageneration;

  /// The name of the bucket.
  final String? name;

  /// The bucket's object retention config.
  final Bucket_ObjectRetention? objectRetention;

  /// The owner of the bucket. This is always the project team's owner group.
  final Bucket_Owner? owner;

  /// The project number of the project the bucket belongs to.
  final BigInt? projectNumber;

  /// The bucket's retention policy. The retention policy enforces a minimum retention time for all objects contained in the bucket, based on their creation time. Any attempt to overwrite or delete objects younger than the retention period will result in a PERMISSION_DENIED error. An unlocked retention policy can be modified or removed from the bucket via a storage.buckets.update operation. A locked retention policy cannot be removed or shortened in duration for the lifetime of the bucket. Attempting to remove or decrease period of a locked retention policy will result in a PERMISSION_DENIED error.
  final Bucket_RetentionPolicy? retentionPolicy;

  /// The Recovery Point Objective (RPO) of this bucket. Set to ASYNC_TURBO to turn on Turbo Replication on a bucket.
  final String? rpo;

  /// Reserved for future use.
  final bool? satisfiesPzi;

  /// Reserved for future use.
  final bool? satisfiesPzs;

  /// The URI of this bucket.
  final String? selfLink;

  /// The bucket's soft delete policy, which defines the period of time that soft-deleted objects will be retained, and cannot be permanently deleted.
  final Bucket_SoftDeletePolicy? softDeletePolicy;

  /// The soft delete time of the bucket in RFC 3339 format.
  final Timestamp? softDeleteTime;

  /// The bucket's default storage class, used whenever no storageClass is specified for a newly-created object. This defines how objects in the bucket are stored and determines the SLA and the cost of storage. Values include MULTI_REGIONAL, REGIONAL, STANDARD, NEARLINE, COLDLINE, ARCHIVE, and DURABLE_REDUCED_AVAILABILITY. If this value is not specified when the bucket is created, it will default to STANDARD. For more information, see [Storage Classes](https://cloud.google.com/storage/docs/storage-classes).
  final String? storageClass;

  /// The creation time of the bucket in RFC 3339 format.
  final Timestamp? timeCreated;

  /// The modification time of the bucket in RFC 3339 format.
  final Timestamp? updated;

  /// The bucket's versioning configuration.
  final Bucket_Versioning? versioning;

  /// The bucket's website configuration, controlling how the service behaves when accessing bucket contents as a web site. See the [Static Website Examples](https://cloud.google.com/storage/docs/static-website) for more information.
  final Bucket_Website? website;

  Bucket({
    this.acl = const [],
    this.autoclass,
    this.billing,
    this.cors = const [],
    this.customPlacementConfig,
    this.defaultEventBasedHold,
    this.defaultObjectAcl = const [],
    this.encryption,
    this.etag,
    this.generation,
    this.hardDeleteTime,
    this.hierarchicalNamespace,
    this.iamConfiguration,
    this.id,
    this.ipFilter,
    this.kind,
    this.labels = const {},
    this.lifecycle,
    this.location,
    this.locationType,
    this.logging,
    this.metageneration,
    this.name,
    this.objectRetention,
    this.owner,
    this.projectNumber,
    this.retentionPolicy,
    this.rpo,
    this.satisfiesPzi,
    this.satisfiesPzs,
    this.selfLink,
    this.softDeletePolicy,
    this.softDeleteTime,
    this.storageClass,
    this.timeCreated,
    this.updated,
    this.versioning,
    this.website,
  }) : super(fullyQualifiedName);

  factory Bucket.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket(
      acl: switch (json['acl']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) BucketAccessControl.fromJson(i),
        ],
        _ => throw const FormatException('"acl" is not a list'),
      },
      autoclass: switch (json['autoclass']) {
        null => null,
        Object $1 => Bucket_Autoclass.fromJson($1),
      },
      billing: switch (json['billing']) {
        null => null,
        Object $1 => Bucket_Billing.fromJson($1),
      },
      cors: switch (json['cors']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Bucket_Cors.fromJson(i)],
        _ => throw const FormatException('"cors" is not a list'),
      },
      customPlacementConfig: switch (json['customPlacementConfig']) {
        null => null,
        Object $1 => Bucket_CustomPlacementConfig.fromJson($1),
      },
      defaultEventBasedHold: switch (json['defaultEventBasedHold']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      defaultObjectAcl: switch (json['defaultObjectAcl']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ObjectAccessControl.fromJson(i),
        ],
        _ => throw const FormatException('"defaultObjectAcl" is not a list'),
      },
      encryption: switch (json['encryption']) {
        null => null,
        Object $1 => Bucket_Encryption.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => null,
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      hardDeleteTime: switch (json['hardDeleteTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      hierarchicalNamespace: switch (json['hierarchicalNamespace']) {
        null => null,
        Object $1 => Bucket_HierarchicalNamespace.fromJson($1),
      },
      iamConfiguration: switch (json['iamConfiguration']) {
        null => null,
        Object $1 => Bucket_IamConfiguration.fromJson($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      ipFilter: switch (json['ipFilter']) {
        null => null,
        Object $1 => Bucket_IpFilter.fromJson($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      lifecycle: switch (json['lifecycle']) {
        null => null,
        Object $1 => Bucket_Lifecycle.fromJson($1),
      },
      location: switch (json['location']) {
        null => null,
        Object $1 => decodeString($1),
      },
      locationType: switch (json['locationType']) {
        null => null,
        Object $1 => decodeString($1),
      },
      logging: switch (json['logging']) {
        null => null,
        Object $1 => Bucket_Logging.fromJson($1),
      },
      metageneration: switch (json['metageneration']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      name: switch (json['name']) {
        null => null,
        Object $1 => decodeString($1),
      },
      objectRetention: switch (json['objectRetention']) {
        null => null,
        Object $1 => Bucket_ObjectRetention.fromJson($1),
      },
      owner: switch (json['owner']) {
        null => null,
        Object $1 => Bucket_Owner.fromJson($1),
      },
      projectNumber: switch (json['projectNumber']) {
        null => null,
        Object $1 => decodeUint64($1),
      },
      retentionPolicy: switch (json['retentionPolicy']) {
        null => null,
        Object $1 => Bucket_RetentionPolicy.fromJson($1),
      },
      rpo: switch (json['rpo']) {
        null => null,
        Object $1 => decodeString($1),
      },
      satisfiesPzi: switch (json['satisfiesPZI']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      satisfiesPzs: switch (json['satisfiesPZS']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      softDeletePolicy: switch (json['softDeletePolicy']) {
        null => null,
        Object $1 => Bucket_SoftDeletePolicy.fromJson($1),
      },
      softDeleteTime: switch (json['softDeleteTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      storageClass: switch (json['storageClass']) {
        null => null,
        Object $1 => decodeString($1),
      },
      timeCreated: switch (json['timeCreated']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      updated: switch (json['updated']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      versioning: switch (json['versioning']) {
        null => null,
        Object $1 => Bucket_Versioning.fromJson($1),
      },
      website: switch (json['website']) {
        null => null,
        Object $1 => Bucket_Website.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (acl.isNotDefault) 'acl': encodeList(acl),
    if (autoclass != null) 'autoclass': autoclass!.toJson(),
    if (billing != null) 'billing': billing!.toJson(),
    if (cors.isNotDefault) 'cors': encodeList(cors),
    if (customPlacementConfig != null)
      'customPlacementConfig': customPlacementConfig!.toJson(),
    if (defaultEventBasedHold != null)
      'defaultEventBasedHold': defaultEventBasedHold,
    if (defaultObjectAcl.isNotDefault)
      'defaultObjectAcl': encodeList(defaultObjectAcl),
    if (encryption != null) 'encryption': encryption!.toJson(),
    if (etag != null) 'etag': etag,
    if (generation != null) 'generation': encodeInt64(generation),
    if (hardDeleteTime != null) 'hardDeleteTime': hardDeleteTime!.toJson(),
    if (hierarchicalNamespace != null)
      'hierarchicalNamespace': hierarchicalNamespace!.toJson(),
    if (iamConfiguration != null)
      'iamConfiguration': iamConfiguration!.toJson(),
    if (id != null) 'id': id,
    if (ipFilter != null) 'ipFilter': ipFilter!.toJson(),
    if (kind != null) 'kind': kind,
    if (labels.isNotDefault) 'labels': labels,
    if (lifecycle != null) 'lifecycle': lifecycle!.toJson(),
    if (location != null) 'location': location,
    if (locationType != null) 'locationType': locationType,
    if (logging != null) 'logging': logging!.toJson(),
    if (metageneration != null) 'metageneration': encodeInt64(metageneration),
    if (name != null) 'name': name,
    if (objectRetention != null) 'objectRetention': objectRetention!.toJson(),
    if (owner != null) 'owner': owner!.toJson(),
    if (projectNumber != null) 'projectNumber': encodeUint64(projectNumber),
    if (retentionPolicy != null) 'retentionPolicy': retentionPolicy!.toJson(),
    if (rpo != null) 'rpo': rpo,
    if (satisfiesPzi != null) 'satisfiesPZI': satisfiesPzi,
    if (satisfiesPzs != null) 'satisfiesPZS': satisfiesPzs,
    if (selfLink != null) 'selfLink': selfLink,
    if (softDeletePolicy != null)
      'softDeletePolicy': softDeletePolicy!.toJson(),
    if (softDeleteTime != null) 'softDeleteTime': softDeleteTime!.toJson(),
    if (storageClass != null) 'storageClass': storageClass,
    if (timeCreated != null) 'timeCreated': timeCreated!.toJson(),
    if (updated != null) 'updated': updated!.toJson(),
    if (versioning != null) 'versioning': versioning!.toJson(),
    if (website != null) 'website': website!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (defaultEventBasedHold != null)
        'defaultEventBasedHold=$defaultEventBasedHold',
      if (etag != null) 'etag=$etag',
      if (generation != null) 'generation=$generation',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (location != null) 'location=$location',
      if (locationType != null) 'locationType=$locationType',
      if (metageneration != null) 'metageneration=$metageneration',
      if (name != null) 'name=$name',
      if (projectNumber != null) 'projectNumber=$projectNumber',
      if (rpo != null) 'rpo=$rpo',
      if (satisfiesPzi != null) 'satisfiesPZI=$satisfiesPzi',
      if (satisfiesPzs != null) 'satisfiesPZS=$satisfiesPzs',
      if (selfLink != null) 'selfLink=$selfLink',
      if (storageClass != null) 'storageClass=$storageClass',
    ].join(',');
    return 'Bucket($contents)';
  }
}

/// The message type for the `autoclass` field.
final class Bucket_Autoclass extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.autoclass';

  /// Whether or not Autoclass is enabled on this bucket
  final bool? enabled;

  /// The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Valid values are NEARLINE and ARCHIVE.
  final String? terminalStorageClass;

  /// A date and time in RFC 3339 format representing the time of the most recent update to "terminalStorageClass".
  final Timestamp? terminalStorageClassUpdateTime;

  /// A date and time in RFC 3339 format representing the instant at which "enabled" was last toggled.
  final Timestamp? toggleTime;

  Bucket_Autoclass({
    this.enabled,
    this.terminalStorageClass,
    this.terminalStorageClassUpdateTime,
    this.toggleTime,
  }) : super(fullyQualifiedName);

  factory Bucket_Autoclass.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Autoclass(
      enabled: switch (json['enabled']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      terminalStorageClass: switch (json['terminalStorageClass']) {
        null => null,
        Object $1 => decodeString($1),
      },
      terminalStorageClassUpdateTime:
          switch (json['terminalStorageClassUpdateTime']) {
            null => null,
            Object $1 => Timestamp.fromJson($1),
          },
      toggleTime: switch (json['toggleTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enabled != null) 'enabled': enabled,
    if (terminalStorageClass != null)
      'terminalStorageClass': terminalStorageClass,
    if (terminalStorageClassUpdateTime != null)
      'terminalStorageClassUpdateTime': terminalStorageClassUpdateTime!
          .toJson(),
    if (toggleTime != null) 'toggleTime': toggleTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (enabled != null) 'enabled=$enabled',
      if (terminalStorageClass != null)
        'terminalStorageClass=$terminalStorageClass',
    ].join(',');
    return 'autoclass($contents)';
  }
}

/// The message type for the `billing` field.
final class Bucket_Billing extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.billing';

  /// When set to true, Requester Pays is enabled for this bucket.
  final bool? requesterPays;

  Bucket_Billing({this.requesterPays}) : super(fullyQualifiedName);

  factory Bucket_Billing.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Billing(
      requesterPays: switch (json['requesterPays']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (requesterPays != null) 'requesterPays': requesterPays,
  };

  @override
  String toString() {
    final contents = [
      if (requesterPays != null) 'requesterPays=$requesterPays',
    ].join(',');
    return 'billing($contents)';
  }
}

/// The message type for the `cors` field.
final class Bucket_Cors extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.cors';

  /// The value, in seconds, to return in the  Access-Control-Max-Age header used in preflight responses.
  final int? maxAgeSeconds;

  /// The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
  final List<String> method;

  /// The list of Origins eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
  final List<String> origin;

  /// The list of HTTP headers other than the simple response headers to give permission for the user-agent to share across domains.
  final List<String> responseHeader;

  Bucket_Cors({
    this.maxAgeSeconds,
    this.method = const [],
    this.origin = const [],
    this.responseHeader = const [],
  }) : super(fullyQualifiedName);

  factory Bucket_Cors.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Cors(
      maxAgeSeconds: switch (json['maxAgeSeconds']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      method: switch (json['method']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"method" is not a list'),
      },
      origin: switch (json['origin']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"origin" is not a list'),
      },
      responseHeader: switch (json['responseHeader']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"responseHeader" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxAgeSeconds != null) 'maxAgeSeconds': maxAgeSeconds,
    if (method.isNotDefault) 'method': method,
    if (origin.isNotDefault) 'origin': origin,
    if (responseHeader.isNotDefault) 'responseHeader': responseHeader,
  };

  @override
  String toString() {
    final contents = [
      if (maxAgeSeconds != null) 'maxAgeSeconds=$maxAgeSeconds',
    ].join(',');
    return 'cors($contents)';
  }
}

/// The message type for the `customPlacementConfig` field.
final class Bucket_CustomPlacementConfig extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.customPlacementConfig';

  /// The list of regional locations in which data is placed.
  final List<String> dataLocations;

  Bucket_CustomPlacementConfig({this.dataLocations = const []})
    : super(fullyQualifiedName);

  factory Bucket_CustomPlacementConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_CustomPlacementConfig(
      dataLocations: switch (json['dataLocations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"dataLocations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataLocations.isNotDefault) 'dataLocations': dataLocations,
  };

  @override
  String toString() => 'customPlacementConfig()';
}

/// The message type for the `encryption` field.
final class Bucket_Encryption extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.encryption';

  /// If set, the new objects created in this bucket must comply with this enforcement config. Changing this has no effect on existing objects; it applies to new objects only. If omitted, the new objects are allowed to be encrypted with Customer Managed Encryption type by default.
  final Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig?
  customerManagedEncryptionEnforcementConfig;

  /// If set, the new objects created in this bucket must comply with this enforcement config. Changing this has no effect on existing objects; it applies to new objects only. If omitted, the new objects are allowed to be encrypted with Customer Supplied Encryption type by default.
  final Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig?
  customerSuppliedEncryptionEnforcementConfig;

  /// A Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
  final String? defaultKmsKeyName;

  /// If set, the new objects created in this bucket must comply with this enforcement config. Changing this has no effect on existing objects; it applies to new objects only. If omitted, the new objects are allowed to be encrypted with Google Managed Encryption type by default.
  final Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig?
  googleManagedEncryptionEnforcementConfig;

  Bucket_Encryption({
    this.customerManagedEncryptionEnforcementConfig,
    this.customerSuppliedEncryptionEnforcementConfig,
    this.defaultKmsKeyName,
    this.googleManagedEncryptionEnforcementConfig,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Encryption(
      customerManagedEncryptionEnforcementConfig:
          switch (json['customerManagedEncryptionEnforcementConfig']) {
            null => null,
            Object $1 =>
              Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig.fromJson(
                $1,
              ),
          },
      customerSuppliedEncryptionEnforcementConfig:
          switch (json['customerSuppliedEncryptionEnforcementConfig']) {
            null => null,
            Object $1 =>
              Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig.fromJson(
                $1,
              ),
          },
      defaultKmsKeyName: switch (json['defaultKmsKeyName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      googleManagedEncryptionEnforcementConfig:
          switch (json['googleManagedEncryptionEnforcementConfig']) {
            null => null,
            Object $1 =>
              Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig.fromJson(
                $1,
              ),
          },
    );
  }

  @override
  Object toJson() => {
    if (customerManagedEncryptionEnforcementConfig != null)
      'customerManagedEncryptionEnforcementConfig':
          customerManagedEncryptionEnforcementConfig!.toJson(),
    if (customerSuppliedEncryptionEnforcementConfig != null)
      'customerSuppliedEncryptionEnforcementConfig':
          customerSuppliedEncryptionEnforcementConfig!.toJson(),
    if (defaultKmsKeyName != null) 'defaultKmsKeyName': defaultKmsKeyName,
    if (googleManagedEncryptionEnforcementConfig != null)
      'googleManagedEncryptionEnforcementConfig':
          googleManagedEncryptionEnforcementConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (defaultKmsKeyName != null) 'defaultKmsKeyName=$defaultKmsKeyName',
    ].join(',');
    return 'encryption($contents)';
  }
}

/// The message type for the `customerManagedEncryptionEnforcementConfig` field.
final class Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      '.Bucket.encryption.customerManagedEncryptionEnforcementConfig';

  /// Server-determined value that indicates the time from which configuration was enforced and effective. This value is in RFC 3339 format.
  final Timestamp? effectiveTime;

  /// Restriction mode for Customer-Managed Encryption Keys. Defaults to NotRestricted.
  final Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode?
  restrictionMode;

  Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig({
    this.effectiveTime,
    this.restrictionMode,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig(
      effectiveTime: switch (json['effectiveTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      restrictionMode: switch (json['restrictionMode']) {
        null => null,
        Object $1 =>
          Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    if (restrictionMode != null) 'restrictionMode': restrictionMode!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (restrictionMode != null) 'restrictionMode=$restrictionMode',
    ].join(',');
    return 'customerManagedEncryptionEnforcementConfig($contents)';
  }
}

/// The enumerated type for the `restrictionMode` field.
final class Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode
    extends ProtoEnum {
  /// Creation of new objects with Customer-Managed Encryption is not restricted.
  static const notRestricted =
      Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode(
        'NotRestricted',
      );

  /// Creation of new objects with Customer-Managed Encryption is fully restricted.
  static const fullyRestricted =
      Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode(
        'FullyRestricted',
      );

  /// The default value for [Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode].
  static const $default = notRestricted;

  const Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode(
    super.value,
  );

  factory Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode.fromJson(
    Object? json,
  ) =>
      Bucket_Encryption_CustomerManagedEncryptionEnforcementConfig_RestrictionMode(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'restrictionMode.$value';
}

/// The message type for the `customerSuppliedEncryptionEnforcementConfig` field.
final class Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      '.Bucket.encryption.customerSuppliedEncryptionEnforcementConfig';

  /// Server-determined value that indicates the time from which configuration was enforced and effective. This value is in RFC 3339 format.
  final Timestamp? effectiveTime;

  /// Restriction mode for Customer-Supplied Encryption Keys. Defaults to NotRestricted.
  final Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode?
  restrictionMode;

  Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig({
    this.effectiveTime,
    this.restrictionMode,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig(
      effectiveTime: switch (json['effectiveTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      restrictionMode: switch (json['restrictionMode']) {
        null => null,
        Object $1 =>
          Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    if (restrictionMode != null) 'restrictionMode': restrictionMode!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (restrictionMode != null) 'restrictionMode=$restrictionMode',
    ].join(',');
    return 'customerSuppliedEncryptionEnforcementConfig($contents)';
  }
}

/// The enumerated type for the `restrictionMode` field.
final class Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode
    extends ProtoEnum {
  /// Creation of new objects with Customer-Supplied Encryption is not restricted.
  static const notRestricted =
      Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode(
        'NotRestricted',
      );

  /// Creation of new objects with Customer-Supplied Encryption is fully restricted.
  static const fullyRestricted =
      Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode(
        'FullyRestricted',
      );

  /// The default value for [Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode].
  static const $default = notRestricted;

  const Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode(
    super.value,
  );

  factory Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode.fromJson(
    Object? json,
  ) =>
      Bucket_Encryption_CustomerSuppliedEncryptionEnforcementConfig_RestrictionMode(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'restrictionMode.$value';
}

/// The message type for the `googleManagedEncryptionEnforcementConfig` field.
final class Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      '.Bucket.encryption.googleManagedEncryptionEnforcementConfig';

  /// Server-determined value that indicates the time from which configuration was enforced and effective. This value is in RFC 3339 format.
  final Timestamp? effectiveTime;

  /// Restriction mode for Google-Managed Encryption Keys. Defaults to NotRestricted.
  final Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode?
  restrictionMode;

  Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig({
    this.effectiveTime,
    this.restrictionMode,
  }) : super(fullyQualifiedName);

  factory Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig(
      effectiveTime: switch (json['effectiveTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      restrictionMode: switch (json['restrictionMode']) {
        null => null,
        Object $1 =>
          Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    if (restrictionMode != null) 'restrictionMode': restrictionMode!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (restrictionMode != null) 'restrictionMode=$restrictionMode',
    ].join(',');
    return 'googleManagedEncryptionEnforcementConfig($contents)';
  }
}

/// The enumerated type for the `restrictionMode` field.
final class Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode
    extends ProtoEnum {
  /// Creation of new objects with Google Managed Encryption is not restricted.
  static const notRestricted =
      Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode(
        'NotRestricted',
      );

  /// Creation of new objects with Google Managed Encryption is fully restricted.
  static const fullyRestricted =
      Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode(
        'FullyRestricted',
      );

  /// The default value for [Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode].
  static const $default = notRestricted;

  const Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode(
    super.value,
  );

  factory Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode.fromJson(
    Object? json,
  ) =>
      Bucket_Encryption_GoogleManagedEncryptionEnforcementConfig_RestrictionMode(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'restrictionMode.$value';
}

/// The message type for the `hierarchicalNamespace` field.
final class Bucket_HierarchicalNamespace extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.hierarchicalNamespace';

  /// When set to true, hierarchical namespace is enabled for this bucket.
  final bool? enabled;

  Bucket_HierarchicalNamespace({this.enabled}) : super(fullyQualifiedName);

  factory Bucket_HierarchicalNamespace.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_HierarchicalNamespace(
      enabled: switch (json['enabled']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (enabled != null) 'enabled': enabled};

  @override
  String toString() {
    final contents = [if (enabled != null) 'enabled=$enabled'].join(',');
    return 'hierarchicalNamespace($contents)';
  }
}

/// The message type for the `iamConfiguration` field.
final class Bucket_IamConfiguration extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.iamConfiguration';

  /// The bucket's uniform bucket-level access configuration. The feature was formerly known as Bucket Policy Only. For backward compatibility, this field will be populated with identical information as the uniformBucketLevelAccess field. We recommend using the uniformBucketLevelAccess field to enable and disable the feature.
  final Bucket_IamConfiguration_BucketPolicyOnly? bucketPolicyOnly;

  /// The bucket's Public Access Prevention configuration. Currently, 'inherited' and 'enforced' are supported.
  final String? publicAccessPrevention;

  /// The bucket's uniform bucket-level access configuration.
  final Bucket_IamConfiguration_UniformBucketLevelAccess?
  uniformBucketLevelAccess;

  Bucket_IamConfiguration({
    this.bucketPolicyOnly,
    this.publicAccessPrevention,
    this.uniformBucketLevelAccess,
  }) : super(fullyQualifiedName);

  factory Bucket_IamConfiguration.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_IamConfiguration(
      bucketPolicyOnly: switch (json['bucketPolicyOnly']) {
        null => null,
        Object $1 => Bucket_IamConfiguration_BucketPolicyOnly.fromJson($1),
      },
      publicAccessPrevention: switch (json['publicAccessPrevention']) {
        null => null,
        Object $1 => decodeString($1),
      },
      uniformBucketLevelAccess: switch (json['uniformBucketLevelAccess']) {
        null => null,
        Object $1 => Bucket_IamConfiguration_UniformBucketLevelAccess.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucketPolicyOnly != null)
      'bucketPolicyOnly': bucketPolicyOnly!.toJson(),
    if (publicAccessPrevention != null)
      'publicAccessPrevention': publicAccessPrevention,
    if (uniformBucketLevelAccess != null)
      'uniformBucketLevelAccess': uniformBucketLevelAccess!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (publicAccessPrevention != null)
        'publicAccessPrevention=$publicAccessPrevention',
    ].join(',');
    return 'iamConfiguration($contents)';
  }
}

/// The message type for the `bucketPolicyOnly` field.
final class Bucket_IamConfiguration_BucketPolicyOnly extends ProtoMessage {
  static const String fullyQualifiedName =
      '.Bucket.iamConfiguration.bucketPolicyOnly';

  /// If set, access is controlled only by bucket-level or above IAM policies.
  final bool? enabled;

  /// The deadline for changing iamConfiguration.bucketPolicyOnly.enabled from true to false in RFC 3339 format. iamConfiguration.bucketPolicyOnly.enabled may be changed from true to false until the locked time, after which the field is immutable.
  final Timestamp? lockedTime;

  Bucket_IamConfiguration_BucketPolicyOnly({this.enabled, this.lockedTime})
    : super(fullyQualifiedName);

  factory Bucket_IamConfiguration_BucketPolicyOnly.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_IamConfiguration_BucketPolicyOnly(
      enabled: switch (json['enabled']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      lockedTime: switch (json['lockedTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enabled != null) 'enabled': enabled,
    if (lockedTime != null) 'lockedTime': lockedTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [if (enabled != null) 'enabled=$enabled'].join(',');
    return 'bucketPolicyOnly($contents)';
  }
}

/// The message type for the `uniformBucketLevelAccess` field.
final class Bucket_IamConfiguration_UniformBucketLevelAccess
    extends ProtoMessage {
  static const String fullyQualifiedName =
      '.Bucket.iamConfiguration.uniformBucketLevelAccess';

  /// If set, access is controlled only by bucket-level or above IAM policies.
  final bool? enabled;

  /// The deadline for changing iamConfiguration.uniformBucketLevelAccess.enabled from true to false in RFC 3339  format. iamConfiguration.uniformBucketLevelAccess.enabled may be changed from true to false until the locked time, after which the field is immutable.
  final Timestamp? lockedTime;

  Bucket_IamConfiguration_UniformBucketLevelAccess({
    this.enabled,
    this.lockedTime,
  }) : super(fullyQualifiedName);

  factory Bucket_IamConfiguration_UniformBucketLevelAccess.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_IamConfiguration_UniformBucketLevelAccess(
      enabled: switch (json['enabled']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      lockedTime: switch (json['lockedTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enabled != null) 'enabled': enabled,
    if (lockedTime != null) 'lockedTime': lockedTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [if (enabled != null) 'enabled=$enabled'].join(',');
    return 'uniformBucketLevelAccess($contents)';
  }
}

/// The message type for the `ipFilter` field.
final class Bucket_IpFilter extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.ipFilter';

  /// Whether to allow all service agents to access the bucket regardless of the IP filter configuration.
  final bool? allowAllServiceAgentAccess;

  /// Whether to allow cross-org VPCs in the bucket's IP filter configuration.
  final bool? allowCrossOrgVpcs;

  /// The mode of the IP filter. Valid values are 'Enabled' and 'Disabled'.
  final String? mode;

  /// The public network source of the bucket's IP filter.
  final Bucket_IpFilter_PublicNetworkSource? publicNetworkSource;

  /// The list of [VPC network](https://cloud.google.com/vpc/docs/vpc) sources of the bucket's IP filter.
  final List<Bucket_IpFilter_VpcNetworkSources> vpcNetworkSources;

  Bucket_IpFilter({
    this.allowAllServiceAgentAccess,
    this.allowCrossOrgVpcs,
    this.mode,
    this.publicNetworkSource,
    this.vpcNetworkSources = const [],
  }) : super(fullyQualifiedName);

  factory Bucket_IpFilter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_IpFilter(
      allowAllServiceAgentAccess: switch (json['allowAllServiceAgentAccess']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      allowCrossOrgVpcs: switch (json['allowCrossOrgVpcs']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      mode: switch (json['mode']) {
        null => null,
        Object $1 => decodeString($1),
      },
      publicNetworkSource: switch (json['publicNetworkSource']) {
        null => null,
        Object $1 => Bucket_IpFilter_PublicNetworkSource.fromJson($1),
      },
      vpcNetworkSources: switch (json['vpcNetworkSources']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Bucket_IpFilter_VpcNetworkSources.fromJson(i),
        ],
        _ => throw const FormatException('"vpcNetworkSources" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (allowAllServiceAgentAccess != null)
      'allowAllServiceAgentAccess': allowAllServiceAgentAccess,
    if (allowCrossOrgVpcs != null) 'allowCrossOrgVpcs': allowCrossOrgVpcs,
    if (mode != null) 'mode': mode,
    if (publicNetworkSource != null)
      'publicNetworkSource': publicNetworkSource!.toJson(),
    if (vpcNetworkSources.isNotDefault)
      'vpcNetworkSources': encodeList(vpcNetworkSources),
  };

  @override
  String toString() {
    final contents = [
      if (allowAllServiceAgentAccess != null)
        'allowAllServiceAgentAccess=$allowAllServiceAgentAccess',
      if (allowCrossOrgVpcs != null) 'allowCrossOrgVpcs=$allowCrossOrgVpcs',
      if (mode != null) 'mode=$mode',
    ].join(',');
    return 'ipFilter($contents)';
  }
}

/// The message type for the `publicNetworkSource` field.
final class Bucket_IpFilter_PublicNetworkSource extends ProtoMessage {
  static const String fullyQualifiedName =
      '.Bucket.ipFilter.publicNetworkSource';

  /// The list of public IPv4, IPv6 cidr ranges that are allowed to access the bucket.
  final List<String> allowedIpCidrRanges;

  Bucket_IpFilter_PublicNetworkSource({this.allowedIpCidrRanges = const []})
    : super(fullyQualifiedName);

  factory Bucket_IpFilter_PublicNetworkSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_IpFilter_PublicNetworkSource(
      allowedIpCidrRanges: switch (json['allowedIpCidrRanges']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"allowedIpCidrRanges" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (allowedIpCidrRanges.isNotDefault)
      'allowedIpCidrRanges': allowedIpCidrRanges,
  };

  @override
  String toString() => 'publicNetworkSource()';
}

/// The message type for the `vpcNetworkSources` field.
final class Bucket_IpFilter_VpcNetworkSources extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.ipFilter.vpcNetworkSources';

  /// The list of IPv4, IPv6 cidr ranges subnetworks that are allowed to access the bucket.
  final List<String> allowedIpCidrRanges;

  /// Name of the network. Format: projects/{PROJECT_ID}/global/networks/{NETWORK_NAME}
  final String? network;

  Bucket_IpFilter_VpcNetworkSources({
    this.allowedIpCidrRanges = const [],
    this.network,
  }) : super(fullyQualifiedName);

  factory Bucket_IpFilter_VpcNetworkSources.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_IpFilter_VpcNetworkSources(
      allowedIpCidrRanges: switch (json['allowedIpCidrRanges']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"allowedIpCidrRanges" is not a list'),
      },
      network: switch (json['network']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (allowedIpCidrRanges.isNotDefault)
      'allowedIpCidrRanges': allowedIpCidrRanges,
    if (network != null) 'network': network,
  };

  @override
  String toString() {
    final contents = [if (network != null) 'network=$network'].join(',');
    return 'vpcNetworkSources($contents)';
  }
}

/// The message type for the `lifecycle` field.
final class Bucket_Lifecycle extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.lifecycle';

  /// A lifecycle management rule, which is made of an action to take and the condition(s) under which the action will be taken.
  final List<Bucket_Lifecycle_Rule> rule;

  Bucket_Lifecycle({this.rule = const []}) : super(fullyQualifiedName);

  factory Bucket_Lifecycle.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Lifecycle(
      rule: switch (json['rule']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Bucket_Lifecycle_Rule.fromJson(i),
        ],
        _ => throw const FormatException('"rule" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (rule.isNotDefault) 'rule': encodeList(rule)};

  @override
  String toString() => 'lifecycle()';
}

/// The message type for the `rule` field.
final class Bucket_Lifecycle_Rule extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.lifecycle.rule';

  /// The action to take.
  final Bucket_Lifecycle_Rule_Action? action;

  /// The condition(s) under which the action will be taken.
  final Bucket_Lifecycle_Rule_Condition? condition;

  Bucket_Lifecycle_Rule({this.action, this.condition})
    : super(fullyQualifiedName);

  factory Bucket_Lifecycle_Rule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Lifecycle_Rule(
      action: switch (json['action']) {
        null => null,
        Object $1 => Bucket_Lifecycle_Rule_Action.fromJson($1),
      },
      condition: switch (json['condition']) {
        null => null,
        Object $1 => Bucket_Lifecycle_Rule_Condition.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (action != null) 'action': action!.toJson(),
    if (condition != null) 'condition': condition!.toJson(),
  };

  @override
  String toString() => 'rule()';
}

/// The message type for the `action` field.
final class Bucket_Lifecycle_Rule_Action extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.lifecycle.rule.action';

  /// Target storage class. Required iff the type of the action is SetStorageClass.
  final String? storageClass;

  /// Type of the action. Currently, only Delete, SetStorageClass, and AbortIncompleteMultipartUpload are supported.
  final String? type;

  Bucket_Lifecycle_Rule_Action({this.storageClass, this.type})
    : super(fullyQualifiedName);

  factory Bucket_Lifecycle_Rule_Action.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Lifecycle_Rule_Action(
      storageClass: switch (json['storageClass']) {
        null => null,
        Object $1 => decodeString($1),
      },
      type: switch (json['type']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (storageClass != null) 'storageClass': storageClass,
    if (type != null) 'type': type,
  };

  @override
  String toString() {
    final contents = [
      if (storageClass != null) 'storageClass=$storageClass',
      if (type != null) 'type=$type',
    ].join(',');
    return 'action($contents)';
  }
}

/// The message type for the `condition` field.
final class Bucket_Lifecycle_Rule_Condition extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.lifecycle.rule.condition';

  /// Age of an object (in days). This condition is satisfied when an object reaches the specified age.
  final int? age;

  /// A date in RFC 3339 format with only the date part (for instance, "2013-01-15"). This condition is satisfied when an object is created before midnight of the specified date in UTC.
  final String? createdBefore;

  /// A date in RFC 3339 format with only the date part (for instance, "2013-01-15"). This condition is satisfied when the custom time on an object is before this date in UTC.
  final String? customTimeBefore;

  /// Number of days elapsed since the user-specified timestamp set on an object. The condition is satisfied if the days elapsed is at least this number. If no custom timestamp is specified on an object, the condition does not apply.
  final int? daysSinceCustomTime;

  /// Number of days elapsed since the noncurrent timestamp of an object. The condition is satisfied if the days elapsed is at least this number. This condition is relevant only for versioned objects. The value of the field must be a nonnegative integer. If it's zero, the object version will become eligible for Lifecycle action as soon as it becomes noncurrent.
  final int? daysSinceNoncurrentTime;

  /// Relevant only for versioned objects. If the value is true, this condition matches live objects; if the value is false, it matches archived objects.
  final bool? isLive;

  /// A regular expression that satisfies the RE2 syntax. This condition is satisfied when the name of the object matches the RE2 pattern. Note: This feature is currently in the "Early Access" launch stage and is only available to a whitelisted set of users; that means that this feature may be changed in backward-incompatible ways and that it is not guaranteed to be released.
  final String? matchesPattern;

  /// List of object name prefixes. This condition will be satisfied when at least one of the prefixes exactly matches the beginning of the object name.
  final List<String> matchesPrefix;

  /// Objects having any of the storage classes specified by this condition will be matched. Values include MULTI_REGIONAL, REGIONAL, NEARLINE, COLDLINE, ARCHIVE, STANDARD, and DURABLE_REDUCED_AVAILABILITY.
  final List<String> matchesStorageClass;

  /// List of object name suffixes. This condition will be satisfied when at least one of the suffixes exactly matches the end of the object name.
  final List<String> matchesSuffix;

  /// A date in RFC 3339 format with only the date part (for instance, "2013-01-15"). This condition is satisfied when the noncurrent time on an object is before this date in UTC. This condition is relevant only for versioned objects.
  final String? noncurrentTimeBefore;

  /// Relevant only for versioned objects. If the value is N, this condition is satisfied when there are at least N versions (including the live version) newer than this version of the object.
  final int? numNewerVersions;

  Bucket_Lifecycle_Rule_Condition({
    this.age,
    this.createdBefore,
    this.customTimeBefore,
    this.daysSinceCustomTime,
    this.daysSinceNoncurrentTime,
    this.isLive,
    this.matchesPattern,
    this.matchesPrefix = const [],
    this.matchesStorageClass = const [],
    this.matchesSuffix = const [],
    this.noncurrentTimeBefore,
    this.numNewerVersions,
  }) : super(fullyQualifiedName);

  factory Bucket_Lifecycle_Rule_Condition.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Lifecycle_Rule_Condition(
      age: switch (json['age']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      createdBefore: switch (json['createdBefore']) {
        null => null,
        Object $1 => decodeString($1),
      },
      customTimeBefore: switch (json['customTimeBefore']) {
        null => null,
        Object $1 => decodeString($1),
      },
      daysSinceCustomTime: switch (json['daysSinceCustomTime']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      daysSinceNoncurrentTime: switch (json['daysSinceNoncurrentTime']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      isLive: switch (json['isLive']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      matchesPattern: switch (json['matchesPattern']) {
        null => null,
        Object $1 => decodeString($1),
      },
      matchesPrefix: switch (json['matchesPrefix']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"matchesPrefix" is not a list'),
      },
      matchesStorageClass: switch (json['matchesStorageClass']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"matchesStorageClass" is not a list'),
      },
      matchesSuffix: switch (json['matchesSuffix']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"matchesSuffix" is not a list'),
      },
      noncurrentTimeBefore: switch (json['noncurrentTimeBefore']) {
        null => null,
        Object $1 => decodeString($1),
      },
      numNewerVersions: switch (json['numNewerVersions']) {
        null => null,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (age != null) 'age': age,
    if (createdBefore != null) 'createdBefore': createdBefore,
    if (customTimeBefore != null) 'customTimeBefore': customTimeBefore,
    if (daysSinceCustomTime != null) 'daysSinceCustomTime': daysSinceCustomTime,
    if (daysSinceNoncurrentTime != null)
      'daysSinceNoncurrentTime': daysSinceNoncurrentTime,
    if (isLive != null) 'isLive': isLive,
    if (matchesPattern != null) 'matchesPattern': matchesPattern,
    if (matchesPrefix.isNotDefault) 'matchesPrefix': matchesPrefix,
    if (matchesStorageClass.isNotDefault)
      'matchesStorageClass': matchesStorageClass,
    if (matchesSuffix.isNotDefault) 'matchesSuffix': matchesSuffix,
    if (noncurrentTimeBefore != null)
      'noncurrentTimeBefore': noncurrentTimeBefore,
    if (numNewerVersions != null) 'numNewerVersions': numNewerVersions,
  };

  @override
  String toString() {
    final contents = [
      if (age != null) 'age=$age',
      if (createdBefore != null) 'createdBefore=$createdBefore',
      if (customTimeBefore != null) 'customTimeBefore=$customTimeBefore',
      if (daysSinceCustomTime != null)
        'daysSinceCustomTime=$daysSinceCustomTime',
      if (daysSinceNoncurrentTime != null)
        'daysSinceNoncurrentTime=$daysSinceNoncurrentTime',
      if (isLive != null) 'isLive=$isLive',
      if (matchesPattern != null) 'matchesPattern=$matchesPattern',
      if (noncurrentTimeBefore != null)
        'noncurrentTimeBefore=$noncurrentTimeBefore',
      if (numNewerVersions != null) 'numNewerVersions=$numNewerVersions',
    ].join(',');
    return 'condition($contents)';
  }
}

/// The message type for the `logging` field.
final class Bucket_Logging extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.logging';

  /// The destination bucket where the current bucket's logs should be placed.
  final String? logBucket;

  /// A prefix for log object names.
  final String? logObjectPrefix;

  Bucket_Logging({this.logBucket, this.logObjectPrefix})
    : super(fullyQualifiedName);

  factory Bucket_Logging.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Logging(
      logBucket: switch (json['logBucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      logObjectPrefix: switch (json['logObjectPrefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (logBucket != null) 'logBucket': logBucket,
    if (logObjectPrefix != null) 'logObjectPrefix': logObjectPrefix,
  };

  @override
  String toString() {
    final contents = [
      if (logBucket != null) 'logBucket=$logBucket',
      if (logObjectPrefix != null) 'logObjectPrefix=$logObjectPrefix',
    ].join(',');
    return 'logging($contents)';
  }
}

/// The message type for the `objectRetention` field.
final class Bucket_ObjectRetention extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.objectRetention';

  /// The bucket's object retention mode. Can be Enabled.
  final String? mode;

  Bucket_ObjectRetention({this.mode}) : super(fullyQualifiedName);

  factory Bucket_ObjectRetention.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_ObjectRetention(
      mode: switch (json['mode']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (mode != null) 'mode': mode};

  @override
  String toString() {
    final contents = [if (mode != null) 'mode=$mode'].join(',');
    return 'objectRetention($contents)';
  }
}

/// The message type for the `owner` field.
final class Bucket_Owner extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.owner';

  /// The entity, in the form project-owner-projectId.
  final String? entity;

  /// The ID for the entity.
  final String? entityId;

  Bucket_Owner({this.entity, this.entityId}) : super(fullyQualifiedName);

  factory Bucket_Owner.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Owner(
      entity: switch (json['entity']) {
        null => null,
        Object $1 => decodeString($1),
      },
      entityId: switch (json['entityId']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entity != null) 'entity': entity,
    if (entityId != null) 'entityId': entityId,
  };

  @override
  String toString() {
    final contents = [
      if (entity != null) 'entity=$entity',
      if (entityId != null) 'entityId=$entityId',
    ].join(',');
    return 'owner($contents)';
  }
}

/// The message type for the `retentionPolicy` field.
final class Bucket_RetentionPolicy extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.retentionPolicy';

  /// Server-determined value that indicates the time from which policy was enforced and effective. This value is in RFC 3339 format.
  final Timestamp? effectiveTime;

  /// Once locked, an object retention policy cannot be modified.
  final bool? isLocked;

  /// The duration in seconds that objects need to be retained. Retention duration must be greater than zero and less than 100 years. Note that enforcement of retention periods less than a day is not guaranteed. Such periods should only be used for testing purposes.
  final int? retentionPeriod;

  Bucket_RetentionPolicy({
    this.effectiveTime,
    this.isLocked,
    this.retentionPeriod,
  }) : super(fullyQualifiedName);

  factory Bucket_RetentionPolicy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_RetentionPolicy(
      effectiveTime: switch (json['effectiveTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      isLocked: switch (json['isLocked']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      retentionPeriod: switch (json['retentionPeriod']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    if (isLocked != null) 'isLocked': isLocked,
    if (retentionPeriod != null)
      'retentionPeriod': encodeInt64(retentionPeriod),
  };

  @override
  String toString() {
    final contents = [
      if (isLocked != null) 'isLocked=$isLocked',
      if (retentionPeriod != null) 'retentionPeriod=$retentionPeriod',
    ].join(',');
    return 'retentionPolicy($contents)';
  }
}

/// The message type for the `softDeletePolicy` field.
final class Bucket_SoftDeletePolicy extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.softDeletePolicy';

  /// Server-determined value that indicates the time from which the policy, or one with a greater retention, was effective. This value is in RFC 3339 format.
  final Timestamp? effectiveTime;

  /// The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted.
  final int? retentionDurationSeconds;

  Bucket_SoftDeletePolicy({this.effectiveTime, this.retentionDurationSeconds})
    : super(fullyQualifiedName);

  factory Bucket_SoftDeletePolicy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_SoftDeletePolicy(
      effectiveTime: switch (json['effectiveTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      retentionDurationSeconds: switch (json['retentionDurationSeconds']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (effectiveTime != null) 'effectiveTime': effectiveTime!.toJson(),
    if (retentionDurationSeconds != null)
      'retentionDurationSeconds': encodeInt64(retentionDurationSeconds),
  };

  @override
  String toString() {
    final contents = [
      if (retentionDurationSeconds != null)
        'retentionDurationSeconds=$retentionDurationSeconds',
    ].join(',');
    return 'softDeletePolicy($contents)';
  }
}

/// The message type for the `versioning` field.
final class Bucket_Versioning extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.versioning';

  /// While set to true, versioning is fully enabled for this bucket.
  final bool? enabled;

  Bucket_Versioning({this.enabled}) : super(fullyQualifiedName);

  factory Bucket_Versioning.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Versioning(
      enabled: switch (json['enabled']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (enabled != null) 'enabled': enabled};

  @override
  String toString() {
    final contents = [if (enabled != null) 'enabled=$enabled'].join(',');
    return 'versioning($contents)';
  }
}

/// The message type for the `website` field.
final class Bucket_Website extends ProtoMessage {
  static const String fullyQualifiedName = '.Bucket.website';

  /// If the requested object path is missing, the service will ensure the path has a trailing '/', append this suffix, and attempt to retrieve the resulting object. This allows the creation of index.html objects to represent directory pages.
  final String? mainPageSuffix;

  /// If the requested object path is missing, and any mainPageSuffix object is missing, if applicable, the service will return the named object from this bucket as the content for a 404 Not Found result.
  final String? notFoundPage;

  Bucket_Website({this.mainPageSuffix, this.notFoundPage})
    : super(fullyQualifiedName);

  factory Bucket_Website.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Bucket_Website(
      mainPageSuffix: switch (json['mainPageSuffix']) {
        null => null,
        Object $1 => decodeString($1),
      },
      notFoundPage: switch (json['notFoundPage']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (mainPageSuffix != null) 'mainPageSuffix': mainPageSuffix,
    if (notFoundPage != null) 'notFoundPage': notFoundPage,
  };

  @override
  String toString() {
    final contents = [
      if (mainPageSuffix != null) 'mainPageSuffix=$mainPageSuffix',
      if (notFoundPage != null) 'notFoundPage=$notFoundPage',
    ].join(',');
    return 'website($contents)';
  }
}

/// An access-control entry.
final class BucketAccessControl extends ProtoMessage {
  static const String fullyQualifiedName = '.BucketAccessControl';

  /// The name of the bucket.
  final String? bucket;

  /// The domain associated with the entity, if any.
  final String? domain;

  /// The email address associated with the entity, if any.
  final String? email;

  /// The entity holding the permission, in one of the following forms:
  /// - user-userId
  /// - user-email
  /// - group-groupId
  /// - group-email
  /// - domain-domain
  /// - project-team-projectId
  /// - allUsers
  /// - allAuthenticatedUsers Examples:
  /// - The user liz@example.com would be user-liz@example.com.
  /// - The group example@googlegroups.com would be group-example@googlegroups.com.
  /// - To refer to all members of the Google Apps for Business domain example.com, the entity would be domain-example.com.
  final String? entity;

  /// The ID for the entity, if any.
  final String? entityId;

  /// HTTP 1.1 Entity tag for the access-control entry.
  final String? etag;

  /// The ID of the access-control entry.
  final String? id;

  /// The kind of item this is. For bucket access control entries, this is always storage#bucketAccessControl.
  final String? kind;

  /// The project team associated with the entity, if any.
  final BucketAccessControl_ProjectTeam? projectTeam;

  /// The access permission for the entity.
  final String? role;

  /// The link to this access-control entry.
  final String? selfLink;

  BucketAccessControl({
    this.bucket,
    this.domain,
    this.email,
    this.entity,
    this.entityId,
    this.etag,
    this.id,
    this.kind,
    this.projectTeam,
    this.role,
    this.selfLink,
  }) : super(fullyQualifiedName);

  factory BucketAccessControl.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControl(
      bucket: switch (json['bucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      domain: switch (json['domain']) {
        null => null,
        Object $1 => decodeString($1),
      },
      email: switch (json['email']) {
        null => null,
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => null,
        Object $1 => decodeString($1),
      },
      entityId: switch (json['entityId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => null,
        Object $1 => decodeString($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      projectTeam: switch (json['projectTeam']) {
        null => null,
        Object $1 => BucketAccessControl_ProjectTeam.fromJson($1),
      },
      role: switch (json['role']) {
        null => null,
        Object $1 => decodeString($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket != null) 'bucket': bucket,
    if (domain != null) 'domain': domain,
    if (email != null) 'email': email,
    if (entity != null) 'entity': entity,
    if (entityId != null) 'entityId': entityId,
    if (etag != null) 'etag': etag,
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (projectTeam != null) 'projectTeam': projectTeam!.toJson(),
    if (role != null) 'role': role,
    if (selfLink != null) 'selfLink': selfLink,
  };

  @override
  String toString() {
    final contents = [
      if (bucket != null) 'bucket=$bucket',
      if (domain != null) 'domain=$domain',
      if (email != null) 'email=$email',
      if (entity != null) 'entity=$entity',
      if (entityId != null) 'entityId=$entityId',
      if (etag != null) 'etag=$etag',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (role != null) 'role=$role',
      if (selfLink != null) 'selfLink=$selfLink',
    ].join(',');
    return 'BucketAccessControl($contents)';
  }
}

/// The message type for the `projectTeam` field.
final class BucketAccessControl_ProjectTeam extends ProtoMessage {
  static const String fullyQualifiedName = '.BucketAccessControl.projectTeam';

  /// The project number.
  final String? projectNumber;

  /// The team.
  final String? team;

  BucketAccessControl_ProjectTeam({this.projectNumber, this.team})
    : super(fullyQualifiedName);

  factory BucketAccessControl_ProjectTeam.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControl_ProjectTeam(
      projectNumber: switch (json['projectNumber']) {
        null => null,
        Object $1 => decodeString($1),
      },
      team: switch (json['team']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (projectNumber != null) 'projectNumber': projectNumber,
    if (team != null) 'team': team,
  };

  @override
  String toString() {
    final contents = [
      if (projectNumber != null) 'projectNumber=$projectNumber',
      if (team != null) 'team=$team',
    ].join(',');
    return 'projectTeam($contents)';
  }
}

/// An access-control list.
final class BucketAccessControls extends ProtoMessage {
  static const String fullyQualifiedName = '.BucketAccessControls';

  /// The list of items.
  final List<BucketAccessControl> items;

  /// The kind of item this is. For lists of bucket access control entries, this is always storage#bucketAccessControls.
  final String? kind;

  BucketAccessControls({this.items = const [], this.kind})
    : super(fullyQualifiedName);

  factory BucketAccessControls.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControls(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) BucketAccessControl.fromJson(i),
        ],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
  };

  @override
  String toString() {
    final contents = [if (kind != null) 'kind=$kind'].join(',');
    return 'BucketAccessControls($contents)';
  }
}

/// The storage layout configuration of a bucket.
final class BucketStorageLayout extends ProtoMessage {
  static const String fullyQualifiedName = '.BucketStorageLayout';

  /// The name of the bucket.
  final String? bucket;

  /// The bucket's custom placement configuration for Custom Dual Regions.
  final BucketStorageLayout_CustomPlacementConfig? customPlacementConfig;

  /// The bucket's hierarchical namespace configuration.
  final BucketStorageLayout_HierarchicalNamespace? hierarchicalNamespace;

  /// The kind of item this is. For storage layout, this is always storage#storageLayout.
  final String? kind;

  /// The location of the bucket.
  final String? location;

  /// The type of the bucket location.
  final String? locationType;

  BucketStorageLayout({
    this.bucket,
    this.customPlacementConfig,
    this.hierarchicalNamespace,
    this.kind,
    this.location,
    this.locationType,
  }) : super(fullyQualifiedName);

  factory BucketStorageLayout.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketStorageLayout(
      bucket: switch (json['bucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      customPlacementConfig: switch (json['customPlacementConfig']) {
        null => null,
        Object $1 => BucketStorageLayout_CustomPlacementConfig.fromJson($1),
      },
      hierarchicalNamespace: switch (json['hierarchicalNamespace']) {
        null => null,
        Object $1 => BucketStorageLayout_HierarchicalNamespace.fromJson($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      location: switch (json['location']) {
        null => null,
        Object $1 => decodeString($1),
      },
      locationType: switch (json['locationType']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket != null) 'bucket': bucket,
    if (customPlacementConfig != null)
      'customPlacementConfig': customPlacementConfig!.toJson(),
    if (hierarchicalNamespace != null)
      'hierarchicalNamespace': hierarchicalNamespace!.toJson(),
    if (kind != null) 'kind': kind,
    if (location != null) 'location': location,
    if (locationType != null) 'locationType': locationType,
  };

  @override
  String toString() {
    final contents = [
      if (bucket != null) 'bucket=$bucket',
      if (kind != null) 'kind=$kind',
      if (location != null) 'location=$location',
      if (locationType != null) 'locationType=$locationType',
    ].join(',');
    return 'BucketStorageLayout($contents)';
  }
}

/// The message type for the `customPlacementConfig` field.
final class BucketStorageLayout_CustomPlacementConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      '.BucketStorageLayout.customPlacementConfig';

  /// The list of regional locations in which data is placed.
  final List<String> dataLocations;

  BucketStorageLayout_CustomPlacementConfig({this.dataLocations = const []})
    : super(fullyQualifiedName);

  factory BucketStorageLayout_CustomPlacementConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketStorageLayout_CustomPlacementConfig(
      dataLocations: switch (json['dataLocations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"dataLocations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataLocations.isNotDefault) 'dataLocations': dataLocations,
  };

  @override
  String toString() => 'customPlacementConfig()';
}

/// The message type for the `hierarchicalNamespace` field.
final class BucketStorageLayout_HierarchicalNamespace extends ProtoMessage {
  static const String fullyQualifiedName =
      '.BucketStorageLayout.hierarchicalNamespace';

  /// When set to true, hierarchical namespace is enabled for this bucket.
  final bool? enabled;

  BucketStorageLayout_HierarchicalNamespace({this.enabled})
    : super(fullyQualifiedName);

  factory BucketStorageLayout_HierarchicalNamespace.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketStorageLayout_HierarchicalNamespace(
      enabled: switch (json['enabled']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (enabled != null) 'enabled': enabled};

  @override
  String toString() {
    final contents = [if (enabled != null) 'enabled=$enabled'].join(',');
    return 'hierarchicalNamespace($contents)';
  }
}

/// A list of buckets.
final class Buckets extends ProtoMessage {
  static const String fullyQualifiedName = '.Buckets';

  /// The list of items.
  final List<Bucket> items;

  /// The kind of item this is. For lists of buckets, this is always storage#buckets.
  final String? kind;

  /// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
  final String? nextPageToken;

  Buckets({this.items = const [], this.kind, this.nextPageToken})
    : super(fullyQualifiedName);

  factory Buckets.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Bucket.fromJson(i)],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
    if (nextPageToken != null) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'Buckets($contents)';
  }
}

/// A bulk restore objects request.
final class BulkRestoreObjectsRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.BulkRestoreObjectsRequest';

  /// If false (default), the restore will not overwrite live objects with the same name at the destination. This means some deleted objects may be skipped. If true, live objects will be overwritten resulting in a noncurrent object (if versioning is enabled). If versioning is not enabled, overwriting the object will result in a soft-deleted object. In either case, if a noncurrent object already exists with the same name, a live version can be written without issue.
  final bool? allowOverwrite;

  /// If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.
  final bool? copySourceAcl;

  /// Restores only the objects that were created after this time.
  final Timestamp? createdAfterTime;

  /// Restores only the objects that were created before this time.
  final Timestamp? createdBeforeTime;

  /// Restores only the objects matching any of the specified glob(s). If this parameter is not specified, all objects will be restored within the specified time range.
  final List<String> matchGlobs;

  /// Restores only the objects that were soft-deleted after this time.
  final Timestamp? softDeletedAfterTime;

  /// Restores only the objects that were soft-deleted before this time.
  final Timestamp? softDeletedBeforeTime;

  BulkRestoreObjectsRequest({
    this.allowOverwrite,
    this.copySourceAcl,
    this.createdAfterTime,
    this.createdBeforeTime,
    this.matchGlobs = const [],
    this.softDeletedAfterTime,
    this.softDeletedBeforeTime,
  }) : super(fullyQualifiedName);

  factory BulkRestoreObjectsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BulkRestoreObjectsRequest(
      allowOverwrite: switch (json['allowOverwrite']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      copySourceAcl: switch (json['copySourceAcl']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      createdAfterTime: switch (json['createdAfterTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      createdBeforeTime: switch (json['createdBeforeTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      matchGlobs: switch (json['matchGlobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"matchGlobs" is not a list'),
      },
      softDeletedAfterTime: switch (json['softDeletedAfterTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      softDeletedBeforeTime: switch (json['softDeletedBeforeTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (allowOverwrite != null) 'allowOverwrite': allowOverwrite,
    if (copySourceAcl != null) 'copySourceAcl': copySourceAcl,
    if (createdAfterTime != null)
      'createdAfterTime': createdAfterTime!.toJson(),
    if (createdBeforeTime != null)
      'createdBeforeTime': createdBeforeTime!.toJson(),
    if (matchGlobs.isNotDefault) 'matchGlobs': matchGlobs,
    if (softDeletedAfterTime != null)
      'softDeletedAfterTime': softDeletedAfterTime!.toJson(),
    if (softDeletedBeforeTime != null)
      'softDeletedBeforeTime': softDeletedBeforeTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (allowOverwrite != null) 'allowOverwrite=$allowOverwrite',
      if (copySourceAcl != null) 'copySourceAcl=$copySourceAcl',
    ].join(',');
    return 'BulkRestoreObjectsRequest($contents)';
  }
}

/// An notification channel used to watch for resource changes.
final class Channel extends ProtoMessage {
  static const String fullyQualifiedName = '.Channel';

  /// The address where notifications are delivered for this channel.
  final String? address;

  /// Date and time of notification channel expiration, expressed as a Unix timestamp, in milliseconds. Optional.
  final int? expiration;

  /// A UUID or similar unique string that identifies this channel.
  final String? id;

  /// Identifies this as a notification channel used to watch for changes to a resource, which is "api#channel".
  final String? kind;

  /// Additional parameters controlling delivery channel behavior. Optional.
  final Map<String, String> params;

  /// A Boolean value to indicate whether payload is wanted. Optional.
  final bool? payload;

  /// An opaque ID that identifies the resource being watched on this channel. Stable across different API versions.
  final String? resourceId;

  /// A version-specific identifier for the watched resource.
  final String? resourceUri;

  /// An arbitrary string delivered to the target address with each notification delivered over this channel. Optional.
  final String? token;

  /// The type of delivery mechanism used for this channel.
  final String? type;

  Channel({
    this.address,
    this.expiration,
    this.id,
    this.kind,
    this.params = const {},
    this.payload,
    this.resourceId,
    this.resourceUri,
    this.token,
    this.type,
  }) : super(fullyQualifiedName);

  factory Channel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Channel(
      address: switch (json['address']) {
        null => null,
        Object $1 => decodeString($1),
      },
      expiration: switch (json['expiration']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      params: switch (json['params']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"params" is not an object'),
      },
      payload: switch (json['payload']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      resourceId: switch (json['resourceId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      resourceUri: switch (json['resourceUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      token: switch (json['token']) {
        null => null,
        Object $1 => decodeString($1),
      },
      type: switch (json['type']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (address != null) 'address': address,
    if (expiration != null) 'expiration': encodeInt64(expiration),
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (params.isNotDefault) 'params': params,
    if (payload != null) 'payload': payload,
    if (resourceId != null) 'resourceId': resourceId,
    if (resourceUri != null) 'resourceUri': resourceUri,
    if (token != null) 'token': token,
    if (type != null) 'type': type,
  };

  @override
  String toString() {
    final contents = [
      if (address != null) 'address=$address',
      if (expiration != null) 'expiration=$expiration',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (payload != null) 'payload=$payload',
      if (resourceId != null) 'resourceId=$resourceId',
      if (resourceUri != null) 'resourceUri=$resourceUri',
      if (token != null) 'token=$token',
      if (type != null) 'type=$type',
    ].join(',');
    return 'Channel($contents)';
  }
}

/// A Compose request.
final class ComposeRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.ComposeRequest';

  /// Properties of the resulting object.
  final Object$? destination;

  /// The kind of item this is.
  final String? kind;

  /// The list of source objects that will be concatenated into a single object.
  final List<ComposeRequest_SourceObjects> sourceObjects;

  ComposeRequest({this.destination, this.kind, this.sourceObjects = const []})
    : super(fullyQualifiedName);

  factory ComposeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ComposeRequest(
      destination: switch (json['destination']) {
        null => null,
        Object $1 => Object$.fromJson($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      sourceObjects: switch (json['sourceObjects']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ComposeRequest_SourceObjects.fromJson(i),
        ],
        _ => throw const FormatException('"sourceObjects" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (destination != null) 'destination': destination!.toJson(),
    if (kind != null) 'kind': kind,
    if (sourceObjects.isNotDefault) 'sourceObjects': encodeList(sourceObjects),
  };

  @override
  String toString() {
    final contents = [if (kind != null) 'kind=$kind'].join(',');
    return 'ComposeRequest($contents)';
  }
}

/// The message type for the `sourceObjects` field.
final class ComposeRequest_SourceObjects extends ProtoMessage {
  static const String fullyQualifiedName = '.ComposeRequest.sourceObjects';

  /// The generation of this object to use as the source.
  final int? generation;

  /// The source object's name. All source objects must reside in the same bucket.
  final String? name;

  /// Conditions that must be met for this operation to execute.
  final ComposeRequest_SourceObjects_ObjectPreconditions? objectPreconditions;

  ComposeRequest_SourceObjects({
    this.generation,
    this.name,
    this.objectPreconditions,
  }) : super(fullyQualifiedName);

  factory ComposeRequest_SourceObjects.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ComposeRequest_SourceObjects(
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      name: switch (json['name']) {
        null => null,
        Object $1 => decodeString($1),
      },
      objectPreconditions: switch (json['objectPreconditions']) {
        null => null,
        Object $1 => ComposeRequest_SourceObjects_ObjectPreconditions.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (generation != null) 'generation': encodeInt64(generation),
    if (name != null) 'name': name,
    if (objectPreconditions != null)
      'objectPreconditions': objectPreconditions!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (generation != null) 'generation=$generation',
      if (name != null) 'name=$name',
    ].join(',');
    return 'sourceObjects($contents)';
  }
}

/// The message type for the `objectPreconditions` field.
final class ComposeRequest_SourceObjects_ObjectPreconditions
    extends ProtoMessage {
  static const String fullyQualifiedName =
      '.ComposeRequest.sourceObjects.objectPreconditions';

  /// Only perform the composition if the generation of the source object that would be used matches this value. If this value and a generation are both specified, they must be the same value or the call will fail.
  final int? ifGenerationMatch;

  ComposeRequest_SourceObjects_ObjectPreconditions({this.ifGenerationMatch})
    : super(fullyQualifiedName);

  factory ComposeRequest_SourceObjects_ObjectPreconditions.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ComposeRequest_SourceObjects_ObjectPreconditions(
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
  };

  @override
  String toString() {
    final contents = [
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
    ].join(',');
    return 'objectPreconditions($contents)';
  }
}

/// Represents an expression text. Example: title: "User account presence" description: "Determines whether the request has a user account" expression: "size(request.user) > 0"
final class Expr extends ProtoMessage {
  static const String fullyQualifiedName = '.Expr';

  /// An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
  final String? description;

  /// Textual representation of an expression in Common Expression Language syntax. The application context of the containing message determines which well-known feature set of CEL is supported.
  final String? expression;

  /// An optional string indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
  final String? location;

  /// An optional title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
  final String? title;

  Expr({this.description, this.expression, this.location, this.title})
    : super(fullyQualifiedName);

  factory Expr.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Expr(
      description: switch (json['description']) {
        null => null,
        Object $1 => decodeString($1),
      },
      expression: switch (json['expression']) {
        null => null,
        Object $1 => decodeString($1),
      },
      location: switch (json['location']) {
        null => null,
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (description != null) 'description': description,
    if (expression != null) 'expression': expression,
    if (location != null) 'location': location,
    if (title != null) 'title': title,
  };

  @override
  String toString() {
    final contents = [
      if (description != null) 'description=$description',
      if (expression != null) 'expression=$expression',
      if (location != null) 'location=$location',
      if (title != null) 'title=$title',
    ].join(',');
    return 'Expr($contents)';
  }
}

/// A folder. Only available in buckets with hierarchical namespace enabled.
final class Folder extends ProtoMessage {
  static const String fullyQualifiedName = '.Folder';

  /// The name of the bucket containing this folder.
  final String? bucket;

  /// The creation time of the folder in RFC 3339 format.
  final Timestamp? createTime;

  /// The ID of the folder, including the bucket name, folder name.
  final String? id;

  /// The kind of item this is. For folders, this is always storage#folder.
  final String? kind;

  /// The version of the metadata for this folder. Used for preconditions and for detecting changes in metadata.
  final int? metageneration;

  /// The name of the folder. Required if not specified by URL parameter.
  final String? name;

  /// Only present if the folder is part of an ongoing rename folder operation. Contains information which can be used to query the operation status.
  final Folder_PendingRenameInfo? pendingRenameInfo;

  /// The link to this folder.
  final String? selfLink;

  /// The modification time of the folder metadata in RFC 3339 format.
  final Timestamp? updateTime;

  Folder({
    this.bucket,
    this.createTime,
    this.id,
    this.kind,
    this.metageneration,
    this.name,
    this.pendingRenameInfo,
    this.selfLink,
    this.updateTime,
  }) : super(fullyQualifiedName);

  factory Folder.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folder(
      bucket: switch (json['bucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      metageneration: switch (json['metageneration']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      name: switch (json['name']) {
        null => null,
        Object $1 => decodeString($1),
      },
      pendingRenameInfo: switch (json['pendingRenameInfo']) {
        null => null,
        Object $1 => Folder_PendingRenameInfo.fromJson($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket != null) 'bucket': bucket,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (metageneration != null) 'metageneration': encodeInt64(metageneration),
    if (name != null) 'name': name,
    if (pendingRenameInfo != null)
      'pendingRenameInfo': pendingRenameInfo!.toJson(),
    if (selfLink != null) 'selfLink': selfLink,
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (bucket != null) 'bucket=$bucket',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (metageneration != null) 'metageneration=$metageneration',
      if (name != null) 'name=$name',
      if (selfLink != null) 'selfLink=$selfLink',
    ].join(',');
    return 'Folder($contents)';
  }
}

/// The message type for the `pendingRenameInfo` field.
final class Folder_PendingRenameInfo extends ProtoMessage {
  static const String fullyQualifiedName = '.Folder.pendingRenameInfo';

  /// The ID of the rename folder operation.
  final String? operationId;

  Folder_PendingRenameInfo({this.operationId}) : super(fullyQualifiedName);

  factory Folder_PendingRenameInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folder_PendingRenameInfo(
      operationId: switch (json['operationId']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (operationId != null) 'operationId': operationId};

  @override
  String toString() {
    final contents = [
      if (operationId != null) 'operationId=$operationId',
    ].join(',');
    return 'pendingRenameInfo($contents)';
  }
}

/// A list of folders.
final class Folders extends ProtoMessage {
  static const String fullyQualifiedName = '.Folders';

  /// The list of items.
  final List<Folder> items;

  /// The kind of item this is. For lists of folders, this is always storage#folders.
  final String? kind;

  /// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
  final String? nextPageToken;

  Folders({this.items = const [], this.kind, this.nextPageToken})
    : super(fullyQualifiedName);

  factory Folders.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folders(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Folder.fromJson(i)],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
    if (nextPageToken != null) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'Folders($contents)';
  }
}

/// The response message for storage.buckets.operations.list.
final class GoogleLongrunningListOperationsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      '.GoogleLongrunningListOperationsResponse';

  /// The kind of item this is. For lists of operations, this is always storage#operations.
  final String? kind;

  /// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
  final String? nextPageToken;

  /// A list of operations that matches the specified filter in the request.
  final List<GoogleLongrunningOperation> operations;

  GoogleLongrunningListOperationsResponse({
    this.kind,
    this.nextPageToken,
    this.operations = const [],
  }) : super(fullyQualifiedName);

  factory GoogleLongrunningListOperationsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoogleLongrunningListOperationsResponse(
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      operations: switch (json['operations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) GoogleLongrunningOperation.fromJson(i),
        ],
        _ => throw const FormatException('"operations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (kind != null) 'kind': kind,
    if (nextPageToken != null) 'nextPageToken': nextPageToken,
    if (operations.isNotDefault) 'operations': encodeList(operations),
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'GoogleLongrunningListOperationsResponse($contents)';
  }
}

/// This resource represents a long-running operation that is the result of a network API call.
final class GoogleLongrunningOperation extends ProtoMessage {
  static const String fullyQualifiedName = '.GoogleLongrunningOperation';

  /// If the value is "false", it means the operation is still in progress. If "true", the operation is completed, and either "error" or "response" is available.
  final bool? done;

  /// The error result of the operation in case of failure or cancellation.
  final GoogleRpcStatus? error;

  /// The kind of item this is. For operations, this is always storage#operation.
  final String? kind;

  /// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
  final Map<String, Value> metadata;

  /// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the "name" should be a resource name ending with "operations/{operationId}".
  final String? name;

  /// The normal response of the operation in case of success. If the original method returns no data on success, such as "Delete", the response is google.protobuf.Empty. If the original method is standard Get/Create/Update, the response should be the resource. For other methods, the response should have the type "XxxResponse", where "Xxx" is the original method name. For example, if the original method name is "TakeSnapshot()", the inferred response type is "TakeSnapshotResponse".
  final Map<String, Value> response;

  /// The link to this long running operation.
  final String? selfLink;

  GoogleLongrunningOperation({
    this.done,
    this.error,
    this.kind,
    this.metadata = const {},
    this.name,
    this.response = const {},
    this.selfLink,
  }) : super(fullyQualifiedName);

  factory GoogleLongrunningOperation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoogleLongrunningOperation(
      done: switch (json['done']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => GoogleRpcStatus.fromJson($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Value.fromJson(e.value),
        },
        _ => throw const FormatException('"metadata" is not an object'),
      },
      name: switch (json['name']) {
        null => null,
        Object $1 => decodeString($1),
      },
      response: switch (json['response']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Value.fromJson(e.value),
        },
        _ => throw const FormatException('"response" is not an object'),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (done != null) 'done': done,
    if (error != null) 'error': error!.toJson(),
    if (kind != null) 'kind': kind,
    if (metadata.isNotDefault) 'metadata': encodeMap(metadata),
    if (name != null) 'name': name,
    if (response.isNotDefault) 'response': encodeMap(response),
    if (selfLink != null) 'selfLink': selfLink,
  };

  @override
  String toString() {
    final contents = [
      if (done != null) 'done=$done',
      if (kind != null) 'kind=$kind',
      if (name != null) 'name=$name',
      if (selfLink != null) 'selfLink=$selfLink',
    ].join(',');
    return 'GoogleLongrunningOperation($contents)';
  }
}

/// The "Status" type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each "Status" message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
final class GoogleRpcStatus extends ProtoMessage {
  static const String fullyQualifiedName = '.GoogleRpcStatus';

  /// The status code, which should be an enum value of google.rpc.Code.
  final int? code;

  /// A list of messages that carry the error details. There is a common set of message types for APIs to use.
  final List<Value> details;

  /// A developer-facing error message, which should be in English.
  final String? message;

  GoogleRpcStatus({this.code, this.details = const [], this.message})
    : super(fullyQualifiedName);

  factory GoogleRpcStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoogleRpcStatus(
      code: switch (json['code']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      details: switch (json['details']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Value.fromJson(i)],
        _ => throw const FormatException('"details" is not a list'),
      },
      message: switch (json['message']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (code != null) 'code': code,
    if (details.isNotDefault) 'details': encodeList(details),
    if (message != null) 'message': message,
  };

  @override
  String toString() {
    final contents = [
      if (code != null) 'code=$code',
      if (message != null) 'message=$message',
    ].join(',');
    return 'GoogleRpcStatus($contents)';
  }
}

/// JSON template to produce a JSON-style HMAC Key resource for Create responses.
final class HmacKey extends ProtoMessage {
  static const String fullyQualifiedName = '.HmacKey';

  /// The kind of item this is. For HMAC keys, this is always storage#hmacKey.
  final String? kind;

  /// Key metadata.
  final HmacKeyMetadata? metadata;

  /// HMAC secret key material.
  final String? secret;

  HmacKey({this.kind, this.metadata, this.secret}) : super(fullyQualifiedName);

  factory HmacKey.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKey(
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => HmacKeyMetadata.fromJson($1),
      },
      secret: switch (json['secret']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (kind != null) 'kind': kind,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (secret != null) 'secret': secret,
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (secret != null) 'secret=$secret',
    ].join(',');
    return 'HmacKey($contents)';
  }
}

/// JSON template to produce a JSON-style HMAC Key metadata resource.
final class HmacKeyMetadata extends ProtoMessage {
  static const String fullyQualifiedName = '.HmacKeyMetadata';

  /// The ID of the HMAC Key.
  final String? accessId;

  /// HTTP 1.1 Entity tag for the HMAC key.
  final String? etag;

  /// The ID of the HMAC key, including the Project ID and the Access ID.
  final String? id;

  /// The kind of item this is. For HMAC Key metadata, this is always storage#hmacKeyMetadata.
  final String? kind;

  /// Project ID owning the service account to which the key authenticates.
  final String? projectId;

  /// The link to this resource.
  final String? selfLink;

  /// The email address of the key's associated service account.
  final String? serviceAccountEmail;

  /// The state of the key. Can be one of ACTIVE, INACTIVE, or DELETED.
  final String? state;

  /// The creation time of the HMAC key in RFC 3339 format.
  final Timestamp? timeCreated;

  /// The last modification time of the HMAC key metadata in RFC 3339 format.
  final Timestamp? updated;

  HmacKeyMetadata({
    this.accessId,
    this.etag,
    this.id,
    this.kind,
    this.projectId,
    this.selfLink,
    this.serviceAccountEmail,
    this.state,
    this.timeCreated,
    this.updated,
  }) : super(fullyQualifiedName);

  factory HmacKeyMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKeyMetadata(
      accessId: switch (json['accessId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => null,
        Object $1 => decodeString($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      serviceAccountEmail: switch (json['serviceAccountEmail']) {
        null => null,
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => null,
        Object $1 => decodeString($1),
      },
      timeCreated: switch (json['timeCreated']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      updated: switch (json['updated']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (accessId != null) 'accessId': accessId,
    if (etag != null) 'etag': etag,
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (projectId != null) 'projectId': projectId,
    if (selfLink != null) 'selfLink': selfLink,
    if (serviceAccountEmail != null) 'serviceAccountEmail': serviceAccountEmail,
    if (state != null) 'state': state,
    if (timeCreated != null) 'timeCreated': timeCreated!.toJson(),
    if (updated != null) 'updated': updated!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (accessId != null) 'accessId=$accessId',
      if (etag != null) 'etag=$etag',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (projectId != null) 'projectId=$projectId',
      if (selfLink != null) 'selfLink=$selfLink',
      if (serviceAccountEmail != null)
        'serviceAccountEmail=$serviceAccountEmail',
      if (state != null) 'state=$state',
    ].join(',');
    return 'HmacKeyMetadata($contents)';
  }
}

/// A list of hmacKeys.
final class HmacKeysMetadata extends ProtoMessage {
  static const String fullyQualifiedName = '.HmacKeysMetadata';

  /// The list of items.
  final List<HmacKeyMetadata> items;

  /// The kind of item this is. For lists of hmacKeys, this is always storage#hmacKeysMetadata.
  final String? kind;

  /// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
  final String? nextPageToken;

  HmacKeysMetadata({this.items = const [], this.kind, this.nextPageToken})
    : super(fullyQualifiedName);

  factory HmacKeysMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKeysMetadata(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) HmacKeyMetadata.fromJson(i)],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
    if (nextPageToken != null) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'HmacKeysMetadata($contents)';
  }
}

/// A managed folder.
final class ManagedFolder extends ProtoMessage {
  static const String fullyQualifiedName = '.ManagedFolder';

  /// The name of the bucket containing this managed folder.
  final String? bucket;

  /// The creation time of the managed folder in RFC 3339 format.
  final Timestamp? createTime;

  /// The ID of the managed folder, including the bucket name and managed folder name.
  final String? id;

  /// The kind of item this is. For managed folders, this is always storage#managedFolder.
  final String? kind;

  /// The version of the metadata for this managed folder. Used for preconditions and for detecting changes in metadata.
  final int? metageneration;

  /// The name of the managed folder. Required if not specified by URL parameter.
  final String? name;

  /// The link to this managed folder.
  final String? selfLink;

  /// The last update time of the managed folder metadata in RFC 3339 format.
  final Timestamp? updateTime;

  ManagedFolder({
    this.bucket,
    this.createTime,
    this.id,
    this.kind,
    this.metageneration,
    this.name,
    this.selfLink,
    this.updateTime,
  }) : super(fullyQualifiedName);

  factory ManagedFolder.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolder(
      bucket: switch (json['bucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      metageneration: switch (json['metageneration']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      name: switch (json['name']) {
        null => null,
        Object $1 => decodeString($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket != null) 'bucket': bucket,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (metageneration != null) 'metageneration': encodeInt64(metageneration),
    if (name != null) 'name': name,
    if (selfLink != null) 'selfLink': selfLink,
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (bucket != null) 'bucket=$bucket',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (metageneration != null) 'metageneration=$metageneration',
      if (name != null) 'name=$name',
      if (selfLink != null) 'selfLink=$selfLink',
    ].join(',');
    return 'ManagedFolder($contents)';
  }
}

/// A list of managed folders.
final class ManagedFolders extends ProtoMessage {
  static const String fullyQualifiedName = '.ManagedFolders';

  /// The list of items.
  final List<ManagedFolder> items;

  /// The kind of item this is. For lists of managed folders, this is always storage#managedFolders.
  final String? kind;

  /// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
  final String? nextPageToken;

  ManagedFolders({this.items = const [], this.kind, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ManagedFolders.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ManagedFolder.fromJson(i)],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
    if (nextPageToken != null) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ManagedFolders($contents)';
  }
}

/// A subscription to receive Google PubSub notifications.
final class Notification extends ProtoMessage {
  static const String fullyQualifiedName = '.Notification';

  /// An optional list of additional attributes to attach to each Cloud PubSub message published for this notification subscription.
  final Map<String, String> customAttributes;

  /// HTTP 1.1 Entity tag for this subscription notification.
  final String? etag;

  /// If present, only send notifications about listed event types. If empty, sent notifications for all event types.
  final List<String> eventTypes;

  /// The ID of the notification.
  final String? id;

  /// The kind of item this is. For notifications, this is always storage#notification.
  final String? kind;

  /// If present, only apply this notification configuration to object names that begin with this prefix.
  final String? objectNamePrefix;

  /// The desired content of the Payload.
  final String? payloadFormat;

  /// The canonical URL of this notification.
  final String? selfLink;

  /// The Cloud PubSub topic to which this subscription publishes. Formatted as: '//pubsub.googleapis.com/projects/{project-identifier}/topics/{my-topic}'
  final String? topic;

  Notification({
    this.customAttributes = const {},
    this.etag,
    this.eventTypes = const [],
    this.id,
    this.kind,
    this.objectNamePrefix,
    this.payloadFormat,
    this.selfLink,
    this.topic,
  }) : super(fullyQualifiedName);

  factory Notification.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Notification(
      customAttributes: switch (json['custom_attributes']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException(
          '"custom_attributes" is not an object',
        ),
      },
      etag: switch (json['etag']) {
        null => null,
        Object $1 => decodeString($1),
      },
      eventTypes: switch (json['event_types']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"event_types" is not a list'),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      objectNamePrefix: switch (json['object_name_prefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
      payloadFormat: switch (json['payload_format']) {
        null => null,
        Object $1 => decodeString($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      topic: switch (json['topic']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (customAttributes.isNotDefault) 'custom_attributes': customAttributes,
    if (etag != null) 'etag': etag,
    if (eventTypes.isNotDefault) 'event_types': eventTypes,
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (objectNamePrefix != null) 'object_name_prefix': objectNamePrefix,
    if (payloadFormat != null) 'payload_format': payloadFormat,
    if (selfLink != null) 'selfLink': selfLink,
    if (topic != null) 'topic': topic,
  };

  @override
  String toString() {
    final contents = [
      if (etag != null) 'etag=$etag',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (objectNamePrefix != null) 'object_name_prefix=$objectNamePrefix',
      if (payloadFormat != null) 'payload_format=$payloadFormat',
      if (selfLink != null) 'selfLink=$selfLink',
      if (topic != null) 'topic=$topic',
    ].join(',');
    return 'Notification($contents)';
  }
}

/// A list of notification subscriptions.
final class Notifications extends ProtoMessage {
  static const String fullyQualifiedName = '.Notifications';

  /// The list of items.
  final List<Notification> items;

  /// The kind of item this is. For lists of notifications, this is always storage#notifications.
  final String? kind;

  Notifications({this.items = const [], this.kind}) : super(fullyQualifiedName);

  factory Notifications.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Notifications(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Notification.fromJson(i)],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
  };

  @override
  String toString() {
    final contents = [if (kind != null) 'kind=$kind'].join(',');
    return 'Notifications($contents)';
  }
}

/// An object.
final class Object$ extends ProtoMessage {
  static const String fullyQualifiedName = '.Object';

  /// Access controls on the object.
  final List<ObjectAccessControl> acl;

  /// The name of the bucket containing this object.
  final String? bucket;

  /// Cache-Control directive for the object data. If omitted, and the object is accessible to all anonymous users, the default will be public, max-age=3600.
  final String? cacheControl;

  /// Number of underlying components that make up this object. Components are accumulated by compose operations.
  final int? componentCount;

  /// Content-Disposition of the object data.
  final String? contentDisposition;

  /// Content-Encoding of the object data.
  final String? contentEncoding;

  /// Content-Language of the object data.
  final String? contentLanguage;

  /// Content-Type of the object data. If an object is stored without a Content-Type, it is served as application/octet-stream.
  final String? contentType;

  /// User-defined or system-defined object contexts. Each object context is a key-payload pair, where the key provides the identification and the payload holds the associated value and additional metadata.
  final Object$_Contexts? contexts;

  /// CRC32c checksum, as described in RFC 4960, Appendix B; encoded using base64 in big-endian byte order. For more information about using the CRC32c checksum, see [Data Validation and Change Detection](https://cloud.google.com/storage/docs/data-validation).
  final String? crc32C;

  /// A timestamp in RFC 3339 format specified by the user for an object.
  final Timestamp? customTime;

  /// Metadata of customer-supplied encryption key, if the object is encrypted by such a key.
  final Object$_CustomerEncryption? customerEncryption;

  /// HTTP 1.1 Entity tag for the object.
  final String? etag;

  /// Whether an object is under event-based hold. Event-based hold is a way to retain objects until an event occurs, which is signified by the hold's release (i.e. this value is set to false). After being released (set to false), such objects will be subject to bucket-level retention (if any). One sample use case of this flag is for banks to hold loan documents for at least 3 years after loan is paid in full. Here, bucket-level retention is 3 years and the event is the loan being paid in full. In this example, these objects will be held intact for any number of years until the event has occurred (event-based hold on the object is released) and then 3 more years after that. That means retention duration of the objects begins from the moment event-based hold transitioned from true to false.
  final bool? eventBasedHold;

  /// The content generation of this object. Used for object versioning.
  final int? generation;

  /// This is the time (in the future) when the soft-deleted object will no longer be restorable. It is equal to the soft delete time plus the current soft delete retention duration of the bucket.
  final Timestamp? hardDeleteTime;

  /// The ID of the object, including the bucket name, object name, and generation number.
  final String? id;

  /// The kind of item this is. For objects, this is always storage#object.
  final String? kind;

  /// Not currently supported. Specifying the parameter causes the request to fail with status code 400 - Bad Request.
  final String? kmsKeyName;

  /// MD5 hash of the data; encoded using base64. For more information about using the MD5 hash, see [Data Validation and Change Detection](https://cloud.google.com/storage/docs/data-validation).
  final String? md5Hash;

  /// Media download link.
  final String? mediaLink;

  /// User-provided metadata, in key/value pairs.
  final Map<String, String> metadata;

  /// The version of the metadata for this object at this generation. Used for preconditions and for detecting changes in metadata. A metageneration number is only meaningful in the context of a particular generation of a particular object.
  final int? metageneration;

  /// The name of the object. Required if not specified by URL parameter.
  final String? name;

  /// The owner of the object. This will always be the uploader of the object.
  final Object$_Owner? owner;

  /// Restore token used to differentiate deleted objects with the same name and generation. This field is only returned for deleted objects in hierarchical namespace buckets.
  final String? restoreToken;

  /// A collection of object level retention parameters.
  final Object$_Retention? retention;

  /// A server-determined value that specifies the earliest time that the object's retention period expires. This value is in RFC 3339 format. Note 1: This field is not provided for objects with an active event-based hold, since retention expiration is unknown until the hold is removed. Note 2: This value can be provided even when temporary hold is set (so that the user can reason about policy without having to first unset the temporary hold).
  final Timestamp? retentionExpirationTime;

  /// The link to this object.
  final String? selfLink;

  /// Content-Length of the data in bytes.
  final BigInt? size;

  /// The time at which the object became soft-deleted in RFC 3339 format.
  final Timestamp? softDeleteTime;

  /// Storage class of the object.
  final String? storageClass;

  /// Whether an object is under temporary hold. While this flag is set to true, the object is protected against deletion and overwrites. A common use case of this flag is regulatory investigations where objects need to be retained while the investigation is ongoing. Note that unlike event-based hold, temporary hold does not impact retention expiration time of an object.
  final bool? temporaryHold;

  /// The creation time of the object in RFC 3339 format.
  final Timestamp? timeCreated;

  /// The time at which the object became noncurrent in RFC 3339 format. Will be returned if and only if this version of the object has been deleted.
  final Timestamp? timeDeleted;

  /// The time when the object was finalized.
  final Timestamp? timeFinalized;

  /// The time at which the object's storage class was last changed. When the object is initially created, it will be set to timeCreated.
  final Timestamp? timeStorageClassUpdated;

  /// The modification time of the object metadata in RFC 3339 format. Set initially to object creation time and then updated whenever any metadata of the object changes. This includes changes made by a requester, such as modifying custom metadata, as well as changes made by Cloud Storage on behalf of a requester, such as changing the storage class based on an Object Lifecycle Configuration.
  final Timestamp? updated;

  Object$({
    this.acl = const [],
    this.bucket,
    this.cacheControl,
    this.componentCount,
    this.contentDisposition,
    this.contentEncoding,
    this.contentLanguage,
    this.contentType,
    this.contexts,
    this.crc32C,
    this.customTime,
    this.customerEncryption,
    this.etag,
    this.eventBasedHold,
    this.generation,
    this.hardDeleteTime,
    this.id,
    this.kind,
    this.kmsKeyName,
    this.md5Hash,
    this.mediaLink,
    this.metadata = const {},
    this.metageneration,
    this.name,
    this.owner,
    this.restoreToken,
    this.retention,
    this.retentionExpirationTime,
    this.selfLink,
    this.size,
    this.softDeleteTime,
    this.storageClass,
    this.temporaryHold,
    this.timeCreated,
    this.timeDeleted,
    this.timeFinalized,
    this.timeStorageClassUpdated,
    this.updated,
  }) : super(fullyQualifiedName);

  factory Object$.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Object$(
      acl: switch (json['acl']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ObjectAccessControl.fromJson(i),
        ],
        _ => throw const FormatException('"acl" is not a list'),
      },
      bucket: switch (json['bucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      cacheControl: switch (json['cacheControl']) {
        null => null,
        Object $1 => decodeString($1),
      },
      componentCount: switch (json['componentCount']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      contentDisposition: switch (json['contentDisposition']) {
        null => null,
        Object $1 => decodeString($1),
      },
      contentEncoding: switch (json['contentEncoding']) {
        null => null,
        Object $1 => decodeString($1),
      },
      contentLanguage: switch (json['contentLanguage']) {
        null => null,
        Object $1 => decodeString($1),
      },
      contentType: switch (json['contentType']) {
        null => null,
        Object $1 => decodeString($1),
      },
      contexts: switch (json['contexts']) {
        null => null,
        Object $1 => Object$_Contexts.fromJson($1),
      },
      crc32C: switch (json['crc32c']) {
        null => null,
        Object $1 => decodeString($1),
      },
      customTime: switch (json['customTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      customerEncryption: switch (json['customerEncryption']) {
        null => null,
        Object $1 => Object$_CustomerEncryption.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => null,
        Object $1 => decodeString($1),
      },
      eventBasedHold: switch (json['eventBasedHold']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      hardDeleteTime: switch (json['hardDeleteTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kmsKeyName: switch (json['kmsKeyName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      md5Hash: switch (json['md5Hash']) {
        null => null,
        Object $1 => decodeString($1),
      },
      mediaLink: switch (json['mediaLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"metadata" is not an object'),
      },
      metageneration: switch (json['metageneration']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      name: switch (json['name']) {
        null => null,
        Object $1 => decodeString($1),
      },
      owner: switch (json['owner']) {
        null => null,
        Object $1 => Object$_Owner.fromJson($1),
      },
      restoreToken: switch (json['restoreToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      retention: switch (json['retention']) {
        null => null,
        Object $1 => Object$_Retention.fromJson($1),
      },
      retentionExpirationTime: switch (json['retentionExpirationTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
      size: switch (json['size']) {
        null => null,
        Object $1 => decodeUint64($1),
      },
      softDeleteTime: switch (json['softDeleteTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      storageClass: switch (json['storageClass']) {
        null => null,
        Object $1 => decodeString($1),
      },
      temporaryHold: switch (json['temporaryHold']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      timeCreated: switch (json['timeCreated']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      timeDeleted: switch (json['timeDeleted']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      timeFinalized: switch (json['timeFinalized']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      timeStorageClassUpdated: switch (json['timeStorageClassUpdated']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      updated: switch (json['updated']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (acl.isNotDefault) 'acl': encodeList(acl),
    if (bucket != null) 'bucket': bucket,
    if (cacheControl != null) 'cacheControl': cacheControl,
    if (componentCount != null) 'componentCount': componentCount,
    if (contentDisposition != null) 'contentDisposition': contentDisposition,
    if (contentEncoding != null) 'contentEncoding': contentEncoding,
    if (contentLanguage != null) 'contentLanguage': contentLanguage,
    if (contentType != null) 'contentType': contentType,
    if (contexts != null) 'contexts': contexts!.toJson(),
    if (crc32C != null) 'crc32c': crc32C,
    if (customTime != null) 'customTime': customTime!.toJson(),
    if (customerEncryption != null)
      'customerEncryption': customerEncryption!.toJson(),
    if (etag != null) 'etag': etag,
    if (eventBasedHold != null) 'eventBasedHold': eventBasedHold,
    if (generation != null) 'generation': encodeInt64(generation),
    if (hardDeleteTime != null) 'hardDeleteTime': hardDeleteTime!.toJson(),
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName,
    if (md5Hash != null) 'md5Hash': md5Hash,
    if (mediaLink != null) 'mediaLink': mediaLink,
    if (metadata.isNotDefault) 'metadata': metadata,
    if (metageneration != null) 'metageneration': encodeInt64(metageneration),
    if (name != null) 'name': name,
    if (owner != null) 'owner': owner!.toJson(),
    if (restoreToken != null) 'restoreToken': restoreToken,
    if (retention != null) 'retention': retention!.toJson(),
    if (retentionExpirationTime != null)
      'retentionExpirationTime': retentionExpirationTime!.toJson(),
    if (selfLink != null) 'selfLink': selfLink,
    if (size != null) 'size': encodeUint64(size),
    if (softDeleteTime != null) 'softDeleteTime': softDeleteTime!.toJson(),
    if (storageClass != null) 'storageClass': storageClass,
    if (temporaryHold != null) 'temporaryHold': temporaryHold,
    if (timeCreated != null) 'timeCreated': timeCreated!.toJson(),
    if (timeDeleted != null) 'timeDeleted': timeDeleted!.toJson(),
    if (timeFinalized != null) 'timeFinalized': timeFinalized!.toJson(),
    if (timeStorageClassUpdated != null)
      'timeStorageClassUpdated': timeStorageClassUpdated!.toJson(),
    if (updated != null) 'updated': updated!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (bucket != null) 'bucket=$bucket',
      if (cacheControl != null) 'cacheControl=$cacheControl',
      if (componentCount != null) 'componentCount=$componentCount',
      if (contentDisposition != null) 'contentDisposition=$contentDisposition',
      if (contentEncoding != null) 'contentEncoding=$contentEncoding',
      if (contentLanguage != null) 'contentLanguage=$contentLanguage',
      if (contentType != null) 'contentType=$contentType',
      if (crc32C != null) 'crc32c=$crc32C',
      if (etag != null) 'etag=$etag',
      if (eventBasedHold != null) 'eventBasedHold=$eventBasedHold',
      if (generation != null) 'generation=$generation',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (kmsKeyName != null) 'kmsKeyName=$kmsKeyName',
      if (md5Hash != null) 'md5Hash=$md5Hash',
      if (mediaLink != null) 'mediaLink=$mediaLink',
      if (metageneration != null) 'metageneration=$metageneration',
      if (name != null) 'name=$name',
      if (restoreToken != null) 'restoreToken=$restoreToken',
      if (selfLink != null) 'selfLink=$selfLink',
      if (size != null) 'size=$size',
      if (storageClass != null) 'storageClass=$storageClass',
      if (temporaryHold != null) 'temporaryHold=$temporaryHold',
    ].join(',');
    return 'Object($contents)';
  }
}

/// The message type for the `contexts` field.
final class Object$_Contexts extends ProtoMessage {
  static const String fullyQualifiedName = '.Object.contexts';

  /// User-defined object contexts.
  final Map<String, ObjectCustomContextPayload> custom;

  Object$_Contexts({this.custom = const {}}) : super(fullyQualifiedName);

  factory Object$_Contexts.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Object$_Contexts(
      custom: switch (json['custom']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ObjectCustomContextPayload.fromJson(e.value),
        },
        _ => throw const FormatException('"custom" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {if (custom.isNotDefault) 'custom': encodeMap(custom)};

  @override
  String toString() => 'contexts()';
}

/// The message type for the `customerEncryption` field.
final class Object$_CustomerEncryption extends ProtoMessage {
  static const String fullyQualifiedName = '.Object.customerEncryption';

  /// The encryption algorithm.
  final String? encryptionAlgorithm;

  /// SHA256 hash value of the encryption key.
  final String? keySha256;

  Object$_CustomerEncryption({this.encryptionAlgorithm, this.keySha256})
    : super(fullyQualifiedName);

  factory Object$_CustomerEncryption.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Object$_CustomerEncryption(
      encryptionAlgorithm: switch (json['encryptionAlgorithm']) {
        null => null,
        Object $1 => decodeString($1),
      },
      keySha256: switch (json['keySha256']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (encryptionAlgorithm != null) 'encryptionAlgorithm': encryptionAlgorithm,
    if (keySha256 != null) 'keySha256': keySha256,
  };

  @override
  String toString() {
    final contents = [
      if (encryptionAlgorithm != null)
        'encryptionAlgorithm=$encryptionAlgorithm',
      if (keySha256 != null) 'keySha256=$keySha256',
    ].join(',');
    return 'customerEncryption($contents)';
  }
}

/// The message type for the `owner` field.
final class Object$_Owner extends ProtoMessage {
  static const String fullyQualifiedName = '.Object.owner';

  /// The entity, in the form user-userId.
  final String? entity;

  /// The ID for the entity.
  final String? entityId;

  Object$_Owner({this.entity, this.entityId}) : super(fullyQualifiedName);

  factory Object$_Owner.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Object$_Owner(
      entity: switch (json['entity']) {
        null => null,
        Object $1 => decodeString($1),
      },
      entityId: switch (json['entityId']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entity != null) 'entity': entity,
    if (entityId != null) 'entityId': entityId,
  };

  @override
  String toString() {
    final contents = [
      if (entity != null) 'entity=$entity',
      if (entityId != null) 'entityId=$entityId',
    ].join(',');
    return 'owner($contents)';
  }
}

/// The message type for the `retention` field.
final class Object$_Retention extends ProtoMessage {
  static const String fullyQualifiedName = '.Object.retention';

  /// The bucket's object retention mode, can only be Unlocked or Locked.
  final String? mode;

  /// A time in RFC 3339 format until which object retention protects this object.
  final Timestamp? retainUntilTime;

  Object$_Retention({this.mode, this.retainUntilTime})
    : super(fullyQualifiedName);

  factory Object$_Retention.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Object$_Retention(
      mode: switch (json['mode']) {
        null => null,
        Object $1 => decodeString($1),
      },
      retainUntilTime: switch (json['retainUntilTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (mode != null) 'mode': mode,
    if (retainUntilTime != null) 'retainUntilTime': retainUntilTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [if (mode != null) 'mode=$mode'].join(',');
    return 'retention($contents)';
  }
}

/// An access-control entry.
final class ObjectAccessControl extends ProtoMessage {
  static const String fullyQualifiedName = '.ObjectAccessControl';

  /// The name of the bucket.
  final String? bucket;

  /// The domain associated with the entity, if any.
  final String? domain;

  /// The email address associated with the entity, if any.
  final String? email;

  /// The entity holding the permission, in one of the following forms:
  /// - user-userId
  /// - user-email
  /// - group-groupId
  /// - group-email
  /// - domain-domain
  /// - project-team-projectId
  /// - allUsers
  /// - allAuthenticatedUsers Examples:
  /// - The user liz@example.com would be user-liz@example.com.
  /// - The group example@googlegroups.com would be group-example@googlegroups.com.
  /// - To refer to all members of the Google Apps for Business domain example.com, the entity would be domain-example.com.
  final String? entity;

  /// The ID for the entity, if any.
  final String? entityId;

  /// HTTP 1.1 Entity tag for the access-control entry.
  final String? etag;

  /// The content generation of the object, if applied to an object.
  final int? generation;

  /// The ID of the access-control entry.
  final String? id;

  /// The kind of item this is. For object access control entries, this is always storage#objectAccessControl.
  final String? kind;

  /// The name of the object, if applied to an object.
  final String? object;

  /// The project team associated with the entity, if any.
  final ObjectAccessControl_ProjectTeam? projectTeam;

  /// The access permission for the entity.
  final String? role;

  /// The link to this access-control entry.
  final String? selfLink;

  ObjectAccessControl({
    this.bucket,
    this.domain,
    this.email,
    this.entity,
    this.entityId,
    this.etag,
    this.generation,
    this.id,
    this.kind,
    this.object,
    this.projectTeam,
    this.role,
    this.selfLink,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControl.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControl(
      bucket: switch (json['bucket']) {
        null => null,
        Object $1 => decodeString($1),
      },
      domain: switch (json['domain']) {
        null => null,
        Object $1 => decodeString($1),
      },
      email: switch (json['email']) {
        null => null,
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => null,
        Object $1 => decodeString($1),
      },
      entityId: switch (json['entityId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => null,
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      object: switch (json['object']) {
        null => null,
        Object $1 => decodeString($1),
      },
      projectTeam: switch (json['projectTeam']) {
        null => null,
        Object $1 => ObjectAccessControl_ProjectTeam.fromJson($1),
      },
      role: switch (json['role']) {
        null => null,
        Object $1 => decodeString($1),
      },
      selfLink: switch (json['selfLink']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket != null) 'bucket': bucket,
    if (domain != null) 'domain': domain,
    if (email != null) 'email': email,
    if (entity != null) 'entity': entity,
    if (entityId != null) 'entityId': entityId,
    if (etag != null) 'etag': etag,
    if (generation != null) 'generation': encodeInt64(generation),
    if (id != null) 'id': id,
    if (kind != null) 'kind': kind,
    if (object != null) 'object': object,
    if (projectTeam != null) 'projectTeam': projectTeam!.toJson(),
    if (role != null) 'role': role,
    if (selfLink != null) 'selfLink': selfLink,
  };

  @override
  String toString() {
    final contents = [
      if (bucket != null) 'bucket=$bucket',
      if (domain != null) 'domain=$domain',
      if (email != null) 'email=$email',
      if (entity != null) 'entity=$entity',
      if (entityId != null) 'entityId=$entityId',
      if (etag != null) 'etag=$etag',
      if (generation != null) 'generation=$generation',
      if (id != null) 'id=$id',
      if (kind != null) 'kind=$kind',
      if (object != null) 'object=$object',
      if (role != null) 'role=$role',
      if (selfLink != null) 'selfLink=$selfLink',
    ].join(',');
    return 'ObjectAccessControl($contents)';
  }
}

/// The message type for the `projectTeam` field.
final class ObjectAccessControl_ProjectTeam extends ProtoMessage {
  static const String fullyQualifiedName = '.ObjectAccessControl.projectTeam';

  /// The project number.
  final String? projectNumber;

  /// The team.
  final String? team;

  ObjectAccessControl_ProjectTeam({this.projectNumber, this.team})
    : super(fullyQualifiedName);

  factory ObjectAccessControl_ProjectTeam.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControl_ProjectTeam(
      projectNumber: switch (json['projectNumber']) {
        null => null,
        Object $1 => decodeString($1),
      },
      team: switch (json['team']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (projectNumber != null) 'projectNumber': projectNumber,
    if (team != null) 'team': team,
  };

  @override
  String toString() {
    final contents = [
      if (projectNumber != null) 'projectNumber=$projectNumber',
      if (team != null) 'team=$team',
    ].join(',');
    return 'projectTeam($contents)';
  }
}

/// An access-control list.
final class ObjectAccessControls extends ProtoMessage {
  static const String fullyQualifiedName = '.ObjectAccessControls';

  /// The list of items.
  final List<ObjectAccessControl> items;

  /// The kind of item this is. For lists of object access control entries, this is always storage#objectAccessControls.
  final String? kind;

  ObjectAccessControls({this.items = const [], this.kind})
    : super(fullyQualifiedName);

  factory ObjectAccessControls.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControls(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ObjectAccessControl.fromJson(i),
        ],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
  };

  @override
  String toString() {
    final contents = [if (kind != null) 'kind=$kind'].join(',');
    return 'ObjectAccessControls($contents)';
  }
}

/// The payload of a single user-defined object context.
final class ObjectCustomContextPayload extends ProtoMessage {
  static const String fullyQualifiedName = '.ObjectCustomContextPayload';

  /// The time at which the object context was created in RFC 3339 format.
  final Timestamp? createTime;

  /// The time at which the object context was last updated in RFC 3339 format.
  final Timestamp? updateTime;

  /// The value of the object context.
  final String? value;

  ObjectCustomContextPayload({this.createTime, this.updateTime, this.value})
    : super(fullyQualifiedName);

  factory ObjectCustomContextPayload.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectCustomContextPayload(
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      value: switch (json['value']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (value != null) 'value': value,
  };

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'ObjectCustomContextPayload($contents)';
  }
}

/// A list of objects.
final class Objects extends ProtoMessage {
  static const String fullyQualifiedName = '.Objects';

  /// The list of items.
  final List<Object$> items;

  /// The kind of item this is. For lists of objects, this is always storage#objects.
  final String? kind;

  /// The continuation token, used to page through large result sets. Provide this value in a subsequent request to return the next page of results.
  final String? nextPageToken;

  /// The list of prefixes of objects matching-but-not-listed up to and including the requested delimiter.
  final List<String> prefixes;

  Objects({
    this.items = const [],
    this.kind,
    this.nextPageToken,
    this.prefixes = const [],
  }) : super(fullyQualifiedName);

  factory Objects.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects(
      items: switch (json['items']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Object$.fromJson(i)],
        _ => throw const FormatException('"items" is not a list'),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      prefixes: switch (json['prefixes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"prefixes" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (items.isNotDefault) 'items': encodeList(items),
    if (kind != null) 'kind': kind,
    if (nextPageToken != null) 'nextPageToken': nextPageToken,
    if (prefixes.isNotDefault) 'prefixes': prefixes,
  };

  @override
  String toString() {
    final contents = [
      if (kind != null) 'kind=$kind',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'Objects($contents)';
  }
}

/// A bucket/object/managedFolder IAM policy.
final class Policy extends ProtoMessage {
  static const String fullyQualifiedName = '.Policy';

  /// An association between a role, which comes with a set of permissions, and members who may assume that role.
  final List<Policy_Bindings> bindings;

  /// HTTP 1.1  Entity tag for the policy.
  final Uint8List? etag;

  /// The kind of item this is. For policies, this is always storage#policy. This field is ignored on input.
  final String? kind;

  /// The ID of the resource to which this policy belongs. Will be of the form projects/_/buckets/bucket for buckets, projects/_/buckets/bucket/objects/object for objects, and projects/_/buckets/bucket/managedFolders/managedFolder. A specific generation may be specified by appending #generationNumber to the end of the object name, e.g. projects/_/buckets/my-bucket/objects/data.txt#17. The current generation can be denoted with #0. This field is ignored on input.
  final String? resourceId;

  /// The IAM policy format version.
  final int? version;

  Policy({
    this.bindings = const [],
    this.etag,
    this.kind,
    this.resourceId,
    this.version,
  }) : super(fullyQualifiedName);

  factory Policy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Policy(
      bindings: switch (json['bindings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Policy_Bindings.fromJson(i)],
        _ => throw const FormatException('"bindings" is not a list'),
      },
      etag: switch (json['etag']) {
        null => null,
        Object $1 => decodeBytes($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      resourceId: switch (json['resourceId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      version: switch (json['version']) {
        null => null,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bindings.isNotDefault) 'bindings': encodeList(bindings),
    if (etag != null) 'etag': encodeBytes(etag),
    if (kind != null) 'kind': kind,
    if (resourceId != null) 'resourceId': resourceId,
    if (version != null) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      if (etag != null) 'etag=$etag',
      if (kind != null) 'kind=$kind',
      if (resourceId != null) 'resourceId=$resourceId',
      if (version != null) 'version=$version',
    ].join(',');
    return 'Policy($contents)';
  }
}

/// The message type for the `bindings` field.
final class Policy_Bindings extends ProtoMessage {
  static const String fullyQualifiedName = '.Policy.bindings';

  /// The condition that is associated with this binding. NOTE: an unsatisfied condition will not allow user access via current binding. Different bindings, including their conditions, are examined independently.
  final Expr? condition;

  /// A collection of identifiers for members who may assume the provided role. Recognized identifiers are as follows:
  /// - allUsers - A special identifier that represents anyone on the internet; with or without a Google account.
  /// - allAuthenticatedUsers - A special identifier that represents anyone who is authenticated with a Google account or a service account.
  /// - user:emailid - An email address that represents a specific account. For example, user:alice@gmail.com or user:joe@example.com.
  /// - serviceAccount:emailid - An email address that represents a service account. For example,  serviceAccount:my-other-app@appspot.gserviceaccount.com .
  /// - group:emailid - An email address that represents a Google group. For example, group:admins@example.com.
  /// - domain:domain - A Google Apps domain name that represents all the users of that domain. For example, domain:google.com or domain:example.com.
  /// - projectOwner:projectid - Owners of the given project. For example, projectOwner:my-example-project
  /// - projectEditor:projectid - Editors of the given project. For example, projectEditor:my-example-project
  /// - projectViewer:projectid - Viewers of the given project. For example, projectViewer:my-example-project
  final List<String> members;

  /// The role to which members belong. Two types of roles are supported: new IAM roles, which grant permissions that do not map directly to those provided by ACLs, and legacy IAM roles, which do map directly to ACL permissions. All roles are of the format roles/storage.specificRole.
  /// The new IAM roles are:
  /// - roles/storage.admin - Full control of Google Cloud Storage resources.
  /// - roles/storage.objectViewer - Read-Only access to Google Cloud Storage objects.
  /// - roles/storage.objectCreator - Access to create objects in Google Cloud Storage.
  /// - roles/storage.objectAdmin - Full control of Google Cloud Storage objects.   The legacy IAM roles are:
  /// - roles/storage.legacyObjectReader - Read-only access to objects without listing. Equivalent to an ACL entry on an object with the READER role.
  /// - roles/storage.legacyObjectOwner - Read/write access to existing objects without listing. Equivalent to an ACL entry on an object with the OWNER role.
  /// - roles/storage.legacyBucketReader - Read access to buckets with object listing. Equivalent to an ACL entry on a bucket with the READER role.
  /// - roles/storage.legacyBucketWriter - Read access to buckets with object listing/creation/deletion. Equivalent to an ACL entry on a bucket with the WRITER role.
  /// - roles/storage.legacyBucketOwner - Read and write access to existing buckets with object listing/creation/deletion. Equivalent to an ACL entry on a bucket with the OWNER role.
  final String? role;

  Policy_Bindings({this.condition, this.members = const [], this.role})
    : super(fullyQualifiedName);

  factory Policy_Bindings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Policy_Bindings(
      condition: switch (json['condition']) {
        null => null,
        Object $1 => Expr.fromJson($1),
      },
      members: switch (json['members']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"members" is not a list'),
      },
      role: switch (json['role']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (condition != null) 'condition': condition!.toJson(),
    if (members.isNotDefault) 'members': members,
    if (role != null) 'role': role,
  };

  @override
  String toString() {
    final contents = [if (role != null) 'role=$role'].join(',');
    return 'bindings($contents)';
  }
}

/// A Relocate Bucket request.
final class RelocateBucketRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.RelocateBucketRequest';

  /// The bucket's new custom placement configuration if relocating to a Custom Dual Region.
  final RelocateBucketRequest_DestinationCustomPlacementConfig?
  destinationCustomPlacementConfig;

  /// The new location the bucket will be relocated to.
  final String? destinationLocation;

  /// If true, validate the operation, but do not actually relocate the bucket.
  final bool? validateOnly;

  RelocateBucketRequest({
    this.destinationCustomPlacementConfig,
    this.destinationLocation,
    this.validateOnly,
  }) : super(fullyQualifiedName);

  factory RelocateBucketRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RelocateBucketRequest(
      destinationCustomPlacementConfig:
          switch (json['destinationCustomPlacementConfig']) {
            null => null,
            Object $1 =>
              RelocateBucketRequest_DestinationCustomPlacementConfig.fromJson(
                $1,
              ),
          },
      destinationLocation: switch (json['destinationLocation']) {
        null => null,
        Object $1 => decodeString($1),
      },
      validateOnly: switch (json['validateOnly']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (destinationCustomPlacementConfig != null)
      'destinationCustomPlacementConfig': destinationCustomPlacementConfig!
          .toJson(),
    if (destinationLocation != null) 'destinationLocation': destinationLocation,
    if (validateOnly != null) 'validateOnly': validateOnly,
  };

  @override
  String toString() {
    final contents = [
      if (destinationLocation != null)
        'destinationLocation=$destinationLocation',
      if (validateOnly != null) 'validateOnly=$validateOnly',
    ].join(',');
    return 'RelocateBucketRequest($contents)';
  }
}

/// The message type for the `destinationCustomPlacementConfig` field.
final class RelocateBucketRequest_DestinationCustomPlacementConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      '.RelocateBucketRequest.destinationCustomPlacementConfig';

  /// The list of regional locations in which data is placed.
  final List<String> dataLocations;

  RelocateBucketRequest_DestinationCustomPlacementConfig({
    this.dataLocations = const [],
  }) : super(fullyQualifiedName);

  factory RelocateBucketRequest_DestinationCustomPlacementConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return RelocateBucketRequest_DestinationCustomPlacementConfig(
      dataLocations: switch (json['dataLocations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"dataLocations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataLocations.isNotDefault) 'dataLocations': dataLocations,
  };

  @override
  String toString() => 'destinationCustomPlacementConfig()';
}

/// A rewrite response.
final class RewriteResponse extends ProtoMessage {
  static const String fullyQualifiedName = '.RewriteResponse';

  /// true if the copy is finished; otherwise, false if the copy is in progress. This property is always present in the response.
  final bool? done;

  /// The kind of item this is.
  final String? kind;

  /// The total size of the object being copied in bytes. This property is always present in the response.
  final int? objectSize;

  /// A resource containing the metadata for the copied-to object. This property is present in the response only when copying completes.
  final Object$? resource;

  /// A token to use in subsequent requests to continue copying data. This token is present in the response only when there is more data to copy.
  final String? rewriteToken;

  /// The total bytes written so far, which can be used to provide a waiting user with a progress indicator. This property is always present in the response.
  final int? totalBytesRewritten;

  RewriteResponse({
    this.done,
    this.kind,
    this.objectSize,
    this.resource,
    this.rewriteToken,
    this.totalBytesRewritten,
  }) : super(fullyQualifiedName);

  factory RewriteResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RewriteResponse(
      done: switch (json['done']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      objectSize: switch (json['objectSize']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      resource: switch (json['resource']) {
        null => null,
        Object $1 => Object$.fromJson($1),
      },
      rewriteToken: switch (json['rewriteToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      totalBytesRewritten: switch (json['totalBytesRewritten']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (done != null) 'done': done,
    if (kind != null) 'kind': kind,
    if (objectSize != null) 'objectSize': encodeInt64(objectSize),
    if (resource != null) 'resource': resource!.toJson(),
    if (rewriteToken != null) 'rewriteToken': rewriteToken,
    if (totalBytesRewritten != null)
      'totalBytesRewritten': encodeInt64(totalBytesRewritten),
  };

  @override
  String toString() {
    final contents = [
      if (done != null) 'done=$done',
      if (kind != null) 'kind=$kind',
      if (objectSize != null) 'objectSize=$objectSize',
      if (rewriteToken != null) 'rewriteToken=$rewriteToken',
      if (totalBytesRewritten != null)
        'totalBytesRewritten=$totalBytesRewritten',
    ].join(',');
    return 'RewriteResponse($contents)';
  }
}

/// A subscription to receive Google PubSub notifications.
final class ServiceAccount extends ProtoMessage {
  static const String fullyQualifiedName = '.ServiceAccount';

  /// The ID of the notification.
  final String? emailAddress;

  /// The kind of item this is. For notifications, this is always storage#notification.
  final String? kind;

  ServiceAccount({this.emailAddress, this.kind}) : super(fullyQualifiedName);

  factory ServiceAccount.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ServiceAccount(
      emailAddress: switch (json['email_address']) {
        null => null,
        Object $1 => decodeString($1),
      },
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (emailAddress != null) 'email_address': emailAddress,
    if (kind != null) 'kind': kind,
  };

  @override
  String toString() {
    final contents = [
      if (emailAddress != null) 'email_address=$emailAddress',
      if (kind != null) 'kind=$kind',
    ].join(',');
    return 'ServiceAccount($contents)';
  }
}

/// A storage.(buckets|objects|managedFolders).testIamPermissions response.
final class TestIamPermissionsResponse extends ProtoMessage {
  static const String fullyQualifiedName = '.TestIamPermissionsResponse';

  /// The kind of item this is.
  final String? kind;

  /// The permissions held by the caller. Permissions are always of the format storage.resource.capability, where resource is one of buckets, objects, or managedFolders. The supported permissions are as follows:
  /// - storage.buckets.delete - Delete bucket.
  /// - storage.buckets.get - Read bucket metadata.
  /// - storage.buckets.getIamPolicy - Read bucket IAM policy.
  /// - storage.buckets.create - Create bucket.
  /// - storage.buckets.list - List buckets.
  /// - storage.buckets.setIamPolicy - Update bucket IAM policy.
  /// - storage.buckets.update - Update bucket metadata.
  /// - storage.objects.delete - Delete object.
  /// - storage.objects.get - Read object data and metadata.
  /// - storage.objects.getIamPolicy - Read object IAM policy.
  /// - storage.objects.create - Create object.
  /// - storage.objects.list - List objects.
  /// - storage.objects.setIamPolicy - Update object IAM policy.
  /// - storage.objects.update - Update object metadata.
  /// - storage.managedFolders.delete - Delete managed folder.
  /// - storage.managedFolders.get - Read managed folder metadata.
  /// - storage.managedFolders.getIamPolicy - Read managed folder IAM policy.
  /// - storage.managedFolders.create - Create managed folder.
  /// - storage.managedFolders.list - List managed folders.
  /// - storage.managedFolders.setIamPolicy - Update managed folder IAM policy.
  final List<String> permissions;

  TestIamPermissionsResponse({this.kind, this.permissions = const []})
    : super(fullyQualifiedName);

  factory TestIamPermissionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TestIamPermissionsResponse(
      kind: switch (json['kind']) {
        null => null,
        Object $1 => decodeString($1),
      },
      permissions: switch (json['permissions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"permissions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (kind != null) 'kind': kind,
    if (permissions.isNotDefault) 'permissions': permissions,
  };

  @override
  String toString() {
    final contents = [if (kind != null) 'kind=$kind'].join(',');
    return 'TestIamPermissionsResponse($contents)';
  }
}

/// Synthetic messages for the `anywhereCaches` service
final class AnywhereCaches extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches';

  AnywhereCaches() : super(fullyQualifiedName);

  factory AnywhereCaches.fromJson(Object? j) => AnywhereCaches();

  @override
  Object toJson() => {};

  @override
  String toString() => 'anywhereCaches()';
}

/// Synthetic request message for the [disable()][.anywhereCaches.disable] method.
final class AnywhereCaches_DisableRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches.disableRequest';

  /// The ID of requested Anywhere Cache instance.
  final String anywhereCacheId;

  /// Name of the parent bucket.
  final String bucket;

  AnywhereCaches_DisableRequest({this.anywhereCacheId = '', this.bucket = ''})
    : super(fullyQualifiedName);

  factory AnywhereCaches_DisableRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches_DisableRequest(
      anywhereCacheId: switch (json['anywhereCacheId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (anywhereCacheId.isNotDefault) 'anywhereCacheId': anywhereCacheId,
    if (bucket.isNotDefault) 'bucket': bucket,
  };

  @override
  String toString() {
    final contents = [
      'anywhereCacheId=$anywhereCacheId',
      'bucket=$bucket',
    ].join(',');
    return 'disableRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.anywhereCaches.get] method.
final class AnywhereCaches_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches.getRequest';

  /// The ID of requested Anywhere Cache instance.
  final String anywhereCacheId;

  /// Name of the parent bucket.
  final String bucket;

  AnywhereCaches_GetRequest({this.anywhereCacheId = '', this.bucket = ''})
    : super(fullyQualifiedName);

  factory AnywhereCaches_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches_GetRequest(
      anywhereCacheId: switch (json['anywhereCacheId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (anywhereCacheId.isNotDefault) 'anywhereCacheId': anywhereCacheId,
    if (bucket.isNotDefault) 'bucket': bucket,
  };

  @override
  String toString() {
    final contents = [
      'anywhereCacheId=$anywhereCacheId',
      'bucket=$bucket',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.anywhereCaches.insert] method.
final class AnywhereCaches_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches.insertRequest';

  /// Name of the parent bucket.
  final String bucket;

  /// Synthetic request body field for the [insert()][.anywhereCaches.insert] method.
  final AnywhereCache? body;

  AnywhereCaches_InsertRequest({this.bucket = '', this.body})
    : super(fullyQualifiedName);

  factory AnywhereCaches_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches_InsertRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => AnywhereCache.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = ['bucket=$bucket'].join(',');
    return 'insertRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.anywhereCaches.list] method.
final class AnywhereCaches_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches.listRequest';

  /// Name of the parent bucket.
  final String bucket;

  /// Maximum number of items to return in a single page of responses. Maximum 1000.
  final int? pageSize;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  AnywhereCaches_ListRequest({this.bucket = '', this.pageSize, this.pageToken})
    : super(fullyQualifiedName);

  factory AnywhereCaches_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (pageSize != null) 'pageSize': pageSize,
    if (pageToken != null) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic request message for the [pause()][.anywhereCaches.pause] method.
final class AnywhereCaches_PauseRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches.pauseRequest';

  /// The ID of requested Anywhere Cache instance.
  final String anywhereCacheId;

  /// Name of the parent bucket.
  final String bucket;

  AnywhereCaches_PauseRequest({this.anywhereCacheId = '', this.bucket = ''})
    : super(fullyQualifiedName);

  factory AnywhereCaches_PauseRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches_PauseRequest(
      anywhereCacheId: switch (json['anywhereCacheId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (anywhereCacheId.isNotDefault) 'anywhereCacheId': anywhereCacheId,
    if (bucket.isNotDefault) 'bucket': bucket,
  };

  @override
  String toString() {
    final contents = [
      'anywhereCacheId=$anywhereCacheId',
      'bucket=$bucket',
    ].join(',');
    return 'pauseRequest($contents)';
  }
}

/// Synthetic request message for the [resume()][.anywhereCaches.resume] method.
final class AnywhereCaches_ResumeRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches.resumeRequest';

  /// The ID of requested Anywhere Cache instance.
  final String anywhereCacheId;

  /// Name of the parent bucket.
  final String bucket;

  AnywhereCaches_ResumeRequest({this.anywhereCacheId = '', this.bucket = ''})
    : super(fullyQualifiedName);

  factory AnywhereCaches_ResumeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches_ResumeRequest(
      anywhereCacheId: switch (json['anywhereCacheId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (anywhereCacheId.isNotDefault) 'anywhereCacheId': anywhereCacheId,
    if (bucket.isNotDefault) 'bucket': bucket,
  };

  @override
  String toString() {
    final contents = [
      'anywhereCacheId=$anywhereCacheId',
      'bucket=$bucket',
    ].join(',');
    return 'resumeRequest($contents)';
  }
}

/// Synthetic request message for the [update()][.anywhereCaches.update] method.
final class AnywhereCaches_UpdateRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.anywhereCaches.updateRequest';

  /// The ID of requested Anywhere Cache instance.
  final String anywhereCacheId;

  /// Name of the parent bucket.
  final String bucket;

  /// Synthetic request body field for the [update()][.anywhereCaches.update] method.
  final AnywhereCache? body;

  AnywhereCaches_UpdateRequest({
    this.anywhereCacheId = '',
    this.bucket = '',
    this.body,
  }) : super(fullyQualifiedName);

  factory AnywhereCaches_UpdateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnywhereCaches_UpdateRequest(
      anywhereCacheId: switch (json['anywhereCacheId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => AnywhereCache.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (anywhereCacheId.isNotDefault) 'anywhereCacheId': anywhereCacheId,
    if (bucket.isNotDefault) 'bucket': bucket,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'anywhereCacheId=$anywhereCacheId',
      'bucket=$bucket',
    ].join(',');
    return 'updateRequest($contents)';
  }
}

/// Synthetic messages for the `bucketAccessControls` service
final class BucketAccessControls extends ProtoMessage {
  static const String fullyQualifiedName = '.bucketAccessControls';

  BucketAccessControls() : super(fullyQualifiedName);

  factory BucketAccessControls.fromJson(Object? j) => BucketAccessControls();

  @override
  Object toJson() => {};

  @override
  String toString() => 'bucketAccessControls()';
}

/// Synthetic request message for the [delete()][.bucketAccessControls.delete] method.
final class BucketAccessControls_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.bucketAccessControls.deleteRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  BucketAccessControls_DeleteRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory BucketAccessControls_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControls_DeleteRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.bucketAccessControls.get] method.
final class BucketAccessControls_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.bucketAccessControls.getRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  BucketAccessControls_GetRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory BucketAccessControls_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControls_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.bucketAccessControls.insert] method.
final class BucketAccessControls_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.bucketAccessControls.insertRequest';

  /// Name of a bucket.
  final String bucket;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [insert()][.bucketAccessControls.insert] method.
  final BucketAccessControl? body;

  BucketAccessControls_InsertRequest({
    this.bucket = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory BucketAccessControls_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControls_InsertRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => BucketAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'insertRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.bucketAccessControls.list] method.
final class BucketAccessControls_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.bucketAccessControls.listRequest';

  /// Name of a bucket.
  final String bucket;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  BucketAccessControls_ListRequest({this.bucket = '', this.userProject})
    : super(fullyQualifiedName);

  factory BucketAccessControls_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControls_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic request message for the [patch()][.bucketAccessControls.patch] method.
final class BucketAccessControls_PatchRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.bucketAccessControls.patchRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [patch()][.bucketAccessControls.patch] method.
  final BucketAccessControl? body;

  BucketAccessControls_PatchRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory BucketAccessControls_PatchRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControls_PatchRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => BucketAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'patchRequest($contents)';
  }
}

/// Synthetic request message for the [update()][.bucketAccessControls.update] method.
final class BucketAccessControls_UpdateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.bucketAccessControls.updateRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [update()][.bucketAccessControls.update] method.
  final BucketAccessControl? body;

  BucketAccessControls_UpdateRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory BucketAccessControls_UpdateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BucketAccessControls_UpdateRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => BucketAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'updateRequest($contents)';
  }
}

/// Synthetic messages for the `buckets` service
final class Buckets extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets';

  Buckets() : super(fullyQualifiedName);

  factory Buckets.fromJson(Object? j) => Buckets();

  @override
  Object toJson() => {};

  @override
  String toString() => 'buckets()';
}

/// Synthetic request message for the [delete()][.buckets.delete] method.
final class Buckets_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.deleteRequest';

  /// Name of a bucket.
  final String bucket;

  /// If set, only deletes the bucket if its metageneration matches this value.
  final int? ifMetagenerationMatch;

  /// If set, only deletes the bucket if its metageneration does not match this value.
  final int? ifMetagenerationNotMatch;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Buckets_DeleteRequest({
    this.bucket = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Buckets_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_DeleteRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.buckets.get] method.
final class Buckets_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.getRequest';

  /// Name of a bucket.
  final String bucket;

  /// If present, specifies the generation of the bucket. This is required if softDeleted is true.
  final int? generation;

  /// Makes the return of the bucket metadata conditional on whether the bucket's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the return of the bucket metadata conditional on whether the bucket's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Set of properties to return. Defaults to noAcl.
  final Buckets_GetRequest_Projection? projection;

  /// If true, return the soft-deleted version of this bucket. The default is false. For more information, see [Soft Delete](https://cloud.google.com/storage/docs/soft-delete).
  final bool? softDeleted;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Buckets_GetRequest({
    this.bucket = '',
    this.generation,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.projection,
    this.softDeleted,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Buckets_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Buckets_GetRequest_Projection.fromJson($1),
      },
      softDeleted: switch (json['softDeleted']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (projection != null) 'projection': projection!.toJson(),
    if (softDeleted != null) 'softDeleted': softDeleted,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (projection != null) 'projection=$projection',
      if (softDeleted != null) 'softDeleted=$softDeleted',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Buckets_GetRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Buckets_GetRequest_Projection('full');

  /// Omit owner, acl and defaultObjectAcl properties.
  static const noAcl = Buckets_GetRequest_Projection('noAcl');

  /// The default value for [Buckets_GetRequest_Projection].
  static const $default = full;

  const Buckets_GetRequest_Projection(super.value);

  factory Buckets_GetRequest_Projection.fromJson(Object? json) =>
      Buckets_GetRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [getIamPolicy()][.buckets.getIamPolicy] method.
final class Buckets_GetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.getIamPolicyRequest';

  /// Name of a bucket.
  final String bucket;

  /// The IAM policy format version to be returned. If the optionsRequestedPolicyVersion is for an older version that doesn't support part of the requested IAM policy, the request fails.
  final int? optionsRequestedPolicyVersion;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Buckets_GetIamPolicyRequest({
    this.bucket = '',
    this.optionsRequestedPolicyVersion,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Buckets_GetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_GetIamPolicyRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      optionsRequestedPolicyVersion:
          switch (json['optionsRequestedPolicyVersion']) {
            null => null,
            Object $1 => decodeInt($1),
          },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (optionsRequestedPolicyVersion != null)
      'optionsRequestedPolicyVersion': optionsRequestedPolicyVersion,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion=$optionsRequestedPolicyVersion',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getIamPolicyRequest($contents)';
  }
}

/// Synthetic request message for the [getStorageLayout()][.buckets.getStorageLayout] method.
final class Buckets_GetStorageLayoutRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.getStorageLayoutRequest';

  /// Name of a bucket.
  final String bucket;

  /// An optional prefix used for permission check. It is useful when the caller only has storage.objects.list permission under a specific prefix.
  final String? prefix;

  Buckets_GetStorageLayoutRequest({this.bucket = '', this.prefix})
    : super(fullyQualifiedName);

  factory Buckets_GetStorageLayoutRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_GetStorageLayoutRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      prefix: switch (json['prefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (prefix != null) 'prefix': prefix,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (prefix != null) 'prefix=$prefix',
    ].join(',');
    return 'getStorageLayoutRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.buckets.insert] method.
final class Buckets_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.insertRequest';

  /// When set to true, object retention is enabled for this bucket.
  final bool? enableObjectRetention;

  /// Apply a predefined set of access controls to this bucket.
  final Buckets_InsertRequest_PredefinedAcl? predefinedAcl;

  /// Apply a predefined set of default object access controls to this bucket.
  final Buckets_InsertRequest_PredefinedDefaultObjectAcl?
  predefinedDefaultObjectAcl;

  /// A valid API project identifier.
  final String project;

  /// Set of properties to return. Defaults to noAcl, unless the bucket resource specifies acl or defaultObjectAcl properties, when it defaults to full.
  final Buckets_InsertRequest_Projection? projection;

  /// The project to be billed for this request.
  final String? userProject;

  /// Synthetic request body field for the [insert()][.buckets.insert] method.
  final Bucket? body;

  Buckets_InsertRequest({
    this.enableObjectRetention,
    this.predefinedAcl,
    this.predefinedDefaultObjectAcl,
    this.project = '',
    this.projection,
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Buckets_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_InsertRequest(
      enableObjectRetention: switch (json['enableObjectRetention']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      predefinedAcl: switch (json['predefinedAcl']) {
        null => null,
        Object $1 => Buckets_InsertRequest_PredefinedAcl.fromJson($1),
      },
      predefinedDefaultObjectAcl: switch (json['predefinedDefaultObjectAcl']) {
        null => null,
        Object $1 => Buckets_InsertRequest_PredefinedDefaultObjectAcl.fromJson(
          $1,
        ),
      },
      project: switch (json['project']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Buckets_InsertRequest_Projection.fromJson($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Bucket.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enableObjectRetention != null)
      'enableObjectRetention': enableObjectRetention,
    if (predefinedAcl != null) 'predefinedAcl': predefinedAcl!.toJson(),
    if (predefinedDefaultObjectAcl != null)
      'predefinedDefaultObjectAcl': predefinedDefaultObjectAcl!.toJson(),
    if (project.isNotDefault) 'project': project,
    if (projection != null) 'projection': projection!.toJson(),
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (enableObjectRetention != null)
        'enableObjectRetention=$enableObjectRetention',
      if (predefinedAcl != null) 'predefinedAcl=$predefinedAcl',
      if (predefinedDefaultObjectAcl != null)
        'predefinedDefaultObjectAcl=$predefinedDefaultObjectAcl',
      'project=$project',
      if (projection != null) 'projection=$projection',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'insertRequest($contents)';
  }
}

/// The enumerated type for the `predefinedAcl` field.
final class Buckets_InsertRequest_PredefinedAcl extends ProtoEnum {
  /// Project team owners get OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead = Buckets_InsertRequest_PredefinedAcl(
    'authenticatedRead',
  );

  /// Project team owners get OWNER access.
  static const private = Buckets_InsertRequest_PredefinedAcl('private');

  /// Project team members get access according to their roles.
  static const projectPrivate = Buckets_InsertRequest_PredefinedAcl(
    'projectPrivate',
  );

  /// Project team owners get OWNER access, and allUsers get READER access.
  static const publicRead = Buckets_InsertRequest_PredefinedAcl('publicRead');

  /// Project team owners get OWNER access, and allUsers get WRITER access.
  static const publicReadWrite = Buckets_InsertRequest_PredefinedAcl(
    'publicReadWrite',
  );

  /// The default value for [Buckets_InsertRequest_PredefinedAcl].
  static const $default = authenticatedRead;

  const Buckets_InsertRequest_PredefinedAcl(super.value);

  factory Buckets_InsertRequest_PredefinedAcl.fromJson(Object? json) =>
      Buckets_InsertRequest_PredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedAcl.$value';
}

/// The enumerated type for the `predefinedDefaultObjectAcl` field.
final class Buckets_InsertRequest_PredefinedDefaultObjectAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead =
      Buckets_InsertRequest_PredefinedDefaultObjectAcl('authenticatedRead');

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl =
      Buckets_InsertRequest_PredefinedDefaultObjectAcl(
        'bucketOwnerFullControl',
      );

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead =
      Buckets_InsertRequest_PredefinedDefaultObjectAcl('bucketOwnerRead');

  /// Object owner gets OWNER access.
  static const private = Buckets_InsertRequest_PredefinedDefaultObjectAcl(
    'private',
  );

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate =
      Buckets_InsertRequest_PredefinedDefaultObjectAcl('projectPrivate');

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Buckets_InsertRequest_PredefinedDefaultObjectAcl(
    'publicRead',
  );

  /// The default value for [Buckets_InsertRequest_PredefinedDefaultObjectAcl].
  static const $default = authenticatedRead;

  const Buckets_InsertRequest_PredefinedDefaultObjectAcl(super.value);

  factory Buckets_InsertRequest_PredefinedDefaultObjectAcl.fromJson(
    Object? json,
  ) => Buckets_InsertRequest_PredefinedDefaultObjectAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedDefaultObjectAcl.$value';
}

/// The enumerated type for the `projection` field.
final class Buckets_InsertRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Buckets_InsertRequest_Projection('full');

  /// Omit owner, acl and defaultObjectAcl properties.
  static const noAcl = Buckets_InsertRequest_Projection('noAcl');

  /// The default value for [Buckets_InsertRequest_Projection].
  static const $default = full;

  const Buckets_InsertRequest_Projection(super.value);

  factory Buckets_InsertRequest_Projection.fromJson(Object? json) =>
      Buckets_InsertRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [list()][.buckets.list] method.
final class Buckets_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.listRequest';

  /// Maximum number of buckets to return in a single response. The service will use this parameter or 1,000 items, whichever is smaller.
  final int? maxResults;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  /// Filter results to buckets whose names begin with this prefix.
  final String? prefix;

  /// A valid API project identifier.
  final String project;

  /// Set of properties to return. Defaults to noAcl.
  final Buckets_ListRequest_Projection? projection;

  /// If true, only soft-deleted bucket versions will be returned. The default is false. For more information, see [Soft Delete](https://cloud.google.com/storage/docs/soft-delete).
  final bool? softDeleted;

  /// The project to be billed for this request.
  final String? userProject;

  Buckets_ListRequest({
    this.maxResults,
    this.pageToken,
    this.prefix,
    this.project = '',
    this.projection,
    this.softDeleted,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Buckets_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_ListRequest(
      maxResults: switch (json['maxResults']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      prefix: switch (json['prefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
      project: switch (json['project']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Buckets_ListRequest_Projection.fromJson($1),
      },
      softDeleted: switch (json['softDeleted']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxResults != null) 'maxResults': maxResults,
    if (pageToken != null) 'pageToken': pageToken,
    if (prefix != null) 'prefix': prefix,
    if (project.isNotDefault) 'project': project,
    if (projection != null) 'projection': projection!.toJson(),
    if (softDeleted != null) 'softDeleted': softDeleted,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      if (maxResults != null) 'maxResults=$maxResults',
      if (pageToken != null) 'pageToken=$pageToken',
      if (prefix != null) 'prefix=$prefix',
      'project=$project',
      if (projection != null) 'projection=$projection',
      if (softDeleted != null) 'softDeleted=$softDeleted',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Buckets_ListRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Buckets_ListRequest_Projection('full');

  /// Omit owner, acl and defaultObjectAcl properties.
  static const noAcl = Buckets_ListRequest_Projection('noAcl');

  /// The default value for [Buckets_ListRequest_Projection].
  static const $default = full;

  const Buckets_ListRequest_Projection(super.value);

  factory Buckets_ListRequest_Projection.fromJson(Object? json) =>
      Buckets_ListRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [lockRetentionPolicy()][.buckets.lockRetentionPolicy] method.
final class Buckets_LockRetentionPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.buckets.lockRetentionPolicyRequest';

  /// Name of a bucket.
  final String bucket;

  /// Makes the operation conditional on whether bucket's current metageneration matches the given value.
  final int ifMetagenerationMatch;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Buckets_LockRetentionPolicyRequest({
    this.bucket = '',
    this.ifMetagenerationMatch = 0,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Buckets_LockRetentionPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_LockRetentionPolicyRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (ifMetagenerationMatch.isNotDefault)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'lockRetentionPolicyRequest($contents)';
  }
}

/// Synthetic request message for the [patch()][.buckets.patch] method.
final class Buckets_PatchRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.patchRequest';

  /// Name of a bucket.
  final String bucket;

  /// Makes the return of the bucket metadata conditional on whether the bucket's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the return of the bucket metadata conditional on whether the bucket's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Apply a predefined set of access controls to this bucket.
  final Buckets_PatchRequest_PredefinedAcl? predefinedAcl;

  /// Apply a predefined set of default object access controls to this bucket.
  final Buckets_PatchRequest_PredefinedDefaultObjectAcl?
  predefinedDefaultObjectAcl;

  /// Set of properties to return. Defaults to full.
  final Buckets_PatchRequest_Projection? projection;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [patch()][.buckets.patch] method.
  final Bucket? body;

  Buckets_PatchRequest({
    this.bucket = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.predefinedAcl,
    this.predefinedDefaultObjectAcl,
    this.projection,
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Buckets_PatchRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_PatchRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      predefinedAcl: switch (json['predefinedAcl']) {
        null => null,
        Object $1 => Buckets_PatchRequest_PredefinedAcl.fromJson($1),
      },
      predefinedDefaultObjectAcl: switch (json['predefinedDefaultObjectAcl']) {
        null => null,
        Object $1 => Buckets_PatchRequest_PredefinedDefaultObjectAcl.fromJson(
          $1,
        ),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Buckets_PatchRequest_Projection.fromJson($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Bucket.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (predefinedAcl != null) 'predefinedAcl': predefinedAcl!.toJson(),
    if (predefinedDefaultObjectAcl != null)
      'predefinedDefaultObjectAcl': predefinedDefaultObjectAcl!.toJson(),
    if (projection != null) 'projection': projection!.toJson(),
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (predefinedAcl != null) 'predefinedAcl=$predefinedAcl',
      if (predefinedDefaultObjectAcl != null)
        'predefinedDefaultObjectAcl=$predefinedDefaultObjectAcl',
      if (projection != null) 'projection=$projection',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'patchRequest($contents)';
  }
}

/// The enumerated type for the `predefinedAcl` field.
final class Buckets_PatchRequest_PredefinedAcl extends ProtoEnum {
  /// Project team owners get OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead = Buckets_PatchRequest_PredefinedAcl(
    'authenticatedRead',
  );

  /// Project team owners get OWNER access.
  static const private = Buckets_PatchRequest_PredefinedAcl('private');

  /// Project team members get access according to their roles.
  static const projectPrivate = Buckets_PatchRequest_PredefinedAcl(
    'projectPrivate',
  );

  /// Project team owners get OWNER access, and allUsers get READER access.
  static const publicRead = Buckets_PatchRequest_PredefinedAcl('publicRead');

  /// Project team owners get OWNER access, and allUsers get WRITER access.
  static const publicReadWrite = Buckets_PatchRequest_PredefinedAcl(
    'publicReadWrite',
  );

  /// The default value for [Buckets_PatchRequest_PredefinedAcl].
  static const $default = authenticatedRead;

  const Buckets_PatchRequest_PredefinedAcl(super.value);

  factory Buckets_PatchRequest_PredefinedAcl.fromJson(Object? json) =>
      Buckets_PatchRequest_PredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedAcl.$value';
}

/// The enumerated type for the `predefinedDefaultObjectAcl` field.
final class Buckets_PatchRequest_PredefinedDefaultObjectAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead =
      Buckets_PatchRequest_PredefinedDefaultObjectAcl('authenticatedRead');

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl =
      Buckets_PatchRequest_PredefinedDefaultObjectAcl('bucketOwnerFullControl');

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead =
      Buckets_PatchRequest_PredefinedDefaultObjectAcl('bucketOwnerRead');

  /// Object owner gets OWNER access.
  static const private = Buckets_PatchRequest_PredefinedDefaultObjectAcl(
    'private',
  );

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate = Buckets_PatchRequest_PredefinedDefaultObjectAcl(
    'projectPrivate',
  );

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Buckets_PatchRequest_PredefinedDefaultObjectAcl(
    'publicRead',
  );

  /// The default value for [Buckets_PatchRequest_PredefinedDefaultObjectAcl].
  static const $default = authenticatedRead;

  const Buckets_PatchRequest_PredefinedDefaultObjectAcl(super.value);

  factory Buckets_PatchRequest_PredefinedDefaultObjectAcl.fromJson(
    Object? json,
  ) => Buckets_PatchRequest_PredefinedDefaultObjectAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedDefaultObjectAcl.$value';
}

/// The enumerated type for the `projection` field.
final class Buckets_PatchRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Buckets_PatchRequest_Projection('full');

  /// Omit owner, acl and defaultObjectAcl properties.
  static const noAcl = Buckets_PatchRequest_Projection('noAcl');

  /// The default value for [Buckets_PatchRequest_Projection].
  static const $default = full;

  const Buckets_PatchRequest_Projection(super.value);

  factory Buckets_PatchRequest_Projection.fromJson(Object? json) =>
      Buckets_PatchRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [relocate()][.buckets.relocate] method.
final class Buckets_RelocateRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.relocateRequest';

  /// Name of the bucket to be moved.
  final String bucket;

  /// Synthetic request body field for the [relocate()][.buckets.relocate] method.
  final RelocateBucketRequest? body;

  Buckets_RelocateRequest({this.bucket = '', this.body})
    : super(fullyQualifiedName);

  factory Buckets_RelocateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_RelocateRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => RelocateBucketRequest.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = ['bucket=$bucket'].join(',');
    return 'relocateRequest($contents)';
  }
}

/// Synthetic request message for the [restore()][.buckets.restore] method.
final class Buckets_RestoreRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.restoreRequest';

  /// Name of a bucket.
  final String bucket;

  /// Generation of a bucket.
  final int generation;

  /// Set of properties to return. Defaults to full.
  final Buckets_RestoreRequest_Projection? projection;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Buckets_RestoreRequest({
    this.bucket = '',
    this.generation = 0,
    this.projection,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Buckets_RestoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_RestoreRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Buckets_RestoreRequest_Projection.fromJson($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation.isNotDefault) 'generation': encodeInt64(generation),
    if (projection != null) 'projection': projection!.toJson(),
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'generation=$generation',
      if (projection != null) 'projection=$projection',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'restoreRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Buckets_RestoreRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Buckets_RestoreRequest_Projection('full');

  /// Omit owner, acl and defaultObjectAcl properties.
  static const noAcl = Buckets_RestoreRequest_Projection('noAcl');

  /// The default value for [Buckets_RestoreRequest_Projection].
  static const $default = full;

  const Buckets_RestoreRequest_Projection(super.value);

  factory Buckets_RestoreRequest_Projection.fromJson(Object? json) =>
      Buckets_RestoreRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [setIamPolicy()][.buckets.setIamPolicy] method.
final class Buckets_SetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.setIamPolicyRequest';

  /// Name of a bucket.
  final String bucket;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [setIamPolicy()][.buckets.setIamPolicy] method.
  final Policy? body;

  Buckets_SetIamPolicyRequest({this.bucket = '', this.userProject, this.body})
    : super(fullyQualifiedName);

  factory Buckets_SetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_SetIamPolicyRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Policy.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'setIamPolicyRequest($contents)';
  }
}

/// Synthetic request message for the [testIamPermissions()][.buckets.testIamPermissions] method.
final class Buckets_TestIamPermissionsRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.testIamPermissionsRequest';

  /// Name of a bucket.
  final String bucket;

  /// Permissions to test.
  final String permissions;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Buckets_TestIamPermissionsRequest({
    this.bucket = '',
    this.permissions = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Buckets_TestIamPermissionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_TestIamPermissionsRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      permissions: switch (json['permissions']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (permissions.isNotDefault) 'permissions': permissions,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'permissions=$permissions',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'testIamPermissionsRequest($contents)';
  }
}

/// Synthetic request message for the [update()][.buckets.update] method.
final class Buckets_UpdateRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.buckets.updateRequest';

  /// Name of a bucket.
  final String bucket;

  /// Makes the return of the bucket metadata conditional on whether the bucket's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the return of the bucket metadata conditional on whether the bucket's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Apply a predefined set of access controls to this bucket.
  final Buckets_UpdateRequest_PredefinedAcl? predefinedAcl;

  /// Apply a predefined set of default object access controls to this bucket.
  final Buckets_UpdateRequest_PredefinedDefaultObjectAcl?
  predefinedDefaultObjectAcl;

  /// Set of properties to return. Defaults to full.
  final Buckets_UpdateRequest_Projection? projection;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [update()][.buckets.update] method.
  final Bucket? body;

  Buckets_UpdateRequest({
    this.bucket = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.predefinedAcl,
    this.predefinedDefaultObjectAcl,
    this.projection,
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Buckets_UpdateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Buckets_UpdateRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      predefinedAcl: switch (json['predefinedAcl']) {
        null => null,
        Object $1 => Buckets_UpdateRequest_PredefinedAcl.fromJson($1),
      },
      predefinedDefaultObjectAcl: switch (json['predefinedDefaultObjectAcl']) {
        null => null,
        Object $1 => Buckets_UpdateRequest_PredefinedDefaultObjectAcl.fromJson(
          $1,
        ),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Buckets_UpdateRequest_Projection.fromJson($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Bucket.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (predefinedAcl != null) 'predefinedAcl': predefinedAcl!.toJson(),
    if (predefinedDefaultObjectAcl != null)
      'predefinedDefaultObjectAcl': predefinedDefaultObjectAcl!.toJson(),
    if (projection != null) 'projection': projection!.toJson(),
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (predefinedAcl != null) 'predefinedAcl=$predefinedAcl',
      if (predefinedDefaultObjectAcl != null)
        'predefinedDefaultObjectAcl=$predefinedDefaultObjectAcl',
      if (projection != null) 'projection=$projection',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'updateRequest($contents)';
  }
}

/// The enumerated type for the `predefinedAcl` field.
final class Buckets_UpdateRequest_PredefinedAcl extends ProtoEnum {
  /// Project team owners get OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead = Buckets_UpdateRequest_PredefinedAcl(
    'authenticatedRead',
  );

  /// Project team owners get OWNER access.
  static const private = Buckets_UpdateRequest_PredefinedAcl('private');

  /// Project team members get access according to their roles.
  static const projectPrivate = Buckets_UpdateRequest_PredefinedAcl(
    'projectPrivate',
  );

  /// Project team owners get OWNER access, and allUsers get READER access.
  static const publicRead = Buckets_UpdateRequest_PredefinedAcl('publicRead');

  /// Project team owners get OWNER access, and allUsers get WRITER access.
  static const publicReadWrite = Buckets_UpdateRequest_PredefinedAcl(
    'publicReadWrite',
  );

  /// The default value for [Buckets_UpdateRequest_PredefinedAcl].
  static const $default = authenticatedRead;

  const Buckets_UpdateRequest_PredefinedAcl(super.value);

  factory Buckets_UpdateRequest_PredefinedAcl.fromJson(Object? json) =>
      Buckets_UpdateRequest_PredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedAcl.$value';
}

/// The enumerated type for the `predefinedDefaultObjectAcl` field.
final class Buckets_UpdateRequest_PredefinedDefaultObjectAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead =
      Buckets_UpdateRequest_PredefinedDefaultObjectAcl('authenticatedRead');

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl =
      Buckets_UpdateRequest_PredefinedDefaultObjectAcl(
        'bucketOwnerFullControl',
      );

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead =
      Buckets_UpdateRequest_PredefinedDefaultObjectAcl('bucketOwnerRead');

  /// Object owner gets OWNER access.
  static const private = Buckets_UpdateRequest_PredefinedDefaultObjectAcl(
    'private',
  );

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate =
      Buckets_UpdateRequest_PredefinedDefaultObjectAcl('projectPrivate');

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Buckets_UpdateRequest_PredefinedDefaultObjectAcl(
    'publicRead',
  );

  /// The default value for [Buckets_UpdateRequest_PredefinedDefaultObjectAcl].
  static const $default = authenticatedRead;

  const Buckets_UpdateRequest_PredefinedDefaultObjectAcl(super.value);

  factory Buckets_UpdateRequest_PredefinedDefaultObjectAcl.fromJson(
    Object? json,
  ) => Buckets_UpdateRequest_PredefinedDefaultObjectAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedDefaultObjectAcl.$value';
}

/// The enumerated type for the `projection` field.
final class Buckets_UpdateRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Buckets_UpdateRequest_Projection('full');

  /// Omit owner, acl and defaultObjectAcl properties.
  static const noAcl = Buckets_UpdateRequest_Projection('noAcl');

  /// The default value for [Buckets_UpdateRequest_Projection].
  static const $default = full;

  const Buckets_UpdateRequest_Projection(super.value);

  factory Buckets_UpdateRequest_Projection.fromJson(Object? json) =>
      Buckets_UpdateRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic messages for the `channels` service
final class Channels extends ProtoMessage {
  static const String fullyQualifiedName = '.channels';

  Channels() : super(fullyQualifiedName);

  factory Channels.fromJson(Object? j) => Channels();

  @override
  Object toJson() => {};

  @override
  String toString() => 'channels()';
}

/// Synthetic request message for the [stop()][.channels.stop] method.
final class Channels_StopRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.channels.stopRequest';

  /// Synthetic request body field for the [stop()][.channels.stop] method.
  final Channel? body;

  Channels_StopRequest({this.body}) : super(fullyQualifiedName);

  factory Channels_StopRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Channels_StopRequest(
      body: switch (json['body']) {
        null => null,
        Object $1 => Channel.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (body != null) 'body': body!.toJson()};

  @override
  String toString() => 'stopRequest()';
}

/// Synthetic messages for the `defaultObjectAccessControls` service
final class DefaultObjectAccessControls extends ProtoMessage {
  static const String fullyQualifiedName = '.defaultObjectAccessControls';

  DefaultObjectAccessControls() : super(fullyQualifiedName);

  factory DefaultObjectAccessControls.fromJson(Object? j) =>
      DefaultObjectAccessControls();

  @override
  Object toJson() => {};

  @override
  String toString() => 'defaultObjectAccessControls()';
}

/// Synthetic request message for the [delete()][.defaultObjectAccessControls.delete] method.
final class DefaultObjectAccessControls_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.defaultObjectAccessControls.deleteRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  DefaultObjectAccessControls_DeleteRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory DefaultObjectAccessControls_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DefaultObjectAccessControls_DeleteRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.defaultObjectAccessControls.get] method.
final class DefaultObjectAccessControls_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.defaultObjectAccessControls.getRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  DefaultObjectAccessControls_GetRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory DefaultObjectAccessControls_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DefaultObjectAccessControls_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.defaultObjectAccessControls.insert] method.
final class DefaultObjectAccessControls_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.defaultObjectAccessControls.insertRequest';

  /// Name of a bucket.
  final String bucket;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [insert()][.defaultObjectAccessControls.insert] method.
  final ObjectAccessControl? body;

  DefaultObjectAccessControls_InsertRequest({
    this.bucket = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory DefaultObjectAccessControls_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DefaultObjectAccessControls_InsertRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ObjectAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'insertRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.defaultObjectAccessControls.list] method.
final class DefaultObjectAccessControls_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.defaultObjectAccessControls.listRequest';

  /// Name of a bucket.
  final String bucket;

  /// If present, only return default ACL listing if the bucket's current metageneration matches this value.
  final int? ifMetagenerationMatch;

  /// If present, only return default ACL listing if the bucket's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  DefaultObjectAccessControls_ListRequest({
    this.bucket = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory DefaultObjectAccessControls_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DefaultObjectAccessControls_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic request message for the [patch()][.defaultObjectAccessControls.patch] method.
final class DefaultObjectAccessControls_PatchRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.defaultObjectAccessControls.patchRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [patch()][.defaultObjectAccessControls.patch] method.
  final ObjectAccessControl? body;

  DefaultObjectAccessControls_PatchRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory DefaultObjectAccessControls_PatchRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DefaultObjectAccessControls_PatchRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ObjectAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'patchRequest($contents)';
  }
}

/// Synthetic request message for the [update()][.defaultObjectAccessControls.update] method.
final class DefaultObjectAccessControls_UpdateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.defaultObjectAccessControls.updateRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [update()][.defaultObjectAccessControls.update] method.
  final ObjectAccessControl? body;

  DefaultObjectAccessControls_UpdateRequest({
    this.bucket = '',
    this.entity = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory DefaultObjectAccessControls_UpdateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DefaultObjectAccessControls_UpdateRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ObjectAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'updateRequest($contents)';
  }
}

/// Synthetic messages for the `folders` service
final class Folders extends ProtoMessage {
  static const String fullyQualifiedName = '.folders';

  Folders() : super(fullyQualifiedName);

  factory Folders.fromJson(Object? j) => Folders();

  @override
  Object toJson() => {};

  @override
  String toString() => 'folders()';
}

/// Synthetic request message for the [delete()][.folders.delete] method.
final class Folders_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.folders.deleteRequest';

  /// Name of the bucket in which the folder resides.
  final String bucket;

  /// Name of a folder.
  final String folder;

  /// If set, only deletes the folder if its metageneration matches this value.
  final int? ifMetagenerationMatch;

  /// If set, only deletes the folder if its metageneration does not match this value.
  final int? ifMetagenerationNotMatch;

  Folders_DeleteRequest({
    this.bucket = '',
    this.folder = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
  }) : super(fullyQualifiedName);

  factory Folders_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folders_DeleteRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      folder: switch (json['folder']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (folder.isNotDefault) 'folder': folder,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'folder=$folder',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.folders.get] method.
final class Folders_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.folders.getRequest';

  /// Name of the bucket in which the folder resides.
  final String bucket;

  /// Name of a folder.
  final String folder;

  /// Makes the return of the folder metadata conditional on whether the folder's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the return of the folder metadata conditional on whether the folder's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  Folders_GetRequest({
    this.bucket = '',
    this.folder = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
  }) : super(fullyQualifiedName);

  factory Folders_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folders_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      folder: switch (json['folder']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (folder.isNotDefault) 'folder': folder,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'folder=$folder',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.folders.insert] method.
final class Folders_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.folders.insertRequest';

  /// Name of the bucket in which the folder resides.
  final String bucket;

  /// If true, any parent folder which doesn't exist will be created automatically.
  final bool? recursive;

  /// Synthetic request body field for the [insert()][.folders.insert] method.
  final Folder? body;

  Folders_InsertRequest({this.bucket = '', this.recursive, this.body})
    : super(fullyQualifiedName);

  factory Folders_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folders_InsertRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      recursive: switch (json['recursive']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Folder.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (recursive != null) 'recursive': recursive,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (recursive != null) 'recursive=$recursive',
    ].join(',');
    return 'insertRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.folders.list] method.
final class Folders_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.folders.listRequest';

  /// Name of the bucket in which to look for folders.
  final String bucket;

  /// Returns results in a directory-like mode. The only supported value is '/'. If set, items will only contain folders that either exactly match the prefix, or are one level below the prefix.
  final String? delimiter;

  /// Filter results to folders whose names are lexicographically before endOffset. If startOffset is also set, the folders listed will have names between startOffset (inclusive) and endOffset (exclusive).
  final String? endOffset;

  /// Maximum number of items to return in a single page of responses.
  final int? pageSize;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  /// Filter results to folders whose paths begin with this prefix. If set, the value must either be an empty string or end with a '/'.
  final String? prefix;

  /// Filter results to folders whose names are lexicographically equal to or after startOffset. If endOffset is also set, the folders listed will have names between startOffset (inclusive) and endOffset (exclusive).
  final String? startOffset;

  Folders_ListRequest({
    this.bucket = '',
    this.delimiter,
    this.endOffset,
    this.pageSize,
    this.pageToken,
    this.prefix,
    this.startOffset,
  }) : super(fullyQualifiedName);

  factory Folders_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folders_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      delimiter: switch (json['delimiter']) {
        null => null,
        Object $1 => decodeString($1),
      },
      endOffset: switch (json['endOffset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      prefix: switch (json['prefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
      startOffset: switch (json['startOffset']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (delimiter != null) 'delimiter': delimiter,
    if (endOffset != null) 'endOffset': endOffset,
    if (pageSize != null) 'pageSize': pageSize,
    if (pageToken != null) 'pageToken': pageToken,
    if (prefix != null) 'prefix': prefix,
    if (startOffset != null) 'startOffset': startOffset,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (delimiter != null) 'delimiter=$delimiter',
      if (endOffset != null) 'endOffset=$endOffset',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (prefix != null) 'prefix=$prefix',
      if (startOffset != null) 'startOffset=$startOffset',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic request message for the [rename()][.folders.rename] method.
final class Folders_RenameRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.folders.renameRequest';

  /// Name of the bucket in which the folders are in.
  final String bucket;

  /// Name of the destination folder.
  final String destinationFolder;

  /// Makes the operation conditional on whether the source object's current metageneration matches the given value.
  final int? ifSourceMetagenerationMatch;

  /// Makes the operation conditional on whether the source object's current metageneration does not match the given value.
  final int? ifSourceMetagenerationNotMatch;

  /// Name of the source folder.
  final String sourceFolder;

  Folders_RenameRequest({
    this.bucket = '',
    this.destinationFolder = '',
    this.ifSourceMetagenerationMatch,
    this.ifSourceMetagenerationNotMatch,
    this.sourceFolder = '',
  }) : super(fullyQualifiedName);

  factory Folders_RenameRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Folders_RenameRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationFolder: switch (json['destinationFolder']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifSourceMetagenerationMatch:
          switch (json['ifSourceMetagenerationMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      ifSourceMetagenerationNotMatch:
          switch (json['ifSourceMetagenerationNotMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      sourceFolder: switch (json['sourceFolder']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (destinationFolder.isNotDefault) 'destinationFolder': destinationFolder,
    if (ifSourceMetagenerationMatch != null)
      'ifSourceMetagenerationMatch': encodeInt64(ifSourceMetagenerationMatch),
    if (ifSourceMetagenerationNotMatch != null)
      'ifSourceMetagenerationNotMatch': encodeInt64(
        ifSourceMetagenerationNotMatch,
      ),
    if (sourceFolder.isNotDefault) 'sourceFolder': sourceFolder,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'destinationFolder=$destinationFolder',
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch=$ifSourceMetagenerationMatch',
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch=$ifSourceMetagenerationNotMatch',
      'sourceFolder=$sourceFolder',
    ].join(',');
    return 'renameRequest($contents)';
  }
}

/// Synthetic messages for the `managedFolders` service
final class ManagedFolders extends ProtoMessage {
  static const String fullyQualifiedName = '.managedFolders';

  ManagedFolders() : super(fullyQualifiedName);

  factory ManagedFolders.fromJson(Object? j) => ManagedFolders();

  @override
  Object toJson() => {};

  @override
  String toString() => 'managedFolders()';
}

/// Synthetic request message for the [delete()][.managedFolders.delete] method.
final class ManagedFolders_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.managedFolders.deleteRequest';

  /// Allows the deletion of a managed folder even if it is not empty. A managed folder is empty if there are no objects or managed folders that it applies to. Callers must have storage.managedFolders.setIamPolicy permission.
  final bool? allowNonEmpty;

  /// Name of the bucket containing the managed folder.
  final String bucket;

  /// If set, only deletes the managed folder if its metageneration matches this value.
  final int? ifMetagenerationMatch;

  /// If set, only deletes the managed folder if its metageneration does not match this value.
  final int? ifMetagenerationNotMatch;

  /// The managed folder name/path.
  final String managedFolder;

  ManagedFolders_DeleteRequest({
    this.allowNonEmpty,
    this.bucket = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.managedFolder = '',
  }) : super(fullyQualifiedName);

  factory ManagedFolders_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders_DeleteRequest(
      allowNonEmpty: switch (json['allowNonEmpty']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      managedFolder: switch (json['managedFolder']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (allowNonEmpty != null) 'allowNonEmpty': allowNonEmpty,
    if (bucket.isNotDefault) 'bucket': bucket,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (managedFolder.isNotDefault) 'managedFolder': managedFolder,
  };

  @override
  String toString() {
    final contents = [
      if (allowNonEmpty != null) 'allowNonEmpty=$allowNonEmpty',
      'bucket=$bucket',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'managedFolder=$managedFolder',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.managedFolders.get] method.
final class ManagedFolders_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.managedFolders.getRequest';

  /// Name of the bucket containing the managed folder.
  final String bucket;

  /// Makes the return of the managed folder metadata conditional on whether the managed folder's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the return of the managed folder metadata conditional on whether the managed folder's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// The managed folder name/path.
  final String managedFolder;

  ManagedFolders_GetRequest({
    this.bucket = '',
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.managedFolder = '',
  }) : super(fullyQualifiedName);

  factory ManagedFolders_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      managedFolder: switch (json['managedFolder']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (managedFolder.isNotDefault) 'managedFolder': managedFolder,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'managedFolder=$managedFolder',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [getIamPolicy()][.managedFolders.getIamPolicy] method.
final class ManagedFolders_GetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.managedFolders.getIamPolicyRequest';

  /// Name of the bucket containing the managed folder.
  final String bucket;

  /// The managed folder name/path.
  final String managedFolder;

  /// The IAM policy format version to be returned. If the optionsRequestedPolicyVersion is for an older version that doesn't support part of the requested IAM policy, the request fails.
  final int? optionsRequestedPolicyVersion;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  ManagedFolders_GetIamPolicyRequest({
    this.bucket = '',
    this.managedFolder = '',
    this.optionsRequestedPolicyVersion,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory ManagedFolders_GetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders_GetIamPolicyRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      managedFolder: switch (json['managedFolder']) {
        null => '',
        Object $1 => decodeString($1),
      },
      optionsRequestedPolicyVersion:
          switch (json['optionsRequestedPolicyVersion']) {
            null => null,
            Object $1 => decodeInt($1),
          },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (managedFolder.isNotDefault) 'managedFolder': managedFolder,
    if (optionsRequestedPolicyVersion != null)
      'optionsRequestedPolicyVersion': optionsRequestedPolicyVersion,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'managedFolder=$managedFolder',
      if (optionsRequestedPolicyVersion != null)
        'optionsRequestedPolicyVersion=$optionsRequestedPolicyVersion',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getIamPolicyRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.managedFolders.insert] method.
final class ManagedFolders_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.managedFolders.insertRequest';

  /// Name of the bucket containing the managed folder.
  final String bucket;

  /// Synthetic request body field for the [insert()][.managedFolders.insert] method.
  final ManagedFolder? body;

  ManagedFolders_InsertRequest({this.bucket = '', this.body})
    : super(fullyQualifiedName);

  factory ManagedFolders_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders_InsertRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ManagedFolder.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = ['bucket=$bucket'].join(',');
    return 'insertRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.managedFolders.list] method.
final class ManagedFolders_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.managedFolders.listRequest';

  /// Name of the bucket containing the managed folder.
  final String bucket;

  /// Maximum number of items to return in a single page of responses.
  final int? pageSize;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  /// The managed folder name/path prefix to filter the output list of results.
  final String? prefix;

  ManagedFolders_ListRequest({
    this.bucket = '',
    this.pageSize,
    this.pageToken,
    this.prefix,
  }) : super(fullyQualifiedName);

  factory ManagedFolders_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      prefix: switch (json['prefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (pageSize != null) 'pageSize': pageSize,
    if (pageToken != null) 'pageToken': pageToken,
    if (prefix != null) 'prefix': prefix,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (prefix != null) 'prefix=$prefix',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic request message for the [setIamPolicy()][.managedFolders.setIamPolicy] method.
final class ManagedFolders_SetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.managedFolders.setIamPolicyRequest';

  /// Name of the bucket containing the managed folder.
  final String bucket;

  /// The managed folder name/path.
  final String managedFolder;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [setIamPolicy()][.managedFolders.setIamPolicy] method.
  final Policy? body;

  ManagedFolders_SetIamPolicyRequest({
    this.bucket = '',
    this.managedFolder = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory ManagedFolders_SetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders_SetIamPolicyRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      managedFolder: switch (json['managedFolder']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Policy.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (managedFolder.isNotDefault) 'managedFolder': managedFolder,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'managedFolder=$managedFolder',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'setIamPolicyRequest($contents)';
  }
}

/// Synthetic request message for the [testIamPermissions()][.managedFolders.testIamPermissions] method.
final class ManagedFolders_TestIamPermissionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.managedFolders.testIamPermissionsRequest';

  /// Name of the bucket containing the managed folder.
  final String bucket;

  /// The managed folder name/path.
  final String managedFolder;

  /// Permissions to test.
  final String permissions;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  ManagedFolders_TestIamPermissionsRequest({
    this.bucket = '',
    this.managedFolder = '',
    this.permissions = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory ManagedFolders_TestIamPermissionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManagedFolders_TestIamPermissionsRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      managedFolder: switch (json['managedFolder']) {
        null => '',
        Object $1 => decodeString($1),
      },
      permissions: switch (json['permissions']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (managedFolder.isNotDefault) 'managedFolder': managedFolder,
    if (permissions.isNotDefault) 'permissions': permissions,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'managedFolder=$managedFolder',
      'permissions=$permissions',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'testIamPermissionsRequest($contents)';
  }
}

/// Synthetic messages for the `notifications` service
final class Notifications extends ProtoMessage {
  static const String fullyQualifiedName = '.notifications';

  Notifications() : super(fullyQualifiedName);

  factory Notifications.fromJson(Object? j) => Notifications();

  @override
  Object toJson() => {};

  @override
  String toString() => 'notifications()';
}

/// Synthetic request message for the [delete()][.notifications.delete] method.
final class Notifications_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.notifications.deleteRequest';

  /// The parent bucket of the notification.
  final String bucket;

  /// ID of the notification to delete.
  final String notification;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Notifications_DeleteRequest({
    this.bucket = '',
    this.notification = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Notifications_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Notifications_DeleteRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notification: switch (json['notification']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (notification.isNotDefault) 'notification': notification,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'notification=$notification',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.notifications.get] method.
final class Notifications_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.notifications.getRequest';

  /// The parent bucket of the notification.
  final String bucket;

  /// Notification ID
  final String notification;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Notifications_GetRequest({
    this.bucket = '',
    this.notification = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Notifications_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Notifications_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notification: switch (json['notification']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (notification.isNotDefault) 'notification': notification,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'notification=$notification',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.notifications.insert] method.
final class Notifications_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.notifications.insertRequest';

  /// The parent bucket of the notification.
  final String bucket;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [insert()][.notifications.insert] method.
  final Notification? body;

  Notifications_InsertRequest({this.bucket = '', this.userProject, this.body})
    : super(fullyQualifiedName);

  factory Notifications_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Notifications_InsertRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Notification.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'insertRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.notifications.list] method.
final class Notifications_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.notifications.listRequest';

  /// Name of a Google Cloud Storage bucket.
  final String bucket;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Notifications_ListRequest({this.bucket = '', this.userProject})
    : super(fullyQualifiedName);

  factory Notifications_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Notifications_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic messages for the `objectAccessControls` service
final class ObjectAccessControls extends ProtoMessage {
  static const String fullyQualifiedName = '.objectAccessControls';

  ObjectAccessControls() : super(fullyQualifiedName);

  factory ObjectAccessControls.fromJson(Object? j) => ObjectAccessControls();

  @override
  Object toJson() => {};

  @override
  String toString() => 'objectAccessControls()';
}

/// Synthetic request message for the [delete()][.objectAccessControls.delete] method.
final class ObjectAccessControls_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.objectAccessControls.deleteRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  ObjectAccessControls_DeleteRequest({
    this.bucket = '',
    this.entity = '',
    this.generation,
    this.object = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControls_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControls_DeleteRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.objectAccessControls.get] method.
final class ObjectAccessControls_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objectAccessControls.getRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  ObjectAccessControls_GetRequest({
    this.bucket = '',
    this.entity = '',
    this.generation,
    this.object = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControls_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControls_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [insert()][.objectAccessControls.insert] method.
final class ObjectAccessControls_InsertRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.objectAccessControls.insertRequest';

  /// Name of a bucket.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [insert()][.objectAccessControls.insert] method.
  final ObjectAccessControl? body;

  ObjectAccessControls_InsertRequest({
    this.bucket = '',
    this.generation,
    this.object = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControls_InsertRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControls_InsertRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ObjectAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'insertRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.objectAccessControls.list] method.
final class ObjectAccessControls_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objectAccessControls.listRequest';

  /// Name of a bucket.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  ObjectAccessControls_ListRequest({
    this.bucket = '',
    this.generation,
    this.object = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControls_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControls_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic request message for the [patch()][.objectAccessControls.patch] method.
final class ObjectAccessControls_PatchRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objectAccessControls.patchRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [patch()][.objectAccessControls.patch] method.
  final ObjectAccessControl? body;

  ObjectAccessControls_PatchRequest({
    this.bucket = '',
    this.entity = '',
    this.generation,
    this.object = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControls_PatchRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControls_PatchRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ObjectAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'patchRequest($contents)';
  }
}

/// Synthetic request message for the [update()][.objectAccessControls.update] method.
final class ObjectAccessControls_UpdateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.objectAccessControls.updateRequest';

  /// Name of a bucket.
  final String bucket;

  /// The entity holding the permission. Can be user-userId, user-emailAddress, group-groupId, group-emailAddress, allUsers, or allAuthenticatedUsers.
  final String entity;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [update()][.objectAccessControls.update] method.
  final ObjectAccessControl? body;

  ObjectAccessControls_UpdateRequest({
    this.bucket = '',
    this.entity = '',
    this.generation,
    this.object = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory ObjectAccessControls_UpdateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ObjectAccessControls_UpdateRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entity: switch (json['entity']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ObjectAccessControl.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (entity.isNotDefault) 'entity': entity,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'entity=$entity',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'updateRequest($contents)';
  }
}

/// Synthetic messages for the `objects` service
final class Objects extends ProtoMessage {
  static const String fullyQualifiedName = '.objects';

  Objects() : super(fullyQualifiedName);

  factory Objects.fromJson(Object? j) => Objects();

  @override
  Object toJson() => {};

  @override
  String toString() => 'objects()';
}

/// Synthetic request message for the [bulkRestore()][.objects.bulkRestore] method.
final class Objects_BulkRestoreRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.bulkRestoreRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// Synthetic request body field for the [bulkRestore()][.objects.bulkRestore] method.
  final BulkRestoreObjectsRequest? body;

  Objects_BulkRestoreRequest({this.bucket = '', this.body})
    : super(fullyQualifiedName);

  factory Objects_BulkRestoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_BulkRestoreRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => BulkRestoreObjectsRequest.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = ['bucket=$bucket'].join(',');
    return 'bulkRestoreRequest($contents)';
  }
}

/// Synthetic request message for the [compose()][.objects.compose] method.
final class Objects_ComposeRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.composeRequest';

  /// Name of the bucket containing the source objects. The destination object is stored in this bucket.
  final String destinationBucket;

  /// Name of the new object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String destinationObject;

  /// Apply a predefined set of access controls to the destination object.
  final Objects_ComposeRequest_DestinationPredefinedAcl?
  destinationPredefinedAcl;

  /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
  final String? kmsKeyName;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [compose()][.objects.compose] method.
  final ComposeRequest? body;

  Objects_ComposeRequest({
    this.destinationBucket = '',
    this.destinationObject = '',
    this.destinationPredefinedAcl,
    this.ifGenerationMatch,
    this.ifMetagenerationMatch,
    this.kmsKeyName,
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Objects_ComposeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_ComposeRequest(
      destinationBucket: switch (json['destinationBucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationObject: switch (json['destinationObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationPredefinedAcl: switch (json['destinationPredefinedAcl']) {
        null => null,
        Object $1 => Objects_ComposeRequest_DestinationPredefinedAcl.fromJson(
          $1,
        ),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      kmsKeyName: switch (json['kmsKeyName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => ComposeRequest.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (destinationBucket.isNotDefault) 'destinationBucket': destinationBucket,
    if (destinationObject.isNotDefault) 'destinationObject': destinationObject,
    if (destinationPredefinedAcl != null)
      'destinationPredefinedAcl': destinationPredefinedAcl!.toJson(),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (kmsKeyName != null) 'kmsKeyName': kmsKeyName,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'destinationBucket=$destinationBucket',
      'destinationObject=$destinationObject',
      if (destinationPredefinedAcl != null)
        'destinationPredefinedAcl=$destinationPredefinedAcl',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (kmsKeyName != null) 'kmsKeyName=$kmsKeyName',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'composeRequest($contents)';
  }
}

/// The enumerated type for the `destinationPredefinedAcl` field.
final class Objects_ComposeRequest_DestinationPredefinedAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead =
      Objects_ComposeRequest_DestinationPredefinedAcl('authenticatedRead');

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl =
      Objects_ComposeRequest_DestinationPredefinedAcl('bucketOwnerFullControl');

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead =
      Objects_ComposeRequest_DestinationPredefinedAcl('bucketOwnerRead');

  /// Object owner gets OWNER access.
  static const private = Objects_ComposeRequest_DestinationPredefinedAcl(
    'private',
  );

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate = Objects_ComposeRequest_DestinationPredefinedAcl(
    'projectPrivate',
  );

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Objects_ComposeRequest_DestinationPredefinedAcl(
    'publicRead',
  );

  /// The default value for [Objects_ComposeRequest_DestinationPredefinedAcl].
  static const $default = authenticatedRead;

  const Objects_ComposeRequest_DestinationPredefinedAcl(super.value);

  factory Objects_ComposeRequest_DestinationPredefinedAcl.fromJson(
    Object? json,
  ) => Objects_ComposeRequest_DestinationPredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'destinationPredefinedAcl.$value';
}

/// Synthetic request message for the [copy()][.objects.copy] method.
final class Objects_CopyRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.copyRequest';

  /// Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String destinationBucket;

  /// Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
  final String? destinationKmsKeyName;

  /// Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any.
  final String destinationObject;

  /// Apply a predefined set of access controls to the destination object.
  final Objects_CopyRequest_DestinationPredefinedAcl? destinationPredefinedAcl;

  /// Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the destination object's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Makes the operation conditional on whether the source object's current generation matches the given value.
  final int? ifSourceGenerationMatch;

  /// Makes the operation conditional on whether the source object's current generation does not match the given value.
  final int? ifSourceGenerationNotMatch;

  /// Makes the operation conditional on whether the source object's current metageneration matches the given value.
  final int? ifSourceMetagenerationMatch;

  /// Makes the operation conditional on whether the source object's current metageneration does not match the given value.
  final int? ifSourceMetagenerationNotMatch;

  /// Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
  final Objects_CopyRequest_Projection? projection;

  /// Name of the bucket in which to find the source object.
  final String sourceBucket;

  /// If present, selects a specific revision of the source object (as opposed to the latest version, the default).
  final int? sourceGeneration;

  /// Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String sourceObject;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [copy()][.objects.copy] method.
  final Object$? body;

  Objects_CopyRequest({
    this.destinationBucket = '',
    this.destinationKmsKeyName,
    this.destinationObject = '',
    this.destinationPredefinedAcl,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.ifSourceGenerationMatch,
    this.ifSourceGenerationNotMatch,
    this.ifSourceMetagenerationMatch,
    this.ifSourceMetagenerationNotMatch,
    this.projection,
    this.sourceBucket = '',
    this.sourceGeneration,
    this.sourceObject = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Objects_CopyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_CopyRequest(
      destinationBucket: switch (json['destinationBucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationKmsKeyName: switch (json['destinationKmsKeyName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      destinationObject: switch (json['destinationObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationPredefinedAcl: switch (json['destinationPredefinedAcl']) {
        null => null,
        Object $1 => Objects_CopyRequest_DestinationPredefinedAcl.fromJson($1),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceGenerationMatch: switch (json['ifSourceGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceGenerationNotMatch: switch (json['ifSourceGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceMetagenerationMatch:
          switch (json['ifSourceMetagenerationMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      ifSourceMetagenerationNotMatch:
          switch (json['ifSourceMetagenerationNotMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_CopyRequest_Projection.fromJson($1),
      },
      sourceBucket: switch (json['sourceBucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sourceGeneration: switch (json['sourceGeneration']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      sourceObject: switch (json['sourceObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Object$.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (destinationBucket.isNotDefault) 'destinationBucket': destinationBucket,
    if (destinationKmsKeyName != null)
      'destinationKmsKeyName': destinationKmsKeyName,
    if (destinationObject.isNotDefault) 'destinationObject': destinationObject,
    if (destinationPredefinedAcl != null)
      'destinationPredefinedAcl': destinationPredefinedAcl!.toJson(),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (ifSourceGenerationMatch != null)
      'ifSourceGenerationMatch': encodeInt64(ifSourceGenerationMatch),
    if (ifSourceGenerationNotMatch != null)
      'ifSourceGenerationNotMatch': encodeInt64(ifSourceGenerationNotMatch),
    if (ifSourceMetagenerationMatch != null)
      'ifSourceMetagenerationMatch': encodeInt64(ifSourceMetagenerationMatch),
    if (ifSourceMetagenerationNotMatch != null)
      'ifSourceMetagenerationNotMatch': encodeInt64(
        ifSourceMetagenerationNotMatch,
      ),
    if (projection != null) 'projection': projection!.toJson(),
    if (sourceBucket.isNotDefault) 'sourceBucket': sourceBucket,
    if (sourceGeneration != null)
      'sourceGeneration': encodeInt64(sourceGeneration),
    if (sourceObject.isNotDefault) 'sourceObject': sourceObject,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'destinationBucket=$destinationBucket',
      if (destinationKmsKeyName != null)
        'destinationKmsKeyName=$destinationKmsKeyName',
      'destinationObject=$destinationObject',
      if (destinationPredefinedAcl != null)
        'destinationPredefinedAcl=$destinationPredefinedAcl',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (ifSourceGenerationMatch != null)
        'ifSourceGenerationMatch=$ifSourceGenerationMatch',
      if (ifSourceGenerationNotMatch != null)
        'ifSourceGenerationNotMatch=$ifSourceGenerationNotMatch',
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch=$ifSourceMetagenerationMatch',
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch=$ifSourceMetagenerationNotMatch',
      if (projection != null) 'projection=$projection',
      'sourceBucket=$sourceBucket',
      if (sourceGeneration != null) 'sourceGeneration=$sourceGeneration',
      'sourceObject=$sourceObject',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'copyRequest($contents)';
  }
}

/// The enumerated type for the `destinationPredefinedAcl` field.
final class Objects_CopyRequest_DestinationPredefinedAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead = Objects_CopyRequest_DestinationPredefinedAcl(
    'authenticatedRead',
  );

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl =
      Objects_CopyRequest_DestinationPredefinedAcl('bucketOwnerFullControl');

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead = Objects_CopyRequest_DestinationPredefinedAcl(
    'bucketOwnerRead',
  );

  /// Object owner gets OWNER access.
  static const private = Objects_CopyRequest_DestinationPredefinedAcl(
    'private',
  );

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate = Objects_CopyRequest_DestinationPredefinedAcl(
    'projectPrivate',
  );

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Objects_CopyRequest_DestinationPredefinedAcl(
    'publicRead',
  );

  /// The default value for [Objects_CopyRequest_DestinationPredefinedAcl].
  static const $default = authenticatedRead;

  const Objects_CopyRequest_DestinationPredefinedAcl(super.value);

  factory Objects_CopyRequest_DestinationPredefinedAcl.fromJson(Object? json) =>
      Objects_CopyRequest_DestinationPredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'destinationPredefinedAcl.$value';
}

/// The enumerated type for the `projection` field.
final class Objects_CopyRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_CopyRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_CopyRequest_Projection('noAcl');

  /// The default value for [Objects_CopyRequest_Projection].
  static const $default = full;

  const Objects_CopyRequest_Projection(super.value);

  factory Objects_CopyRequest_Projection.fromJson(Object? json) =>
      Objects_CopyRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [delete()][.objects.delete] method.
final class Objects_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.deleteRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If present, permanently deletes a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Objects_DeleteRequest({
    this.bucket = '',
    this.generation,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.object = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Objects_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_DeleteRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.objects.get] method.
final class Objects_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.getRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// Set of properties to return. Defaults to noAcl.
  final Objects_GetRequest_Projection? projection;

  /// Restore token used to differentiate soft-deleted objects with the same name and generation. Only applicable for hierarchical namespace buckets and if softDeleted is set to true. This parameter is optional, and is only required in the rare case when there are multiple soft-deleted objects with the same name and generation.
  final String? restoreToken;

  /// If true, only soft-deleted object versions will be listed. The default is false. For more information, see [Soft Delete](https://cloud.google.com/storage/docs/soft-delete).
  final bool? softDeleted;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Objects_GetRequest({
    this.bucket = '',
    this.generation,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.object = '',
    this.projection,
    this.restoreToken,
    this.softDeleted,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Objects_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_GetRequest_Projection.fromJson($1),
      },
      restoreToken: switch (json['restoreToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      softDeleted: switch (json['softDeleted']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (object.isNotDefault) 'object': object,
    if (projection != null) 'projection': projection!.toJson(),
    if (restoreToken != null) 'restoreToken': restoreToken,
    if (softDeleted != null) 'softDeleted': softDeleted,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'object=$object',
      if (projection != null) 'projection=$projection',
      if (restoreToken != null) 'restoreToken=$restoreToken',
      if (softDeleted != null) 'softDeleted=$softDeleted',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Objects_GetRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_GetRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_GetRequest_Projection('noAcl');

  /// The default value for [Objects_GetRequest_Projection].
  static const $default = full;

  const Objects_GetRequest_Projection(super.value);

  factory Objects_GetRequest_Projection.fromJson(Object? json) =>
      Objects_GetRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [getIamPolicy()][.objects.getIamPolicy] method.
final class Objects_GetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.getIamPolicyRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Objects_GetIamPolicyRequest({
    this.bucket = '',
    this.generation,
    this.object = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Objects_GetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_GetIamPolicyRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getIamPolicyRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.objects.list] method.
final class Objects_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.listRequest';

  /// Name of the bucket in which to look for objects.
  final String bucket;

  /// Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
  final String? delimiter;

  /// Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
  final String? endOffset;

  /// Filter the returned objects. Currently only supported for the contexts field. If delimiter is set, the returned prefixes are exempt from this filter.
  final String? filter;

  /// Only applicable if delimiter is set to '/'. If true, will also include folders and managed folders (besides objects) in the returned prefixes.
  final bool? includeFoldersAsPrefixes;

  /// If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
  final bool? includeTrailingDelimiter;

  /// Filter results to objects and prefixes that match this glob pattern.
  final String? matchGlob;

  /// Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
  final int? maxResults;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  /// Filter results to objects whose names begin with this prefix.
  final String? prefix;

  /// Set of properties to return. Defaults to noAcl.
  final Objects_ListRequest_Projection? projection;

  /// If true, only soft-deleted object versions will be listed. The default is false. For more information, see [Soft Delete](https://cloud.google.com/storage/docs/soft-delete).
  final bool? softDeleted;

  /// Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
  final String? startOffset;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// If true, lists all versions of an object as distinct results. The default is false. For more information, see [Object Versioning](https://cloud.google.com/storage/docs/object-versioning).
  final bool? versions;

  Objects_ListRequest({
    this.bucket = '',
    this.delimiter,
    this.endOffset,
    this.filter,
    this.includeFoldersAsPrefixes,
    this.includeTrailingDelimiter,
    this.matchGlob,
    this.maxResults,
    this.pageToken,
    this.prefix,
    this.projection,
    this.softDeleted,
    this.startOffset,
    this.userProject,
    this.versions,
  }) : super(fullyQualifiedName);

  factory Objects_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      delimiter: switch (json['delimiter']) {
        null => null,
        Object $1 => decodeString($1),
      },
      endOffset: switch (json['endOffset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => null,
        Object $1 => decodeString($1),
      },
      includeFoldersAsPrefixes: switch (json['includeFoldersAsPrefixes']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      includeTrailingDelimiter: switch (json['includeTrailingDelimiter']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      matchGlob: switch (json['matchGlob']) {
        null => null,
        Object $1 => decodeString($1),
      },
      maxResults: switch (json['maxResults']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      prefix: switch (json['prefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_ListRequest_Projection.fromJson($1),
      },
      softDeleted: switch (json['softDeleted']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      startOffset: switch (json['startOffset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      versions: switch (json['versions']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (delimiter != null) 'delimiter': delimiter,
    if (endOffset != null) 'endOffset': endOffset,
    if (filter != null) 'filter': filter,
    if (includeFoldersAsPrefixes != null)
      'includeFoldersAsPrefixes': includeFoldersAsPrefixes,
    if (includeTrailingDelimiter != null)
      'includeTrailingDelimiter': includeTrailingDelimiter,
    if (matchGlob != null) 'matchGlob': matchGlob,
    if (maxResults != null) 'maxResults': maxResults,
    if (pageToken != null) 'pageToken': pageToken,
    if (prefix != null) 'prefix': prefix,
    if (projection != null) 'projection': projection!.toJson(),
    if (softDeleted != null) 'softDeleted': softDeleted,
    if (startOffset != null) 'startOffset': startOffset,
    if (userProject != null) 'userProject': userProject,
    if (versions != null) 'versions': versions,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (delimiter != null) 'delimiter=$delimiter',
      if (endOffset != null) 'endOffset=$endOffset',
      if (filter != null) 'filter=$filter',
      if (includeFoldersAsPrefixes != null)
        'includeFoldersAsPrefixes=$includeFoldersAsPrefixes',
      if (includeTrailingDelimiter != null)
        'includeTrailingDelimiter=$includeTrailingDelimiter',
      if (matchGlob != null) 'matchGlob=$matchGlob',
      if (maxResults != null) 'maxResults=$maxResults',
      if (pageToken != null) 'pageToken=$pageToken',
      if (prefix != null) 'prefix=$prefix',
      if (projection != null) 'projection=$projection',
      if (softDeleted != null) 'softDeleted=$softDeleted',
      if (startOffset != null) 'startOffset=$startOffset',
      if (userProject != null) 'userProject=$userProject',
      if (versions != null) 'versions=$versions',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Objects_ListRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_ListRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_ListRequest_Projection('noAcl');

  /// The default value for [Objects_ListRequest_Projection].
  static const $default = full;

  const Objects_ListRequest_Projection(super.value);

  factory Objects_ListRequest_Projection.fromJson(Object? json) =>
      Objects_ListRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [move()][.objects.move] method.
final class Objects_MoveRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.moveRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// Name of the destination object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String destinationObject;

  /// Makes the operation conditional on whether the destination object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object. `ifGenerationMatch` and `ifGenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the destination object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.`ifGenerationMatch` and `ifGenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the destination object's current metageneration matches the given value. `ifMetagenerationMatch` and `ifMetagenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the destination object's current metageneration does not match the given value. `ifMetagenerationMatch` and `ifMetagenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifMetagenerationNotMatch;

  /// Makes the operation conditional on whether the source object's current generation matches the given value. `ifSourceGenerationMatch` and `ifSourceGenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifSourceGenerationMatch;

  /// Makes the operation conditional on whether the source object's current generation does not match the given value. `ifSourceGenerationMatch` and `ifSourceGenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifSourceGenerationNotMatch;

  /// Makes the operation conditional on whether the source object's current metageneration matches the given value. `ifSourceMetagenerationMatch` and `ifSourceMetagenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifSourceMetagenerationMatch;

  /// Makes the operation conditional on whether the source object's current metageneration does not match the given value. `ifSourceMetagenerationMatch` and `ifSourceMetagenerationNotMatch` conditions are mutually exclusive: it's an error for both of them to be set in the request.
  final int? ifSourceMetagenerationNotMatch;

  /// Set of properties to return. Defaults to noAcl.
  final Objects_MoveRequest_Projection? projection;

  /// Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String sourceObject;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Objects_MoveRequest({
    this.bucket = '',
    this.destinationObject = '',
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.ifSourceGenerationMatch,
    this.ifSourceGenerationNotMatch,
    this.ifSourceMetagenerationMatch,
    this.ifSourceMetagenerationNotMatch,
    this.projection,
    this.sourceObject = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Objects_MoveRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_MoveRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationObject: switch (json['destinationObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceGenerationMatch: switch (json['ifSourceGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceGenerationNotMatch: switch (json['ifSourceGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceMetagenerationMatch:
          switch (json['ifSourceMetagenerationMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      ifSourceMetagenerationNotMatch:
          switch (json['ifSourceMetagenerationNotMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_MoveRequest_Projection.fromJson($1),
      },
      sourceObject: switch (json['sourceObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (destinationObject.isNotDefault) 'destinationObject': destinationObject,
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (ifSourceGenerationMatch != null)
      'ifSourceGenerationMatch': encodeInt64(ifSourceGenerationMatch),
    if (ifSourceGenerationNotMatch != null)
      'ifSourceGenerationNotMatch': encodeInt64(ifSourceGenerationNotMatch),
    if (ifSourceMetagenerationMatch != null)
      'ifSourceMetagenerationMatch': encodeInt64(ifSourceMetagenerationMatch),
    if (ifSourceMetagenerationNotMatch != null)
      'ifSourceMetagenerationNotMatch': encodeInt64(
        ifSourceMetagenerationNotMatch,
      ),
    if (projection != null) 'projection': projection!.toJson(),
    if (sourceObject.isNotDefault) 'sourceObject': sourceObject,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'destinationObject=$destinationObject',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (ifSourceGenerationMatch != null)
        'ifSourceGenerationMatch=$ifSourceGenerationMatch',
      if (ifSourceGenerationNotMatch != null)
        'ifSourceGenerationNotMatch=$ifSourceGenerationNotMatch',
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch=$ifSourceMetagenerationMatch',
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch=$ifSourceMetagenerationNotMatch',
      if (projection != null) 'projection=$projection',
      'sourceObject=$sourceObject',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'moveRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Objects_MoveRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_MoveRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_MoveRequest_Projection('noAcl');

  /// The default value for [Objects_MoveRequest_Projection].
  static const $default = full;

  const Objects_MoveRequest_Projection(super.value);

  factory Objects_MoveRequest_Projection.fromJson(Object? json) =>
      Objects_MoveRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [patch()][.objects.patch] method.
final class Objects_PatchRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.patchRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
  final bool? overrideUnlockedRetention;

  /// Apply a predefined set of access controls to this object.
  final Objects_PatchRequest_PredefinedAcl? predefinedAcl;

  /// Set of properties to return. Defaults to full.
  final Objects_PatchRequest_Projection? projection;

  /// The project to be billed for this request, for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [patch()][.objects.patch] method.
  final Object$? body;

  Objects_PatchRequest({
    this.bucket = '',
    this.generation,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.object = '',
    this.overrideUnlockedRetention,
    this.predefinedAcl,
    this.projection,
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Objects_PatchRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_PatchRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      overrideUnlockedRetention: switch (json['overrideUnlockedRetention']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      predefinedAcl: switch (json['predefinedAcl']) {
        null => null,
        Object $1 => Objects_PatchRequest_PredefinedAcl.fromJson($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_PatchRequest_Projection.fromJson($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Object$.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (object.isNotDefault) 'object': object,
    if (overrideUnlockedRetention != null)
      'overrideUnlockedRetention': overrideUnlockedRetention,
    if (predefinedAcl != null) 'predefinedAcl': predefinedAcl!.toJson(),
    if (projection != null) 'projection': projection!.toJson(),
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'object=$object',
      if (overrideUnlockedRetention != null)
        'overrideUnlockedRetention=$overrideUnlockedRetention',
      if (predefinedAcl != null) 'predefinedAcl=$predefinedAcl',
      if (projection != null) 'projection=$projection',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'patchRequest($contents)';
  }
}

/// The enumerated type for the `predefinedAcl` field.
final class Objects_PatchRequest_PredefinedAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead = Objects_PatchRequest_PredefinedAcl(
    'authenticatedRead',
  );

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl = Objects_PatchRequest_PredefinedAcl(
    'bucketOwnerFullControl',
  );

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead = Objects_PatchRequest_PredefinedAcl(
    'bucketOwnerRead',
  );

  /// Object owner gets OWNER access.
  static const private = Objects_PatchRequest_PredefinedAcl('private');

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate = Objects_PatchRequest_PredefinedAcl(
    'projectPrivate',
  );

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Objects_PatchRequest_PredefinedAcl('publicRead');

  /// The default value for [Objects_PatchRequest_PredefinedAcl].
  static const $default = authenticatedRead;

  const Objects_PatchRequest_PredefinedAcl(super.value);

  factory Objects_PatchRequest_PredefinedAcl.fromJson(Object? json) =>
      Objects_PatchRequest_PredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedAcl.$value';
}

/// The enumerated type for the `projection` field.
final class Objects_PatchRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_PatchRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_PatchRequest_Projection('noAcl');

  /// The default value for [Objects_PatchRequest_Projection].
  static const $default = full;

  const Objects_PatchRequest_Projection(super.value);

  factory Objects_PatchRequest_Projection.fromJson(Object? json) =>
      Objects_PatchRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [restore()][.objects.restore] method.
final class Objects_RestoreRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.restoreRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If true, copies the source object's ACL; otherwise, uses the bucket's default object ACL. The default is false.
  final bool? copySourceAcl;

  /// Selects a specific revision of this object.
  final int generation;

  /// Makes the operation conditional on whether the object's one live generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether none of the object's live generations match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's one live metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether none of the object's live metagenerations match the given value.
  final int? ifMetagenerationNotMatch;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// Set of properties to return. Defaults to full.
  final Objects_RestoreRequest_Projection? projection;

  /// Restore token used to differentiate sof-deleted objects with the same name and generation. Only applicable for hierarchical namespace buckets. This parameter is optional, and is only required in the rare case when there are multiple soft-deleted objects with the same name and generation.
  final String? restoreToken;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Objects_RestoreRequest({
    this.bucket = '',
    this.copySourceAcl,
    this.generation = 0,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.object = '',
    this.projection,
    this.restoreToken,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Objects_RestoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_RestoreRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      copySourceAcl: switch (json['copySourceAcl']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      generation: switch (json['generation']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_RestoreRequest_Projection.fromJson($1),
      },
      restoreToken: switch (json['restoreToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (copySourceAcl != null) 'copySourceAcl': copySourceAcl,
    if (generation.isNotDefault) 'generation': encodeInt64(generation),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (object.isNotDefault) 'object': object,
    if (projection != null) 'projection': projection!.toJson(),
    if (restoreToken != null) 'restoreToken': restoreToken,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (copySourceAcl != null) 'copySourceAcl=$copySourceAcl',
      'generation=$generation',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'object=$object',
      if (projection != null) 'projection=$projection',
      if (restoreToken != null) 'restoreToken=$restoreToken',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'restoreRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Objects_RestoreRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_RestoreRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_RestoreRequest_Projection('noAcl');

  /// The default value for [Objects_RestoreRequest_Projection].
  static const $default = full;

  const Objects_RestoreRequest_Projection(super.value);

  factory Objects_RestoreRequest_Projection.fromJson(Object? json) =>
      Objects_RestoreRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [rewrite()][.objects.rewrite] method.
final class Objects_RewriteRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.rewriteRequest';

  /// Name of the bucket in which to store the new object. Overrides the provided object metadata's bucket value, if any.
  final String destinationBucket;

  /// Resource name of the Cloud KMS key, of the form projects/my-project/locations/global/keyRings/my-kr/cryptoKeys/my-key, that will be used to encrypt the object. Overrides the object metadata's kms_key_name value, if any.
  final String? destinationKmsKeyName;

  /// Name of the new object. Required when the object metadata is not otherwise provided. Overrides the object metadata's name value, if any. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String destinationObject;

  /// Apply a predefined set of access controls to the destination object.
  final Objects_RewriteRequest_DestinationPredefinedAcl?
  destinationPredefinedAcl;

  /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the destination object's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the destination object's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Makes the operation conditional on whether the source object's current generation matches the given value.
  final int? ifSourceGenerationMatch;

  /// Makes the operation conditional on whether the source object's current generation does not match the given value.
  final int? ifSourceGenerationNotMatch;

  /// Makes the operation conditional on whether the source object's current metageneration matches the given value.
  final int? ifSourceMetagenerationMatch;

  /// Makes the operation conditional on whether the source object's current metageneration does not match the given value.
  final int? ifSourceMetagenerationNotMatch;

  /// The maximum number of bytes that will be rewritten per rewrite request. Most callers shouldn't need to specify this parameter - it is primarily in place to support testing. If specified the value must be an integral multiple of 1 MiB (1048576). Also, this only applies to requests where the source and destination span locations and/or storage classes. Finally, this value must not change across rewrite calls else you'll get an error that the rewriteToken is invalid.
  final int? maxBytesRewrittenPerCall;

  /// Set of properties to return. Defaults to noAcl, unless the object resource specifies the acl property, when it defaults to full.
  final Objects_RewriteRequest_Projection? projection;

  /// Include this field (from the previous rewrite response) on each rewrite request after the first one, until the rewrite response 'done' flag is true. Calls that provide a rewriteToken can omit all other request fields, but if included those fields must match the values provided in the first rewrite request.
  final String? rewriteToken;

  /// Name of the bucket in which to find the source object.
  final String sourceBucket;

  /// If present, selects a specific revision of the source object (as opposed to the latest version, the default).
  final int? sourceGeneration;

  /// Name of the source object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String sourceObject;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [rewrite()][.objects.rewrite] method.
  final Object$? body;

  Objects_RewriteRequest({
    this.destinationBucket = '',
    this.destinationKmsKeyName,
    this.destinationObject = '',
    this.destinationPredefinedAcl,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.ifSourceGenerationMatch,
    this.ifSourceGenerationNotMatch,
    this.ifSourceMetagenerationMatch,
    this.ifSourceMetagenerationNotMatch,
    this.maxBytesRewrittenPerCall,
    this.projection,
    this.rewriteToken,
    this.sourceBucket = '',
    this.sourceGeneration,
    this.sourceObject = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Objects_RewriteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_RewriteRequest(
      destinationBucket: switch (json['destinationBucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationKmsKeyName: switch (json['destinationKmsKeyName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      destinationObject: switch (json['destinationObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationPredefinedAcl: switch (json['destinationPredefinedAcl']) {
        null => null,
        Object $1 => Objects_RewriteRequest_DestinationPredefinedAcl.fromJson(
          $1,
        ),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceGenerationMatch: switch (json['ifSourceGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceGenerationNotMatch: switch (json['ifSourceGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifSourceMetagenerationMatch:
          switch (json['ifSourceMetagenerationMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      ifSourceMetagenerationNotMatch:
          switch (json['ifSourceMetagenerationNotMatch']) {
            null => null,
            Object $1 => decodeInt64($1),
          },
      maxBytesRewrittenPerCall: switch (json['maxBytesRewrittenPerCall']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_RewriteRequest_Projection.fromJson($1),
      },
      rewriteToken: switch (json['rewriteToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      sourceBucket: switch (json['sourceBucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sourceGeneration: switch (json['sourceGeneration']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      sourceObject: switch (json['sourceObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Object$.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (destinationBucket.isNotDefault) 'destinationBucket': destinationBucket,
    if (destinationKmsKeyName != null)
      'destinationKmsKeyName': destinationKmsKeyName,
    if (destinationObject.isNotDefault) 'destinationObject': destinationObject,
    if (destinationPredefinedAcl != null)
      'destinationPredefinedAcl': destinationPredefinedAcl!.toJson(),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (ifSourceGenerationMatch != null)
      'ifSourceGenerationMatch': encodeInt64(ifSourceGenerationMatch),
    if (ifSourceGenerationNotMatch != null)
      'ifSourceGenerationNotMatch': encodeInt64(ifSourceGenerationNotMatch),
    if (ifSourceMetagenerationMatch != null)
      'ifSourceMetagenerationMatch': encodeInt64(ifSourceMetagenerationMatch),
    if (ifSourceMetagenerationNotMatch != null)
      'ifSourceMetagenerationNotMatch': encodeInt64(
        ifSourceMetagenerationNotMatch,
      ),
    if (maxBytesRewrittenPerCall != null)
      'maxBytesRewrittenPerCall': encodeInt64(maxBytesRewrittenPerCall),
    if (projection != null) 'projection': projection!.toJson(),
    if (rewriteToken != null) 'rewriteToken': rewriteToken,
    if (sourceBucket.isNotDefault) 'sourceBucket': sourceBucket,
    if (sourceGeneration != null)
      'sourceGeneration': encodeInt64(sourceGeneration),
    if (sourceObject.isNotDefault) 'sourceObject': sourceObject,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'destinationBucket=$destinationBucket',
      if (destinationKmsKeyName != null)
        'destinationKmsKeyName=$destinationKmsKeyName',
      'destinationObject=$destinationObject',
      if (destinationPredefinedAcl != null)
        'destinationPredefinedAcl=$destinationPredefinedAcl',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      if (ifSourceGenerationMatch != null)
        'ifSourceGenerationMatch=$ifSourceGenerationMatch',
      if (ifSourceGenerationNotMatch != null)
        'ifSourceGenerationNotMatch=$ifSourceGenerationNotMatch',
      if (ifSourceMetagenerationMatch != null)
        'ifSourceMetagenerationMatch=$ifSourceMetagenerationMatch',
      if (ifSourceMetagenerationNotMatch != null)
        'ifSourceMetagenerationNotMatch=$ifSourceMetagenerationNotMatch',
      if (maxBytesRewrittenPerCall != null)
        'maxBytesRewrittenPerCall=$maxBytesRewrittenPerCall',
      if (projection != null) 'projection=$projection',
      if (rewriteToken != null) 'rewriteToken=$rewriteToken',
      'sourceBucket=$sourceBucket',
      if (sourceGeneration != null) 'sourceGeneration=$sourceGeneration',
      'sourceObject=$sourceObject',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'rewriteRequest($contents)';
  }
}

/// The enumerated type for the `destinationPredefinedAcl` field.
final class Objects_RewriteRequest_DestinationPredefinedAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead =
      Objects_RewriteRequest_DestinationPredefinedAcl('authenticatedRead');

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl =
      Objects_RewriteRequest_DestinationPredefinedAcl('bucketOwnerFullControl');

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead =
      Objects_RewriteRequest_DestinationPredefinedAcl('bucketOwnerRead');

  /// Object owner gets OWNER access.
  static const private = Objects_RewriteRequest_DestinationPredefinedAcl(
    'private',
  );

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate = Objects_RewriteRequest_DestinationPredefinedAcl(
    'projectPrivate',
  );

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Objects_RewriteRequest_DestinationPredefinedAcl(
    'publicRead',
  );

  /// The default value for [Objects_RewriteRequest_DestinationPredefinedAcl].
  static const $default = authenticatedRead;

  const Objects_RewriteRequest_DestinationPredefinedAcl(super.value);

  factory Objects_RewriteRequest_DestinationPredefinedAcl.fromJson(
    Object? json,
  ) => Objects_RewriteRequest_DestinationPredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'destinationPredefinedAcl.$value';
}

/// The enumerated type for the `projection` field.
final class Objects_RewriteRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_RewriteRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_RewriteRequest_Projection('noAcl');

  /// The default value for [Objects_RewriteRequest_Projection].
  static const $default = full;

  const Objects_RewriteRequest_Projection(super.value);

  factory Objects_RewriteRequest_Projection.fromJson(Object? json) =>
      Objects_RewriteRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [setIamPolicy()][.objects.setIamPolicy] method.
final class Objects_SetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.setIamPolicyRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [setIamPolicy()][.objects.setIamPolicy] method.
  final Policy? body;

  Objects_SetIamPolicyRequest({
    this.bucket = '',
    this.generation,
    this.object = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Objects_SetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_SetIamPolicyRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Policy.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      'object=$object',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'setIamPolicyRequest($contents)';
  }
}

/// Synthetic request message for the [testIamPermissions()][.objects.testIamPermissions] method.
final class Objects_TestIamPermissionsRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.testIamPermissionsRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// Permissions to test.
  final String permissions;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  Objects_TestIamPermissionsRequest({
    this.bucket = '',
    this.generation,
    this.object = '',
    this.permissions = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory Objects_TestIamPermissionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_TestIamPermissionsRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      permissions: switch (json['permissions']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (object.isNotDefault) 'object': object,
    if (permissions.isNotDefault) 'permissions': permissions,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      'object=$object',
      'permissions=$permissions',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'testIamPermissionsRequest($contents)';
  }
}

/// Synthetic request message for the [update()][.objects.update] method.
final class Objects_UpdateRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.updateRequest';

  /// Name of the bucket in which the object resides.
  final String bucket;

  /// If present, selects a specific revision of this object (as opposed to the latest version, the default).
  final int? generation;

  /// Makes the operation conditional on whether the object's current generation matches the given value. Setting to 0 makes the operation succeed only if there are no live versions of the object.
  final int? ifGenerationMatch;

  /// Makes the operation conditional on whether the object's current generation does not match the given value. If no live object exists, the precondition fails. Setting to 0 makes the operation succeed only if there is a live version of the object.
  final int? ifGenerationNotMatch;

  /// Makes the operation conditional on whether the object's current metageneration matches the given value.
  final int? ifMetagenerationMatch;

  /// Makes the operation conditional on whether the object's current metageneration does not match the given value.
  final int? ifMetagenerationNotMatch;

  /// Name of the object. For information about how to URL encode object names to be path safe, see [Encoding URI Path Parts](https://cloud.google.com/storage/docs/request-endpoints#encoding).
  final String object;

  /// Must be true to remove the retention configuration, reduce its unlocked retention period, or change its mode from unlocked to locked.
  final bool? overrideUnlockedRetention;

  /// Apply a predefined set of access controls to this object.
  final Objects_UpdateRequest_PredefinedAcl? predefinedAcl;

  /// Set of properties to return. Defaults to full.
  final Objects_UpdateRequest_Projection? projection;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// Synthetic request body field for the [update()][.objects.update] method.
  final Object$? body;

  Objects_UpdateRequest({
    this.bucket = '',
    this.generation,
    this.ifGenerationMatch,
    this.ifGenerationNotMatch,
    this.ifMetagenerationMatch,
    this.ifMetagenerationNotMatch,
    this.object = '',
    this.overrideUnlockedRetention,
    this.predefinedAcl,
    this.projection,
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory Objects_UpdateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_UpdateRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationMatch: switch (json['ifGenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifGenerationNotMatch: switch (json['ifGenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationMatch: switch (json['ifMetagenerationMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      ifMetagenerationNotMatch: switch (json['ifMetagenerationNotMatch']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      overrideUnlockedRetention: switch (json['overrideUnlockedRetention']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      predefinedAcl: switch (json['predefinedAcl']) {
        null => null,
        Object $1 => Objects_UpdateRequest_PredefinedAcl.fromJson($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_UpdateRequest_Projection.fromJson($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Object$.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (generation != null) 'generation': encodeInt64(generation),
    if (ifGenerationMatch != null)
      'ifGenerationMatch': encodeInt64(ifGenerationMatch),
    if (ifGenerationNotMatch != null)
      'ifGenerationNotMatch': encodeInt64(ifGenerationNotMatch),
    if (ifMetagenerationMatch != null)
      'ifMetagenerationMatch': encodeInt64(ifMetagenerationMatch),
    if (ifMetagenerationNotMatch != null)
      'ifMetagenerationNotMatch': encodeInt64(ifMetagenerationNotMatch),
    if (object.isNotDefault) 'object': object,
    if (overrideUnlockedRetention != null)
      'overrideUnlockedRetention': overrideUnlockedRetention,
    if (predefinedAcl != null) 'predefinedAcl': predefinedAcl!.toJson(),
    if (projection != null) 'projection': projection!.toJson(),
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (generation != null) 'generation=$generation',
      if (ifGenerationMatch != null) 'ifGenerationMatch=$ifGenerationMatch',
      if (ifGenerationNotMatch != null)
        'ifGenerationNotMatch=$ifGenerationNotMatch',
      if (ifMetagenerationMatch != null)
        'ifMetagenerationMatch=$ifMetagenerationMatch',
      if (ifMetagenerationNotMatch != null)
        'ifMetagenerationNotMatch=$ifMetagenerationNotMatch',
      'object=$object',
      if (overrideUnlockedRetention != null)
        'overrideUnlockedRetention=$overrideUnlockedRetention',
      if (predefinedAcl != null) 'predefinedAcl=$predefinedAcl',
      if (projection != null) 'projection=$projection',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'updateRequest($contents)';
  }
}

/// The enumerated type for the `predefinedAcl` field.
final class Objects_UpdateRequest_PredefinedAcl extends ProtoEnum {
  /// Object owner gets OWNER access, and allAuthenticatedUsers get READER access.
  static const authenticatedRead = Objects_UpdateRequest_PredefinedAcl(
    'authenticatedRead',
  );

  /// Object owner gets OWNER access, and project team owners get OWNER access.
  static const bucketOwnerFullControl = Objects_UpdateRequest_PredefinedAcl(
    'bucketOwnerFullControl',
  );

  /// Object owner gets OWNER access, and project team owners get READER access.
  static const bucketOwnerRead = Objects_UpdateRequest_PredefinedAcl(
    'bucketOwnerRead',
  );

  /// Object owner gets OWNER access.
  static const private = Objects_UpdateRequest_PredefinedAcl('private');

  /// Object owner gets OWNER access, and project team members get access according to their roles.
  static const projectPrivate = Objects_UpdateRequest_PredefinedAcl(
    'projectPrivate',
  );

  /// Object owner gets OWNER access, and allUsers get READER access.
  static const publicRead = Objects_UpdateRequest_PredefinedAcl('publicRead');

  /// The default value for [Objects_UpdateRequest_PredefinedAcl].
  static const $default = authenticatedRead;

  const Objects_UpdateRequest_PredefinedAcl(super.value);

  factory Objects_UpdateRequest_PredefinedAcl.fromJson(Object? json) =>
      Objects_UpdateRequest_PredefinedAcl(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'predefinedAcl.$value';
}

/// The enumerated type for the `projection` field.
final class Objects_UpdateRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_UpdateRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_UpdateRequest_Projection('noAcl');

  /// The default value for [Objects_UpdateRequest_Projection].
  static const $default = full;

  const Objects_UpdateRequest_Projection(super.value);

  factory Objects_UpdateRequest_Projection.fromJson(Object? json) =>
      Objects_UpdateRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic request message for the [watchAll()][.objects.watchAll] method.
final class Objects_WatchAllRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.objects.watchAllRequest';

  /// Name of the bucket in which to look for objects.
  final String bucket;

  /// Returns results in a directory-like mode. items will contain only objects whose names, aside from the prefix, do not contain delimiter. Objects whose names, aside from the prefix, contain delimiter will have their name, truncated after the delimiter, returned in prefixes. Duplicate prefixes are omitted.
  final String? delimiter;

  /// Filter results to objects whose names are lexicographically before endOffset. If startOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
  final String? endOffset;

  /// If true, objects that end in exactly one instance of delimiter will have their metadata included in items in addition to prefixes.
  final bool? includeTrailingDelimiter;

  /// Maximum number of items plus prefixes to return in a single page of responses. As duplicate prefixes are omitted, fewer total results may be returned than requested. The service will use this parameter or 1,000 items, whichever is smaller.
  final int? maxResults;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  /// Filter results to objects whose names begin with this prefix.
  final String? prefix;

  /// Set of properties to return. Defaults to noAcl.
  final Objects_WatchAllRequest_Projection? projection;

  /// Filter results to objects whose names are lexicographically equal to or after startOffset. If endOffset is also set, the objects listed will have names between startOffset (inclusive) and endOffset (exclusive).
  final String? startOffset;

  /// The project to be billed for this request. Required for Requester Pays buckets.
  final String? userProject;

  /// If true, lists all versions of an object as distinct results. The default is false. For more information, see [Object Versioning](https://cloud.google.com/storage/docs/object-versioning).
  final bool? versions;

  /// Synthetic request body field for the [watchAll()][.objects.watchAll] method.
  final Channel? body;

  Objects_WatchAllRequest({
    this.bucket = '',
    this.delimiter,
    this.endOffset,
    this.includeTrailingDelimiter,
    this.maxResults,
    this.pageToken,
    this.prefix,
    this.projection,
    this.startOffset,
    this.userProject,
    this.versions,
    this.body,
  }) : super(fullyQualifiedName);

  factory Objects_WatchAllRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Objects_WatchAllRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      delimiter: switch (json['delimiter']) {
        null => null,
        Object $1 => decodeString($1),
      },
      endOffset: switch (json['endOffset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      includeTrailingDelimiter: switch (json['includeTrailingDelimiter']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      maxResults: switch (json['maxResults']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      prefix: switch (json['prefix']) {
        null => null,
        Object $1 => decodeString($1),
      },
      projection: switch (json['projection']) {
        null => null,
        Object $1 => Objects_WatchAllRequest_Projection.fromJson($1),
      },
      startOffset: switch (json['startOffset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      versions: switch (json['versions']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => Channel.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (delimiter != null) 'delimiter': delimiter,
    if (endOffset != null) 'endOffset': endOffset,
    if (includeTrailingDelimiter != null)
      'includeTrailingDelimiter': includeTrailingDelimiter,
    if (maxResults != null) 'maxResults': maxResults,
    if (pageToken != null) 'pageToken': pageToken,
    if (prefix != null) 'prefix': prefix,
    if (projection != null) 'projection': projection!.toJson(),
    if (startOffset != null) 'startOffset': startOffset,
    if (userProject != null) 'userProject': userProject,
    if (versions != null) 'versions': versions,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (delimiter != null) 'delimiter=$delimiter',
      if (endOffset != null) 'endOffset=$endOffset',
      if (includeTrailingDelimiter != null)
        'includeTrailingDelimiter=$includeTrailingDelimiter',
      if (maxResults != null) 'maxResults=$maxResults',
      if (pageToken != null) 'pageToken=$pageToken',
      if (prefix != null) 'prefix=$prefix',
      if (projection != null) 'projection=$projection',
      if (startOffset != null) 'startOffset=$startOffset',
      if (userProject != null) 'userProject=$userProject',
      if (versions != null) 'versions=$versions',
    ].join(',');
    return 'watchAllRequest($contents)';
  }
}

/// The enumerated type for the `projection` field.
final class Objects_WatchAllRequest_Projection extends ProtoEnum {
  /// Include all properties.
  static const full = Objects_WatchAllRequest_Projection('full');

  /// Omit the owner, acl property.
  static const noAcl = Objects_WatchAllRequest_Projection('noAcl');

  /// The default value for [Objects_WatchAllRequest_Projection].
  static const $default = full;

  const Objects_WatchAllRequest_Projection(super.value);

  factory Objects_WatchAllRequest_Projection.fromJson(Object? json) =>
      Objects_WatchAllRequest_Projection(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'projection.$value';
}

/// Synthetic messages for the `operations` service
final class Operations extends ProtoMessage {
  static const String fullyQualifiedName = '.operations';

  Operations() : super(fullyQualifiedName);

  factory Operations.fromJson(Object? j) => Operations();

  @override
  Object toJson() => {};

  @override
  String toString() => 'operations()';
}

/// Synthetic request message for the [advanceRelocateBucket()][.operations.advanceRelocateBucket] method.
final class Operations_AdvanceRelocateBucketRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      '.operations.advanceRelocateBucketRequest';

  /// Name of the bucket to advance the relocate for.
  final String bucket;

  /// ID of the operation resource.
  final String operationId;

  /// Synthetic request body field for the [advanceRelocateBucket()][.operations.advanceRelocateBucket] method.
  final AdvanceRelocateBucketOperationRequest? body;

  Operations_AdvanceRelocateBucketRequest({
    this.bucket = '',
    this.operationId = '',
    this.body,
  }) : super(fullyQualifiedName);

  factory Operations_AdvanceRelocateBucketRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Operations_AdvanceRelocateBucketRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operationId: switch (json['operationId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => AdvanceRelocateBucketOperationRequest.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (operationId.isNotDefault) 'operationId': operationId,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = ['bucket=$bucket', 'operationId=$operationId'].join(',');
    return 'advanceRelocateBucketRequest($contents)';
  }
}

/// Synthetic request message for the [cancel()][.operations.cancel] method.
final class Operations_CancelRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.operations.cancelRequest';

  /// The parent bucket of the operation resource.
  final String bucket;

  /// The ID of the operation resource.
  final String operationId;

  Operations_CancelRequest({this.bucket = '', this.operationId = ''})
    : super(fullyQualifiedName);

  factory Operations_CancelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Operations_CancelRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operationId: switch (json['operationId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (operationId.isNotDefault) 'operationId': operationId,
  };

  @override
  String toString() {
    final contents = ['bucket=$bucket', 'operationId=$operationId'].join(',');
    return 'cancelRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.operations.get] method.
final class Operations_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.operations.getRequest';

  /// The parent bucket of the operation resource.
  final String bucket;

  /// The ID of the operation resource.
  final String operationId;

  Operations_GetRequest({this.bucket = '', this.operationId = ''})
    : super(fullyQualifiedName);

  factory Operations_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Operations_GetRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operationId: switch (json['operationId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (operationId.isNotDefault) 'operationId': operationId,
  };

  @override
  String toString() {
    final contents = ['bucket=$bucket', 'operationId=$operationId'].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.operations.list] method.
final class Operations_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.operations.listRequest';

  /// Name of the bucket in which to look for operations.
  final String bucket;

  /// A filter to narrow down results to a preferred subset. The filtering language is documented in more detail in [AIP-160](https://google.aip.dev/160).
  final String? filter;

  /// Maximum number of items to return in a single page of responses. Fewer total results may be returned than requested. The service uses this parameter or 100 items, whichever is smaller.
  final int? pageSize;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  Operations_ListRequest({
    this.bucket = '',
    this.filter,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory Operations_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Operations_ListRequest(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => null,
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (filter != null) 'filter': filter,
    if (pageSize != null) 'pageSize': pageSize,
    if (pageToken != null) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic messages for the `hmacKeys` service
final class HmacKeys extends ProtoMessage {
  static const String fullyQualifiedName = '.hmacKeys';

  HmacKeys() : super(fullyQualifiedName);

  factory HmacKeys.fromJson(Object? j) => HmacKeys();

  @override
  Object toJson() => {};

  @override
  String toString() => 'hmacKeys()';
}

/// Synthetic request message for the [create()][.hmacKeys.create] method.
final class HmacKeys_CreateRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.hmacKeys.createRequest';

  /// Project ID owning the service account.
  final String projectId;

  /// Email address of the service account.
  final String serviceAccountEmail;

  /// The project to be billed for this request.
  final String? userProject;

  HmacKeys_CreateRequest({
    this.projectId = '',
    this.serviceAccountEmail = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory HmacKeys_CreateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKeys_CreateRequest(
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAccountEmail: switch (json['serviceAccountEmail']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (projectId.isNotDefault) 'projectId': projectId,
    if (serviceAccountEmail.isNotDefault)
      'serviceAccountEmail': serviceAccountEmail,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'projectId=$projectId',
      'serviceAccountEmail=$serviceAccountEmail',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'createRequest($contents)';
  }
}

/// Synthetic request message for the [delete()][.hmacKeys.delete] method.
final class HmacKeys_DeleteRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.hmacKeys.deleteRequest';

  /// Name of the HMAC key to be deleted.
  final String accessId;

  /// Project ID owning the requested key
  final String projectId;

  /// The project to be billed for this request.
  final String? userProject;

  HmacKeys_DeleteRequest({
    this.accessId = '',
    this.projectId = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory HmacKeys_DeleteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKeys_DeleteRequest(
      accessId: switch (json['accessId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (accessId.isNotDefault) 'accessId': accessId,
    if (projectId.isNotDefault) 'projectId': projectId,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'accessId=$accessId',
      'projectId=$projectId',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'deleteRequest($contents)';
  }
}

/// Synthetic request message for the [get()][.hmacKeys.get] method.
final class HmacKeys_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.hmacKeys.getRequest';

  /// Name of the HMAC key.
  final String accessId;

  /// Project ID owning the service account of the requested key.
  final String projectId;

  /// The project to be billed for this request.
  final String? userProject;

  HmacKeys_GetRequest({
    this.accessId = '',
    this.projectId = '',
    this.userProject,
  }) : super(fullyQualifiedName);

  factory HmacKeys_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKeys_GetRequest(
      accessId: switch (json['accessId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (accessId.isNotDefault) 'accessId': accessId,
    if (projectId.isNotDefault) 'projectId': projectId,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'accessId=$accessId',
      'projectId=$projectId',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}

/// Synthetic request message for the [list()][.hmacKeys.list] method.
final class HmacKeys_ListRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.hmacKeys.listRequest';

  /// Maximum number of items to return in a single page of responses. The service uses this parameter or 250 items, whichever is smaller. The max number of items per page will also be limited by the number of distinct service accounts in the response. If the number of service accounts in a single response is too high, the page will truncated and a next page token will be returned.
  final int? maxResults;

  /// A previously-returned page token representing part of the larger set of results to view.
  final String? pageToken;

  /// Name of the project in which to look for HMAC keys.
  final String projectId;

  /// If present, only keys for the given service account are returned.
  final String? serviceAccountEmail;

  /// Whether or not to show keys in the DELETED state.
  final bool? showDeletedKeys;

  /// The project to be billed for this request.
  final String? userProject;

  HmacKeys_ListRequest({
    this.maxResults,
    this.pageToken,
    this.projectId = '',
    this.serviceAccountEmail,
    this.showDeletedKeys,
    this.userProject,
  }) : super(fullyQualifiedName);

  factory HmacKeys_ListRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKeys_ListRequest(
      maxResults: switch (json['maxResults']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAccountEmail: switch (json['serviceAccountEmail']) {
        null => null,
        Object $1 => decodeString($1),
      },
      showDeletedKeys: switch (json['showDeletedKeys']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxResults != null) 'maxResults': maxResults,
    if (pageToken != null) 'pageToken': pageToken,
    if (projectId.isNotDefault) 'projectId': projectId,
    if (serviceAccountEmail != null) 'serviceAccountEmail': serviceAccountEmail,
    if (showDeletedKeys != null) 'showDeletedKeys': showDeletedKeys,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      if (maxResults != null) 'maxResults=$maxResults',
      if (pageToken != null) 'pageToken=$pageToken',
      'projectId=$projectId',
      if (serviceAccountEmail != null)
        'serviceAccountEmail=$serviceAccountEmail',
      if (showDeletedKeys != null) 'showDeletedKeys=$showDeletedKeys',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'listRequest($contents)';
  }
}

/// Synthetic request message for the [update()][.hmacKeys.update] method.
final class HmacKeys_UpdateRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.hmacKeys.updateRequest';

  /// Name of the HMAC key being updated.
  final String accessId;

  /// Project ID owning the service account of the updated key.
  final String projectId;

  /// The project to be billed for this request.
  final String? userProject;

  /// Synthetic request body field for the [update()][.hmacKeys.update] method.
  final HmacKeyMetadata? body;

  HmacKeys_UpdateRequest({
    this.accessId = '',
    this.projectId = '',
    this.userProject,
    this.body,
  }) : super(fullyQualifiedName);

  factory HmacKeys_UpdateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HmacKeys_UpdateRequest(
      accessId: switch (json['accessId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
      body: switch (json['body']) {
        null => null,
        Object $1 => HmacKeyMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (accessId.isNotDefault) 'accessId': accessId,
    if (projectId.isNotDefault) 'projectId': projectId,
    if (userProject != null) 'userProject': userProject,
    if (body != null) 'body': body!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'accessId=$accessId',
      'projectId=$projectId',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'updateRequest($contents)';
  }
}

/// Synthetic messages for the `serviceAccount` service
final class ServiceAccount extends ProtoMessage {
  static const String fullyQualifiedName = '.serviceAccount';

  ServiceAccount() : super(fullyQualifiedName);

  factory ServiceAccount.fromJson(Object? j) => ServiceAccount();

  @override
  Object toJson() => {};

  @override
  String toString() => 'serviceAccount()';
}

/// Synthetic request message for the [get()][.serviceAccount.get] method.
final class ServiceAccount_GetRequest extends ProtoMessage {
  static const String fullyQualifiedName = '.serviceAccount.getRequest';

  /// Project ID
  final String projectId;

  /// The project to be billed for this request.
  final String? userProject;

  ServiceAccount_GetRequest({this.projectId = '', this.userProject})
    : super(fullyQualifiedName);

  factory ServiceAccount_GetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ServiceAccount_GetRequest(
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      userProject: switch (json['userProject']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (projectId.isNotDefault) 'projectId': projectId,
    if (userProject != null) 'userProject': userProject,
  };

  @override
  String toString() {
    final contents = [
      'projectId=$projectId',
      if (userProject != null) 'userProject=$userProject',
    ].join(',');
    return 'getRequest($contents)';
  }
}
